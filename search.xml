<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2025/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>NPD介绍</title>
    <url>/2025/07/devops/npd/NPD%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>官方文档库地址：<a href="https://github.com/kubernetes/node-problem-detector">https://github.com/kubernetes/node-problem-detector</a></p>
<p>node-problem-detector 旨在使集群管理堆栈中的上游层能够看到各种节点问题。</p>
<p>它是一个在每个节点上运行的守护进程，检测节点问题并将其报告给apiserver。</p>
<p>node-problem-detector 可以作为 DaemonSet 运行，也可以独立运行。</p>
<p>现在它作为 GKE集群中默认启用的Kubernetes Addon运行。它也作为AKS Linux Extension的一部分在 AKS 中默认启用。</p>
<h2 id="1-2-背景"><a href="#1-2-背景" class="headerlink" title="1.2 背景"></a>1.2 背景</h2><p>大量节点问题可能会影响节点上运行的 pod，例如：</p>
<ul>
<li>基础设施守护进程问题：ntp 服务关闭；</li>
<li>硬件问题：CPU、内存或磁盘损坏；</li>
<li>内核问题：内核死锁、文件系统损坏；</li>
<li>容器运行时问题：运行时守护进程无响应；</li>
<li>…</li>
</ul>
<p>目前，这些问题对于集群管理堆栈中的上游层是不可见的，因此 Kubernetes 将继续将 pod 调度到坏节点。<br>为了解决这个问题，我们引入了这个新的守护进程node-problem-detector来从各种守护进程收集节点问题，并将它们提供给上游层。一旦上游层能够看到这些问题，我们就可以讨论 <a href="https://github.com/kubernetes/node-problem-detector?tab=readme-ov-file#remedy-systems">remedy systems</a>了。</p>
<h2 id="1-3-Problem-API"><a href="#1-3-Problem-API" class="headerlink" title="1.3 Problem API"></a>1.3 Problem API</h2><p>node-problem-detector 使用Event并向NodeConditionapiserver 报告问题。</p>
<ul>
<li>NodeCondition：导致节点无法用于 pod 的永久性问题应报告为NodeCondition。</li>
<li>Event：对 pod 影响有限但具有参考意义的临时问题应报告为Event。</li>
</ul>
<h2 id="1-4-Problem-Daemon"><a href="#1-4-Problem-Daemon" class="headerlink" title="1.4 Problem Daemon"></a>1.4 Problem Daemon</h2><p>问题守护进程是 node-problem-detector 的一个子守护进程。它监视特定类型的节点问题并将其报告给 node-problem-detector。<br>守护进程可能是：</p>
<ul>
<li>专为 Kubernetes 专用用例设计的微型守护进程。</li>
<li>与节点问题检测器集成的现有节点健康监控守护进程。</li>
</ul>
<p>目前，问题守护进程在 node-problem-detector 二进制文件中以 goroutine 的形式运行。</p>
<p>未来，我们会将 node-problem-detector和问题守护进程分离到不同的容器中，并使用 pod 规范将它们组合在一起。</p>
<p>每种类型的问题守护进程都可以通过设置相应的构建标签在编译时禁用。</p>
<p>如果在编译时禁用它们，则它们的所有构建依赖项、全局变量和后台goroutine 都将从编译的可执行文件中剔除。</p>
<p>支持的守护进程列表：</p>
<table>
<thead>
<tr>
<th>问题守护进程类型</th>
<th>节点状态</th>
<th>解释</th>
<th>配置</th>
<th>禁用构建标签</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/systemlogmonitor">SystemLogMonitor</a></td>
<td>KernelDeadlock ReadonlyFilesystem FrequentKubeletRestart FrequentDockerRestart FrequentContainerdRestart</td>
<td>系统日志监视器监视系统日志并根据预定义的规则报告问题和指标。</td>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor-filelog.json">filelog</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor.json">kmsg</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor-counter.json">kernel</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/systemd-monitor-counter.json">abrt</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/systemd-monitor-counter.json">systemd</a></td>
<td>disable_system_log_monitor</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/systemstatsmonitor">SystemStatsMonitor</a></td>
<td>None(Could be added in the future)</td>
<td>节点问题检测器的系统统计监视器，用于收集各种与健康相关的系统统计信息作为指标。请参阅<a href="https://docs.google.com/document/d/1SeaUz6kBavI283Dq8GBpoEUDrHA2a795xtw0OvjM568/edit">此处</a>的提案。</td>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/system-stats-monitor.json">system-stats-monitor</a></td>
<td>disable_system_stats_monitor</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/custompluginmonitor">CustomPluginMonitor</a></td>
<td>On-demand(According to users configuration), existing example: NTPProblem</td>
<td>一个自定义的 node-problem-detector 插件监控器，用于调用和检查各种节点问题，并使用用户定义的检查脚本。请参阅<a href="https://docs.google.com/document/d/1jK_5YloSYtboj-DtfjmYKxfNnUxCAvohLnsH5aGCAYQ/edit#">此处</a>的提案。</td>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/4ad49bbd84b8ced45ac825eac01ec93d9235935e/config/custom-plugin-monitor.json">example</a></td>
<td>disable_custom_plugin_monitor</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/healthchecker">HealthChecker</a></td>
<td>KubeletUnhealthy ContainerRuntimeUnhealthy</td>
<td>节点问题检测器的健康检查器用于检查 kubelet 和容器运行时的健康状况。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-5-Exporter"><a href="#1-5-Exporter" class="headerlink" title="1.5 Exporter"></a>1.5 Exporter</h2><p>exporter 是 node-problem-detector 的一个组件。</p>
<p>它向某些后端报告节点问题 和&#x2F;或 指标。</p>
<p>其中一些可以在编译时使用构建标记禁用。支持的导出器列表：</p>
<table>
<thead>
<tr>
<th>Exporter</th>
<th>解释</th>
<th>禁用构建标签</th>
</tr>
</thead>
<tbody><tr>
<td>Kubernetes exporter</td>
<td>Kubernetes 导出器向 Kubernetes API 服务器报告节点问题：临时问题报告为事件，永久问题报告为节点状况。</td>
<td></td>
</tr>
<tr>
<td>Prometheus exporter</td>
<td>Prometheus 导出器将节点问题和指标本地报告为 Prometheus 指标</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/exporter/stackdriver-exporter.json">Stackdriver exporter</a></td>
<td>Stackdriver 导出器向 Stackdriver Monitoring API 报告节点问题和指标。</td>
<td>disable_stackdriver_exporter</td>
</tr>
</tbody></table>
<h2 id="1-6-用法"><a href="#1-6-用法" class="headerlink" title="1.6 用法"></a>1.6 用法</h2><h3 id="1-6-1-标志"><a href="#1-6-1-标志" class="headerlink" title="1.6.1 标志"></a>1.6.1 标志</h3><ul>
<li>–version：打印节点问题检测器的当前版本。</li>
<li>–hostname-override：node-problem-detector 用于更新状态和发出事件的自定义节点名称。node-problem-detector 首先从hostname-override获取节点名称，然后从NODE_NAME环境变量 获取，最后返回到os.Hostname。</li>
</ul>
<h3 id="1-6-2-对于系统日志监控"><a href="#1-6-2-对于系统日志监控" class="headerlink" title="1.6.2 对于系统日志监控"></a>1.6.2 对于系统日志监控</h3><ul>
<li>–config.system-log-monitor：系统日志监视器配置文件路径列表，以逗号分隔，例如 config&#x2F;kernel-monitor.json。节点问题检测器将为每个配置启动单独的日志监视器。您可以使用不同的日志监视器来监视不同的系统日志。</li>
</ul>
<h3 id="1-6-3-对于系统统计监控"><a href="#1-6-3-对于系统统计监控" class="headerlink" title="1.6.3 对于系统统计监控"></a>1.6.3 对于系统统计监控</h3><ul>
<li>–config.system-stats-monitor：系统统计监控配置文件的路径列表，以逗号分隔，例如 <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/system-stats-monitor.json">config&#x2F;system-stats-monitor.json</a>。节点问题检测器将为每个配置启动一个单独的系统统计监控器。您可以使用不同的系统统计监控器来监控与问题相关的不同系统统计信息。</li>
</ul>
<h3 id="1-6-4-对于自定义插件监视器"><a href="#1-6-4-对于自定义插件监视器" class="headerlink" title="1.6.4 对于自定义插件监视器"></a>1.6.4 对于自定义插件监视器</h3><ul>
<li>–config.custom-plugin-monitor：自定义插件监控配置文件路径列表，以逗号分隔，例如 <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/custom-plugin-monitor.json">config&#x2F;custom-plugin-monitor.json</a>。节点问题检测器将为每个配置启动一个单独的自定义插件监控。您可以使用不同的自定义插件监控来监控不同的节点问题。</li>
</ul>
<h3 id="1-6-5-对于健康检查者"><a href="#1-6-5-对于健康检查者" class="headerlink" title="1.6.5 对于健康检查者"></a>1.6.5 对于健康检查者</h3><ul>
<li>–enable-k8s-exporter：启用向 Kubernetes API 服务器报告，默认为true。</li>
<li>–apiserver-override：用于自定义 node-problem-detector 如何连接 apiserver 的 URI 参数。如果–enable-k8s-exporter是，则忽略此参数。格式与<a href="https://github.com/kubernetes/heapster">Heapster</a> 的标志false相同。例如，要无需身份验证即可运行，请使用以下配置： <a href="https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md#kubernetes">source</a></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://APISERVER_IP:APISERVER_PORT?inClusterConfig=false</span><br></pre></td></tr></table></figure>

<p>请参阅<a href="https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md#kubernetes">heapster 文档</a><br>以获取可用选项的完整列表。</p>
<ul>
<li>–address：绑定节点问题检测服务器的地址。</li>
<li>–port：绑定节点问题检测服务器的端口。使用 0 表示禁用。</li>
</ul>
<h3 id="1-6-6-对于-Prometheus-exporter"><a href="#1-6-6-对于-Prometheus-exporter" class="headerlink" title="1.6.6 对于 Prometheus exporter"></a>1.6.6 对于 Prometheus exporter</h3><ul>
<li>–prometheus-address：绑定Prometheus抓取端点的地址，默认为127.0.0.1。</li>
<li>–prometheus-port：绑定 Prometheus 抓取端点的端口，默认为 20257。使用 0 表示禁用。</li>
</ul>
<h3 id="1-6-7-对于-Stackdriver-exporter"><a href="#1-6-7-对于-Stackdriver-exporter" class="headerlink" title="1.6.7 对于 Stackdriver exporter"></a>1.6.7 对于 Stackdriver exporter</h3><ul>
<li>–exporter.stackdriver：Stackdriver 导出器配置文件的路径，例如config&#x2F;exporter&#x2F;stackdriver-exporter.json，默认为空字符串。设置为空字符串即可禁用。</li>
</ul>
<h3 id="1-6-8-已弃用的标志"><a href="#1-6-8-已弃用的标志" class="headerlink" title="1.6.8 已弃用的标志"></a>1.6.8 已弃用的标志</h3><ul>
<li>–system-log-monitors：系统日志监控配置文件的路径列表，以逗号分隔。此选项已弃用，由–config.system-log-monitor替代，并将被删除。如果同时设置–system-log-monitors和 –config.system-log-monitor ， NPD 将崩溃。</li>
<li>–custom-plugin-monitors：自定义插件监控配置文件的路径列表，以逗号分隔。此选项已弃用，由–config.custom-plugin-monitor替代，并将被删除。如果同时设置–custom-plugin-monitors和 –config.custom-plugin-monitor，NPD 将崩溃。</li>
</ul>
<h2 id="1-7-构建镜像"><a href="#1-7-构建镜像" class="headerlink" title="1.7 构建镜像"></a>1.7 构建镜像</h2><ul>
<li>安装libsystemdARM GCC 工具链的开发依赖项<ul>
<li>Debian &#x2F; Ubuntu：apt install libsystemd-dev gcc-aarch64-linux-gnu</li>
</ul>
</li>
<li>git clone <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#x6f;&#109;</a>:kubernetes&#x2F;node-problem-detector.git</li>
<li>在顶层目录中运行make。它将：<ul>
<li>构建二进制文件。</li>
<li>构建docker镜像。二进制文件和config&#x2F;被复制到docker镜像中。</li>
</ul>
</li>
</ul>
<p>如果您不需要某些类别的问题守护进程，您可以选择在编译时禁用它们。这是保持 node-problem-detector运行时紧凑且没有不必要代码（例如全局变量、goroutines 等）的最佳方法。</p>
<p>您可以通过BUILD_TAGS在运行之前设置环境变量来实现这一点make。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BUILD_TAGS=&quot;disable_custom_plugin_monitor disable_system_stats_monitor&quot; make</span><br></pre></td></tr></table></figure>

<p>上述命令将在不使用<a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/custompluginmonitor">自定义插件监视器</a>和<a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/systemstatsmonitor">系统统计监视器</a>的情况下编译node-problem-detector 。查看<a href="https://github.com/kubernetes/node-problem-detector#problem-daemon">问题守护进程</a>部分，了解如何在编译时禁用每个问题守护进程。</p>
<h2 id="1-8-推送镜像"><a href="#1-8-推送镜像" class="headerlink" title="1.8 推送镜像"></a>1.8 推送镜像</h2><p><code>make push</code>将 docker 镜像上传到注册表。默认情况下，镜像将上传到 <code>staging-k8s.gcr.io</code>。可以轻松修改<code>Makefile</code>以将镜像推送到另一个注册表。</p>
<h2 id="1-9-安装"><a href="#1-9-安装" class="headerlink" title="1.9 安装"></a>1.9 安装</h2><p>将 node-problem-detector<br>安装到集群中的最简单方法是使用<a href="https://github.com/deliveryhero/helm-charts/tree/master/stable/node-problem-detector">Helm 图表</a>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm repo add deliveryhero https://charts.deliveryhero.io/</span><br><span class="line">helm install --generate-name deliveryhero/node-problem-detector</span><br></pre></td></tr></table></figure>

<p>或者，手动安装 node-problem-detector：</p>
<p>编辑<a href="https://github.com/kubernetes/node-problem-detector/blob/master/deployment/node-problem-detector.yaml">node-problem-detector.yaml</a>以适应您的环境。将<code>log</code>卷设置为您的系统日志目录（由 SystemLogMonitor 使用）。您可以使用 ConfigMap 覆盖<code>config</code> pod 内的目录。</p>
<p>编辑<a href="https://github.com/kubernetes/node-problem-detector/blob/master/deployment/node-problem-detector-config.yaml">node-problem-detector-config.yaml</a>来配置 node-problem-detector。</p>
<ul>
<li>编辑<a href="https://github.com/kubernetes/node-problem-detector/blob/master/deployment/rbac.yaml">rbac.yaml</a>以适合您的环境。</li>
<li>使用 创建 ServiceAccount 和 ClusterRoleBinding <code>kubectl create -f rbac.yaml</code>。</li>
<li>使用 创建 ConfigMap <code>kubectl create -f node-problem-detector-config.yaml</code>。</li>
<li>使用 创建 DaemonSet <code>kubectl create -f node-problem-detector.yaml</code>。</li>
</ul>
<h2 id="1-10-开始独立运行"><a href="#1-10-开始独立运行" class="headerlink" title="1.10 开始独立运行"></a>1.10 开始独立运行</h2><p>要独立运行 node-problem-detector，您应该设置inClusterConfig为false，并且教 node-problem-detector 如何 访问 apiserver，也就是apiserver-override。</p>
<p>要使用不安全的 apiserver 连接独立运行 node-problem-detector：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node-problem-detector --apiserver-override=http://APISERVER_IP:APISERVER_INSECURE_PORT?inClusterConfig=false</span><br></pre></td></tr></table></figure>

<p>更多场景请见<a href="https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md#kubernetes">此处</a></p>
<h2 id="1-11-试用"><a href="#1-11-试用" class="headerlink" title="1.11 试用"></a>1.11 试用</h2><p>您可以在正在运行的集群中尝试使用 node-problem-detector，方法是将消息注入到 node-problem-detector 正在监视的日志中。</p>
<p>例如，假设 node-problem-detector 正在使用KernelMonitor。</p>
<p>在您的机器上运行<code>kubectl get events -w</code>。在节点上运行<code>sudo sh -c &quot;echo &#39;kernel: BUG: unable to handle kernel NULL pointer dereference at TESTING&#39; &gt;&gt; /dev/kmsg&quot;</code>。然后您应该会看到该KernelOopss事件。</p>
<p>添加新规则或开发节点问题检测器时，在独立模式下在本地工作站上进行测试可能更容易。</p>
<p>对于 API 服务器，一种简单的方法是使用kubectl proxy正在运行的集群的 API 服务器在本地可用。</p>
<p>您会收到一些错误，因为 API 服务器无法识别您的本地工作站。但无论如何，您仍然应该能够测试您的新规则。</p>
<p>例如，测试KernelMonitor规则：</p>
<ul>
<li><code>make</code>（本地构建node-problem-detector）</li>
<li><code>kubectl proxy --port=8080</code>（使正在运行的集群的 API 服务器在本地可用）</li>
<li>将KernelMonitor更新到您的本地内核日志目录<code>logPath</code>。例如，在某些 Linux 系统上，它是<code>/run/log/journal</code>, 而不是<code>/var/log/journal</code>。</li>
<li><code>./bin/node-problem-detector --logtostderr --apiserver-override=http://127.0.0.1:8080?inClusterConfig=false --config.system-log-monitor=config/kernel-monitor.json --config.system-stats-monitor=config/system-stats-monitor.json --port=20256 --prometheus-port=2025</code>（或指向任何 API 服务器地址：端口和 Prometheus 端口）</li>
<li><code>sudo sh -c &quot;echo &#39;kernel: BUG: unable to handle kernel NULL pointer dereference at TESTING&#39; &gt;&gt; /dev/kmsg&quot;</code></li>
<li>您可以<code>KernelOops</code>在节点问题检测器日志中看到事件。</li>
<li><code>sudo sh -c &quot;echo &#39;kernel: INFO: task docker:20744 blocked for more than 120 seconds.&#39; &gt;&gt; /dev/kmsg&quot;</code></li>
<li>您可以在node-problem-detector log看DockerHung event和状态</li>
<li>您可以在<a href="http://127.0.0.1:20256/conditions%E6%9F%A5%E7%9C%8B%60DockerHung%60%E7%8A%B6%E6%80%81">http://127.0.0.1:20256/conditions查看DockerHung状态</a></li>
<li>您可以在<a href="http://127.0.0.1:20257/metrics%E4%B8%8A%E6%9F%A5%E7%9C%8B">http://127.0.0.1:20257/metrics</a>上查看 Prometheus 格式的磁盘相关系统指标。</li>
</ul>
<p>注： 您可以在<a href="https://github.com/kubernetes/node-problem-detector/tree/master/test/kernel_log_generator/problems">test&#x2F;kernel_log_generator&#x2F;problems</a>下查看更多规则示例。</p>
<ul>
<li>对于<a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor.json">KernelMonitor</a><br>消息注入，所有消息都应该有kernel: 前缀（另请注意，后面有一个空格:）；或者使用<a href="https://github.com/kubernetes/node-problem-detector/blob/master/test/kernel_log_generator/generator.sh">generator.sh</a>。</li>
<li>要将其他日志（如 systemd 日志）注入 journald，请使用<code>echo &#39;Some systemd message&#39; | systemd-cat -t systemd</code>。</li>
</ul>
<h2 id="1-12-Remedy-Systems"><a href="#1-12-Remedy-Systems" class="headerlink" title="1.12 Remedy Systems"></a>1.12 Remedy Systems</h2><p>Remedy Systems是一个或多个旨在尝试解决node-problem-detector检测到的问题的过程。</p>
<p>Remedy Systems会观察node-problem-detector发出的事件 和&#x2F;或 节点状况，并采取措施使 Kubernetes 集群恢复健康状态。</p>
<p>补救系统有以下几种：</p>
<ul>
<li><a href="https://github.com/planetlabs/draino">Draino</a> 根据标签和节点条件自动排空 Kubernetes节点。与所有提供的标签和任何提供的节点条件匹配的节点将被阻止立即接受新 pod（也称为“封锁”），并在可配置的时间后<a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/">排空</a>。Draino可以与 <a href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler">Cluster Autoscaler</a>结合使用，以自动终止排空的节点。请参阅 <a href="https://github.com/kubernetes/node-problem-detector/issues/199">此问题</a> ，了解 Draino的示例生产用例。</li>
<li><a href="https://github.com/kubernetes-sigs/descheduler">Descheduler</a> 取消调度策略RemovePodsViolatingNodeTaints会驱逐节点上违反NoSchedule污染的Pod。必须启用k8s调度程序的TaintNodesByCondition功能。</li>
<li><a href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler">Cluster Autoscaler</a> 可用于自动终止耗尽的节点。</li>
<li><a href="https://github.com/medik8s">mediK8S</a> 是一个基于<a href="https://github.com/medik8s/node-healthcheck-operator">Node Health Check Operator (NHC)</a>构建的自动修复系统的总体项目，该系统监控节点状况并使用修复 API将修复委托给外部修复程序。</li>
<li><a href="https://github.com/medik8s/poison-pill">Poison-Pill</a>是一个修复程序，它将重新启动节点并确保所有有状态的工作负载都得到重新安排。如果集群具有足够的健康容量，NHC支持有条件地进行修复，或者手动暂停任何操作以最大限度地减少集群中断。</li>
<li><a href="https://cluster-api.sigs.k8s.io/">Cluster API</a> 的<a href="https://cluster-api.sigs.k8s.io/developer/architecture/controllers/machine-health-check">MachineHealthCheck</a>负责修复不健康的机器。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>BKCI 简介</title>
    <url>/2025/07/devops/blueking/BKCI%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>BK-CI官方文档：<a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/README.md">https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/README.md</a><br>github仓库地址：<a href="https://github.com/TencentBlueKing/bk-ci">https://github.com/TencentBlueKing/bk-ci</a></p>
<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><table>
<thead>
<tr>
<th>🐤 了解基本概念</th>
<th>👉 使用 BKCI</th>
<th>🚀 部署 BKCI</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/bkci.md">BKCI 是什么？</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Create-your-first-pipeline.md">创建你的第一条流水线</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Setup/system-requirements/hardware.md">BKCI 硬件规格指南</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/terminology/components.md">BKCI 组件</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Link-your-first-repo.md">关联你的第一个代码库</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Setup/system-requirements/system.md">BKCI 系统要求</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/terminology/Learn-pipeline-in-5min.md">快速熟悉流水线</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Enable-ci.md">为你的Git工程开启CI</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/terminology/Learn-pipeline-in-5min.md">术语解释</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Case/Examples/vars-usage.md">示例</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/rest-api/read-before-use.md">API接口</a></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>📔 产品功能</th>
<th>🏪 研发商店</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Pipeline/pipeline-list.md">流水线</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/home.md">浏览研发商店</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Console/Console.md">控制台</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/start-new-task.md">开发一个流水线插件</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Ticket/ticket.md">凭证管理</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/upload-new-task.md">在 BKCI 里使用商店插件</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Pools/host-to-bkci.md">构建资源</a></td>
<td></td>
</tr>
</tbody></table>
<h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><p>蓝鲸学习社区：<a href="https://bk.tencent.com/s-mart/communities">https://bk.tencent.com/s-mart/communities</a><br>蓝鲸官方文档：<a href="https://bk.tencent.com/docs/">https://bk.tencent.com/docs/</a></p>
<p><strong>蓝鲸体系</strong><br>蓝鲸简介：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/intro.md</a><br>核心优势：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/advantages.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/advantages.md</a><br>体系架构：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/solution.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/solution.md</a><br>CI领域：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/ci_intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/ci_intro.md</a><br>CD领域：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/cd_intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/cd_intro.md</a><br>CO领域：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/co_intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/co_intro.md</a></p>
]]></content>
  </entry>
  <entry>
    <title>BK-CI插件开发指引</title>
    <url>/2025/07/devops/blueking/BK-CI%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8C%87%E5%BC%95/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>开发插件前，先进入插件工作台初始化一个插件，确定插件在平台中的唯一标识</p>
</blockquote>
<h1 id="工作台"><a href="#工作台" class="headerlink" title="工作台"></a>工作台</h1><p>可以在这里进行新增&#x2F;发布&#x2F;下架等管理插件的操作</p>
<h2 id="功能区介绍"><a href="#功能区介绍" class="headerlink" title="功能区介绍"></a>功能区介绍</h2><p><img src="/img.png" alt="img.png"></p>
<ol>
<li>切换资源类型</li>
<li>新增插件</li>
<li>单个插件的管理入口</li>
<li>升级、下架、删除插件快捷入口</li>
<li>指引文档和插件 UI 调试工具入口</li>
</ol>
<h2 id="新增插件"><a href="#新增插件" class="headerlink" title="新增插件"></a>新增插件</h2><p><img src="/img_1.png" alt="img_1.png"></p>
<ol>
<li>标识</li>
</ol>
<ul>
<li>插件在平台中的唯一标识，建议取和插件功能相关的可读性好的英文标识</li>
</ul>
<ol start="2">
<li>调试项目</li>
</ol>
<ul>
<li>插件发布过程中，可以在调试项目下将插件添加到流水线执行，对插件进行测试，保证插件功能满足预期。</li>
<li>建议新增专用的插件调试项目，避免测试过程中影响到业务。</li>
</ul>
<ol start="3">
<li>开发语言</li>
</ol>
<ul>
<li>支持四种语言开发插件：<ul>
<li>Java（推荐）</li>
<li>Python</li>
<li>Golang</li>
<li>Nodejs</li>
</ul>
</li>
</ul>
<h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h2><blockquote>
<p>初始化好插件之后，可以开始开发插件</p>
</blockquote>
<ul>
<li>根据开发语言参考对应的开发指引<ul>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/java.md">Java 插件开发指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/python.md">Python 插件开发指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/golang.md">Golang 插件开发指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/nodejs.md">Nodejs 插件开发指引</a></li>
</ul>
</li>
</ul>
<h2 id="插件私有配置"><a href="#插件私有配置" class="headerlink" title="插件私有配置"></a>插件私有配置</h2><blockquote>
<p>插件级别的敏感信息，如 token、用户名密码、IP、域名等，不建议直接提交到代码库，通过工作台私有配置界面管理</p>
</blockquote>
<p><img src="/img_2.png" alt="img_2.png"></p>
<h1 id="Golang-插件开发"><a href="#Golang-插件开发" class="headerlink" title="Golang 插件开发"></a>Golang 插件开发</h1><h2 id="插件开发框架说明"><a href="#插件开发框架说明" class="headerlink" title="插件开发框架说明"></a>插件开发框架说明</h2><blockquote>
<p>插件最终打包成一个命令行可执行的命令即可，对开发框架无硬性要求 下边以 demo 插件为例示范</p>
</blockquote>
<h2 id="示例插件代码工程的整体结构如下"><a href="#示例插件代码工程的整体结构如下" class="headerlink" title="示例插件代码工程的整体结构如下"></a>示例插件代码工程的整体结构如下</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|- &lt;你的插件标识&gt;</span><br><span class="line">    |- cmd</span><br><span class="line">        |- application</span><br><span class="line">            |- main.go</span><br><span class="line"></span><br><span class="line">    |- hello</span><br><span class="line">        |- hello.go</span><br></pre></td></tr></table></figure>

<h2 id="如何开发插件："><a href="#如何开发插件：" class="headerlink" title="如何开发插件："></a>如何开发插件：</h2><blockquote>
<p>参考 <a href="https://github.com/ci-plugins/plugin-demo-golang">plugin-demo-golang</a></p>
</blockquote>
<ul>
<li>建插件代码工程<ul>
<li>插件代码建议企业下统一管理。 通用的开源插件可以联系蓝鲸官方放到 <a href="https://github.com/TencentBlueKing">TencentBlueKing</a> 下，供更多用户使用</li>
</ul>
</li>
<li>实现插件功能</li>
<li>规范：<ul>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-specification.md">插件开发规范</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-config.md">插件配置规范</a></li>
</ul>
</li>
<li>插件前端不仅可以通过 task.json 进行标准化配置，也可以自定义开发：<ul>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-custom-ui.md">自定义插件 UI 交互指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-output.md">插件输出规范</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-error-code.md">插件错误码规范</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/release.md">插件发布包规范</a></li>
</ul>
</li>
</ul>
<h2 id="Demo示例研读"><a href="#Demo示例研读" class="headerlink" title="Demo示例研读"></a>Demo示例研读</h2><p>将 <a href="https://github.com/ci-plugins/plugin-demo-golang">plugin-demo-golang</a> clone到本地。<br>来看下项目结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── i18n</span><br><span class="line">│   ├── message_en_US.properties</span><br><span class="line">│   └── message_zh_CN.properties</span><br><span class="line">├── main.go</span><br><span class="line">├── task.json</span><br><span class="line">└── translation</span><br><span class="line">    └── translation.go</span><br><span class="line"></span><br><span class="line">3 directories, 11 files</span><br></pre></td></tr></table></figure>

<p>咦！和上面说的插件代码工程的整体架构不一样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|- &lt;你的插件标识&gt;</span><br><span class="line">    |- cmd</span><br><span class="line">        |- application</span><br><span class="line">            |- main.go</span><br><span class="line"></span><br><span class="line">    |- hello</span><br><span class="line">        |- hello.go</span><br></pre></td></tr></table></figure>

<p>不过，这不重要，只要插件最终能够打包成一个命令行可执行的命令即可。<br>这里i18n是实现中英文国际化使用的，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── i18n</span><br><span class="line">│   ├── message_en_US.properties</span><br><span class="line">│   └── message_zh_CN.properties</span><br></pre></td></tr></table></figure>

<p>看下内容对比：<br>message_en_US.properties：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input.desc.label=desc</span><br><span class="line">100001=input param [&#123;0&#125;] invitated</span><br></pre></td></tr></table></figure>

<p>message_zh_CN.properties</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input.desc.label=描述</span><br><span class="line">100001=输入参数[&#123;0&#125;]非法</span><br></pre></td></tr></table></figure>

<p>那我们就可以猜测，这里是实现输入参数[{0}]非法这句话的中英文，其中[{0}]会使用具体的参数填充。<br>然后i18ngenerator则是根据properties文件的配置，生成translation代码，如translation.go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code generated by &quot;i18ngenerator&quot;; DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> translation</span><br><span class="line"></span><br><span class="line"><span class="comment">// Translations</span></span><br><span class="line"><span class="keyword">var</span> Translations <span class="keyword">map</span>[<span class="type">string</span>][][]<span class="type">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][][]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Translations[<span class="string">&quot;en-US&quot;</span>] = [][]<span class="type">string</span>&#123;</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;100001&quot;</span>,</span><br><span class="line">          <span class="string">&quot;input param [&#123;0&#125;] invitated&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;input.desc.label&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    Translations[<span class="string">&quot;zh-CN&quot;</span>] = [][]<span class="type">string</span>&#123;</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;100001&quot;</span>,</span><br><span class="line">          <span class="string">&quot;输入参数[&#123;0&#125;]非法&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;input.desc.label&quot;</span>,</span><br><span class="line">          <span class="string">&quot;描述&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该文件是由i18ngenerator自动生成的，不要自己改。<br>main函数内，实现了一个小的输出功能，简单看下源码，然后去进行测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/ci-plugins/golang-plugin-sdk/api&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ci-plugins/golang-plugin-sdk/log&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ci-plugins/plugin-demo-golang/translation&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate i18ngenerator i18n ./translation/translation.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> greetingParam <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserName <span class="type">string</span> <span class="string">`json:&quot;userName&quot;`</span></span><br><span class="line">    Greeting <span class="type">string</span> <span class="string">`json:&quot;greeting&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *greetingParam)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;userName: %v, greeting: %v&quot;</span>, a.UserName, a.Greeting)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">4</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;atom-demo-glang starts&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Error(<span class="string">&quot;panic: &quot;</span>, err)</span><br><span class="line">          api.FinishBuild(api.StatusError, <span class="string">&quot;panic occurs&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    api.InitI18n(translation.Translations, api.GetRuntimeLanguage())</span><br><span class="line">    msg, err := api.Localize(<span class="string">&quot;input.desc.label&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.Error(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Info(msg)</span><br><span class="line"></span><br><span class="line">    helloBuild()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloBuild</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取单个输入参数</span></span><br><span class="line">    userName := api.GetInputParam(<span class="string">&quot;userName&quot;</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;userName: &quot;</span>, userName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打屏</span></span><br><span class="line">    log.Info(<span class="string">&quot;\nBuildInfo:&quot;</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;Project Name:     &quot;</span>, api.GetProjectDisplayName())</span><br><span class="line">    log.Info(<span class="string">&quot;Pipeline Id:      &quot;</span>, api.GetPipelineId())</span><br><span class="line">    log.Info(<span class="string">&quot;Pipeline Name:    &quot;</span>, api.GetPipelineName())</span><br><span class="line">    log.Info(<span class="string">&quot;Pipeline Version: &quot;</span>, api.GetPipelineVersion())</span><br><span class="line">    log.Info(<span class="string">&quot;Build Id:         &quot;</span>, api.GetPipelineBuildId())</span><br><span class="line">    log.Info(<span class="string">&quot;Build Num:        &quot;</span>, api.GetPipelineBuildNumber())</span><br><span class="line">    log.Info(<span class="string">&quot;Start Type:       &quot;</span>, api.GetPipelineStartType())</span><br><span class="line">    log.Info(<span class="string">&quot;Start UserId:     &quot;</span>, api.GetPipelineStartUserId())</span><br><span class="line">    log.Info(<span class="string">&quot;Start UserName:   &quot;</span>, api.GetPipelineStartUserName())</span><br><span class="line">    log.Info(<span class="string">&quot;Start Time:       &quot;</span>, api.GetPipelineStartTimeMills())</span><br><span class="line">    log.Info(<span class="string">&quot;Workspace:        &quot;</span>, api.GetWorkspace())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入参数解析到对象</span></span><br><span class="line">    paramData := <span class="built_in">new</span>(greetingParam)</span><br><span class="line">    api.LoadInputParam(paramData)</span><br><span class="line">    log.Info(fmt.Sprintf(<span class="string">&quot;\n%v，%v\n&quot;</span>, paramData.Greeting, paramData.UserName))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    log.Info(<span class="string">&quot;start build&quot;</span>)</span><br><span class="line">    build()</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 字符串输出</span></span><br><span class="line">    strData := api.NewStringData(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    api.AddOutputData(<span class="string">&quot;strData_01&quot;</span>, strData)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件归档输出</span></span><br><span class="line">    artifactData := api.NewArtifactData()</span><br><span class="line">    artifactData.AddArtifact(<span class="string">&quot;result.dat&quot;</span>)</span><br><span class="line">    api.AddOutputData(<span class="string">&quot;artifactData_02&quot;</span>, artifactData)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报告输出</span></span><br><span class="line">    reportData := api.NewReportData(<span class="string">&quot;label_01&quot;</span>, api.GetWorkspace()+<span class="string">&quot;/report&quot;</span>, <span class="string">&quot;report.htm&quot;</span>)</span><br><span class="line">    api.AddOutputData(<span class="string">&quot;report_01&quot;</span>, reportData)</span><br><span class="line"></span><br><span class="line">    api.WriteOutput()</span><br><span class="line">    log.Info(<span class="string">&quot;build done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Info(<span class="string">&quot;write result.dat&quot;</span>)</span><br><span class="line">    ioutil.WriteFile(api.GetWorkspace()+<span class="string">&quot;/result.dat&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;content&quot;</span>), <span class="number">0644</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;write report.htm&quot;</span>)</span><br><span class="line">    os.Mkdir(api.GetWorkspace()+<span class="string">&quot;/report&quot;</span>, os.ModePerm)</span><br><span class="line">    ioutil.WriteFile(api.GetWorkspace()+<span class="string">&quot;/report/report.htm&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Report&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;This is a Report&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>), <span class="number">0644</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在根目录下已经给我们预设了一个task.json文件，后面可以简单修改下这个文件来实现测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;atomCode&quot;</span>: <span class="string">&quot;goDemo&quot;</span>,</span><br><span class="line">  <span class="string">&quot;execution&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;language&quot;</span>: <span class="string">&quot;golang&quot;</span>,</span><br><span class="line">    <span class="string">&quot;packagePath&quot;</span>: <span class="string">&quot;goDemo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;demands&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;chmod +x goDemo&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;./goDemo&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;input&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;greeting&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;label&quot;</span>: <span class="string">&quot;欢迎词&quot;</span>,</span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;Glad to see you&quot;</span>,</span><br><span class="line">      <span class="string">&quot;placeholder&quot;</span>: <span class="string">&quot;欢迎词&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;vuex-input&quot;</span>,</span><br><span class="line">      <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;欢迎词&quot;</span>,</span><br><span class="line">      <span class="string">&quot;required&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;disabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;isSensitive&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;userName&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;label&quot;</span>: <span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;Mr. Huang&quot;</span>,</span><br><span class="line">      <span class="string">&quot;placeholder&quot;</span>: <span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;vuex-input&quot;</span>,</span><br><span class="line">      <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">      <span class="string">&quot;required&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;disabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;isSensitive&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;output&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;strData_01&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;测试&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="string">&quot;isSensitive&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何打包发布"><a href="#如何打包发布" class="headerlink" title="如何打包发布"></a>如何打包发布</h2><ol>
<li>进入插件代码工程目录下</li>
<li>打包</li>
</ol>
<ul>
<li>如果按照正常的demo的目录结构是需要进入cmd&#x2F;application内执行build命令，因为main在此</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd cmd/application</span><br><span class="line">GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/$&#123;executable&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这次用的demo则直接在根目录下执行build命令，因为main在根目录下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/$&#123;executable&#125;</span><br></pre></td></tr></table></figure>

<p>这里go build -o bin&#x2F;${executable}会在bin目录下，生成可执行文件，文件名是${executable}，即项目名。<br>也可以自定义一个名字，如<code>GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/kingtest</code></p>
<ol>
<li>在任意位置新建文件夹，命名示例：release_pkg &#x3D; &lt;你的插件标识&gt;_release</li>
<li>将步骤 2 生产的执行包拷贝到 下</li>
<li>添加 task.json 文件到 下 task.json 见示例，按照插件功能配置。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir kingtest_release</span><br><span class="line">cp bin/kingtest kingtest_release/kingtest</span><br><span class="line">touch kingtest_release/task.json</span><br></pre></td></tr></table></figure>

<ul>
<li>插件配置规范</li>
<li>task.json 示例：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;atomCode&quot;: &quot;king-test&quot;,                  # atomCode 要与工作台录入的一致</span><br><span class="line">  &quot;execution&quot;: &#123;</span><br><span class="line">    &quot;language&quot;: &quot;golang&quot;,</span><br><span class="line">    &quot;packagePath&quot;: &quot;kingtest&quot;,              # 发布包中插件安装包的相对路径</span><br><span class="line">    &quot;demands&quot;: [</span><br><span class="line">      &quot;echo start run chmod +x kingtest&quot;,   # 插件启动前需要执行的安装命令，顺序执行</span><br><span class="line">      &quot;chmod +x kingtest&quot;,                  # 插件启动前需要执行的安装命令，顺序执行</span><br><span class="line">      &quot;echo stop run chmod +x kingtest&quot;,    # 插件启动前需要执行的安装命令，顺序执行</span><br><span class="line">    ],</span><br><span class="line">    &quot;target&quot;: &quot;./kingtest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;input&quot;: &#123;</span><br><span class="line">    &quot;greeting&quot;: &#123;</span><br><span class="line">      &quot;label&quot;: &quot;欢迎词&quot;,</span><br><span class="line">      &quot;default&quot;: &quot;Glad to see you&quot;,</span><br><span class="line">      &quot;placeholder&quot;: &quot;欢迎词&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;vuex-input&quot;,</span><br><span class="line">      &quot;desc&quot;: &quot;欢迎词&quot;,</span><br><span class="line">      &quot;required&quot;: true,</span><br><span class="line">      &quot;disabled&quot;: false,</span><br><span class="line">      &quot;hidden&quot;: false,</span><br><span class="line">      &quot;isSensitive&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;userName&quot;: &#123;</span><br><span class="line">      &quot;label&quot;: &quot;姓名&quot;,</span><br><span class="line">      &quot;default&quot;: &quot;Mr. Huang&quot;,</span><br><span class="line">      &quot;placeholder&quot;: &quot;姓名&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;vuex-input&quot;,</span><br><span class="line">      &quot;desc&quot;: &quot;姓名&quot;,</span><br><span class="line">      &quot;required&quot;: true,</span><br><span class="line">      &quot;disabled&quot;: false,</span><br><span class="line">      &quot;hidden&quot;: false,</span><br><span class="line">      &quot;isSensitive&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;output&quot;: &#123;</span><br><span class="line">    &quot;strData_01&quot;: &#123;</span><br><span class="line">      &quot;description&quot;: &quot;测试&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">      &quot;isSensitive&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 目录下，把所有文件打成 zip 包即可</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd kingtest_release &amp;&amp; zip kingtest_release.zip kingtest task.json</span><br></pre></td></tr></table></figure>

<p>zip包结构示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|- kingtest_release.zip         # 发布包</span><br><span class="line">   |- kingtest                  # 插件执行包</span><br><span class="line">   |- task.json                 # 插件配置文件</span><br></pre></td></tr></table></figure>

<p>打包完成后，在插件工作台提单发布，即可测试或发布插件</p>
<h1 id="上传一个流水线插件"><a href="#上传一个流水线插件" class="headerlink" title="上传一个流水线插件"></a>上传一个流水线插件</h1><blockquote>
<p>开发好插件之后，通过研发商店工作台，将插件发布到研发商店，提供给用户添加到流水线中使用。</p>
</blockquote>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>在工作台列表，点击如下入口发起发布流程：<br><img src="/img_3.png" alt="img_3.png"></p>
<p>首次发布时，入口名为上架<br>后续更新版本时，入口名为升级<br>或者在插件发布管理-&gt;版本管理界面发起发布流程：<br><img src="/img_4.png" alt="img_4.png"></p>
<h2 id="填写插件相关信息-上传插件发布包"><a href="#填写插件相关信息-上传插件发布包" class="headerlink" title="填写插件相关信息&#x2F;上传插件发布包"></a>填写插件相关信息&#x2F;上传插件发布包</h2><p>上架&#x2F;升级插件时，可以修改插件的基本信息，如下所示：<br><img src="/img_5.png" alt="img_5.png"></p>
<ol>
<li>适用 Job 类型：</li>
</ol>
<ul>
<li>和流水线 Job 类型对应，请按照插件实际适用情况选择</li>
<li>若选错，需新增版本修改</li>
</ul>
<ol start="2">
<li>发布包：</li>
</ol>
<ul>
<li>task.json 中的 atomCode 需和 新增插件时填写的标识一致，否则上传会失败</li>
</ul>
<h2 id="测试-发布插件"><a href="#测试-发布插件" class="headerlink" title="测试&#x2F;发布插件"></a>测试&#x2F;发布插件</h2><blockquote>
<p>填写好信息，提交后，进入发布流程，可以测试-&gt;重新传包-&gt;测试，直至插件满足预期后，手动继续流程将插件发布到研发商店</p>
</blockquote>
<p><img src="/img_6.png" alt="img_6.png"></p>
<ol>
<li>测试：点击后跳转到插件调试项目的流水线服务下，可以将当前插件添加到流水线，验证 UI、功能是否满足预期</li>
<li>重新传包：当测试发现问题，修复后，重新上传发布包，再次进行测试</li>
<li>继续：测试 OK，满足预期后，确认提交发布</li>
<li>取消发布：发布过程中，随时可以终止发布</li>
</ol>
<h2 id="遇见的几个错误"><a href="#遇见的几个错误" class="headerlink" title="遇见的几个错误"></a>遇见的几个错误</h2><h3 id="无权限执行"><a href="#无权限执行" class="headerlink" title="无权限执行"></a>无权限执行</h3><p>在测试中遇见一个问题：无权限执行<br><img src="/img_7.png" alt="img_7.png"></p>
<p>在<code>execution-&gt;demands</code>增加一个命令<code>chmod +x kingtest</code>即可解决</p>
<h3 id="发布进度里重新传包持续报错task-json格式错误"><a href="#发布进度里重新传包持续报错task-json格式错误" class="headerlink" title="发布进度里重新传包持续报错task.json格式错误"></a>发布进度里重新传包持续报错task.json格式错误</h3><p>还有个问题，在发布进度里重新传包时，一直报错task.json格式错误，但实际格式是对的！<br>触发的原因暂不知道，但是确实是一个隐藏的bug。<br><img src="/img_8.png" alt="img_8.png"></p>
<p>直接点击继续，然后走升级插件的方式可以正常使用。</p>
<h3 id="cannot-execute-binary-file-Exec-format-error"><a href="#cannot-execute-binary-file-Exec-format-error" class="headerlink" title="cannot execute binary file: Exec format error"></a>cannot execute binary file: Exec format error</h3><p>这里的问题是我造成的，最初我在mac环境下编译的可执行文件，命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mac下执行</span></span><br><span class="line">go build -o bin/kingtest</span><br></pre></td></tr></table></figure>

<p>但是插件里选择的编译环境是linux。<br><img src="/img_9.png" alt="img_9.png"></p>
<p>解决方式：让插件选择的编译环境和可执行文件的平台统一。<br>我这里选择重新编译下可执行文件，采用在mac平台交叉编译linux平台可执行文件的方式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/kingtest</span><br></pre></td></tr></table></figure>

<p>也可以新建一个插件，编译环境选择mac。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>流水线结果：<br><img src="/img_10.png" alt="img_10.png"></p>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Plugin info]</span><br><span class="line">=====================================================================</span><br><span class="line">Task           : king-test</span><br><span class="line">Description    : bk插件测试</span><br><span class="line">Version        : 1.0.3</span><br><span class="line">Author         : huari</span><br><span class="line">Help           : More Information</span><br><span class="line">=====================================================================</span><br><span class="line">-----</span><br><span class="line">[Input]</span><br><span class="line">input(normal): (欢迎词)greeting=Glad to see you</span><br><span class="line">input(normal): (姓名)userName=Mr. Huang</span><br><span class="line">-----</span><br><span class="line">[Install plugin]</span><br><span class="line">-----</span><br><span class="line">start run chmod +x kingtest</span><br><span class="line">stop run chmod +x kingtest</span><br><span class="line">atom-demo-glang starts</span><br><span class="line">描述</span><br><span class="line">userName:  Mr. Huang</span><br><span class="line"></span><br><span class="line">BuildInfo:</span><br><span class="line">Project Name:      GOPS</span><br><span class="line">Pipeline Id:       p-8967ed52b08847c8a5b0140937db0975</span><br><span class="line">Pipeline Name:     king-test</span><br><span class="line">Pipeline Version:  11</span><br><span class="line">Build Id:          b-78947b5c39f34b32bbafb803042d1e22</span><br><span class="line">Build Num:         15</span><br><span class="line">Start Type:        MANUAL</span><br><span class="line">Start UserId:      huari</span><br><span class="line">Start UserName:    huari</span><br><span class="line">Start Time:        1733298107286</span><br><span class="line">Workspace:         /data/devops/workspace</span><br><span class="line"></span><br><span class="line">Glad to see you，Mr. Huang</span><br><span class="line">start build</span><br><span class="line">write result.dat</span><br><span class="line">write report.htm</span><br><span class="line">build done</span><br><span class="line">[Output]</span><br><span class="line">1 file match: </span><br><span class="line">  /data/devops/workspace/result.dat</span><br><span class="line">prepare to upload 7 B</span><br><span class="line">1/1 file(s) finished</span><br><span class="line">output(except): artifactData_02=result.dat</span><br><span class="line">入口文件检测完成</span><br><span class="line">上传自定义产出物成功，共产生了1个文件</span><br><span class="line">output(except): report_01=report.htm</span><br><span class="line">output(normal): strData_01=test</span><br><span class="line">-----</span><br><span class="line"></span><br></pre></td></tr></table></figure>






]]></content>
  </entry>
</search>
