<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2025/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Ldap通过helm部署</title>
    <url>/2025/07/devops/ldap/Ldap%E9%80%9A%E8%BF%87helm%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>⚡️: OpenLDAP是轻量级目录访问协议（LDAP）的开源实现，它提供了一种存储和访问关于用户、组、计算机和其他资源的信息的中心化目录服务。</p>
</blockquote>
<h1 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h1><ul>
<li>cn（common name）：通用名称，表示一个对象的名称。在用户条目中，通常与用户的姓名相对应；在组条目中，则与组名相对应。</li>
<li>ou（organizational unit）：组织单位，表示一个组织或部门。在LDAP目录服务中，可以使用ou来创建多级组织结构，并将用户和其他对象分配到相应的组织单元中，以便更好地管理它们。</li>
<li>dc（domain component）：域组件，表示域名的一部分。在LDAP中，域名通常是按照层次结构组织的，例如：example.com可以被拆分为dc&#x3D;example,dc&#x3D;com。这样做有利于有效地组织和管理大规模的目录服务。</li>
<li>sn（surname）：姓氏，表示一个人的姓氏。与cn属性不同，sn只表示姓氏，而且通常不唯一。</li>
</ul>
<h1 id="kubernetes集群部署"><a href="#kubernetes集群部署" class="headerlink" title="kubernetes集群部署"></a>kubernetes集群部署</h1><p>参考快速搭建kind测试集群快速搭建一本地测使用的kind集群。</p>
]]></content>
  </entry>
  <entry>
    <title>BKCI 简介</title>
    <url>/2025/07/devops/blueking/BKCI%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>BK-CI官方文档：<a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/README.md">https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/README.md</a><br>github仓库地址：<a href="https://github.com/TencentBlueKing/bk-ci">https://github.com/TencentBlueKing/bk-ci</a></p>
<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><table>
<thead>
<tr>
<th>🐤 了解基本概念</th>
<th>👉 使用 BKCI</th>
<th>🚀 部署 BKCI</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/bkci.md">BKCI 是什么？</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Create-your-first-pipeline.md">创建你的第一条流水线</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Setup/system-requirements/hardware.md">BKCI 硬件规格指南</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/terminology/components.md">BKCI 组件</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Link-your-first-repo.md">关联你的第一个代码库</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Setup/system-requirements/system.md">BKCI 系统要求</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/terminology/Learn-pipeline-in-5min.md">快速熟悉流水线</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Enable-ci.md">为你的Git工程开启CI</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/terminology/Learn-pipeline-in-5min.md">术语解释</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Case/Examples/vars-usage.md">示例</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/rest-api/read-before-use.md">API接口</a></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>📔 产品功能</th>
<th>🏪 研发商店</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Pipeline/pipeline-list.md">流水线</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/home.md">浏览研发商店</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Console/Console.md">控制台</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/start-new-task.md">开发一个流水线插件</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Ticket/ticket.md">凭证管理</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/upload-new-task.md">在 BKCI 里使用商店插件</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Pools/host-to-bkci.md">构建资源</a></td>
<td></td>
</tr>
</tbody></table>
<h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><p>蓝鲸学习社区：<a href="https://bk.tencent.com/s-mart/communities">https://bk.tencent.com/s-mart/communities</a><br>蓝鲸官方文档：<a href="https://bk.tencent.com/docs/">https://bk.tencent.com/docs/</a></p>
<p><strong>蓝鲸体系</strong><br>蓝鲸简介：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/intro.md</a><br>核心优势：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/advantages.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/advantages.md</a><br>体系架构：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/solution.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/solution.md</a><br>CI领域：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/ci_intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/ci_intro.md</a><br>CD领域：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/cd_intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/cd_intro.md</a><br>CO领域：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/co_intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/co_intro.md</a></p>
]]></content>
  </entry>
  <entry>
    <title>alicloud_alikafka_instance</title>
    <url>/2025/07/devops/terraform/alicloud_alikafka_instance/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>约定格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── aliyun                                             # 云厂商实例文件</span><br><span class="line">│   └── aliyun_ecs_mod_demo                           # 模型名</span><br><span class="line">│       └── aliyun_china_platform_7111                # 云账号名</span><br><span class="line">│           └── ecs_instance_name_20241224121212      # 实例名</span><br><span class="line">│               ├── backend.tf                        # 实例state文件保存说明：oss</span><br><span class="line">│               └── main.tf                           # 实例具体的参数</span><br><span class="line">├── modules                                            # 模型数据文件夹</span><br><span class="line">│   ├── aliyun                                        # 云厂商模型文件夹</span><br><span class="line">│   │   └── aliyun_ecs_mod_demo                       # 模型名</span><br><span class="line">│   │       ├── main.tf                               # 模型定义主文件</span><br><span class="line">│   │       ├── outputs.tf                            # 模型定义输出文件</span><br><span class="line">│   │       └── variables.tf                          # 模型定义参数文件</span><br><span class="line">│   └── tenmod                                         # 另一个云厂商模型</span><br><span class="line">└── tenent                                              # 另一个云厂商实例文件</span><br></pre></td></tr></table></figure>

<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── aliyun</span><br><span class="line">│   └── aliyun_alikafka_demo</span><br><span class="line">│       └── aliyun_china_pt_7111</span><br><span class="line">│           └── alikafka_demo_202502061910</span><br><span class="line">│               ├── backend.tf</span><br><span class="line">│               └── main.tf</span><br><span class="line">└── modules</span><br><span class="line">    └── aliyun</span><br><span class="line">        └── aliyun_alikafka_mod_demo</span><br><span class="line">            ├── main.tf</span><br><span class="line">            └── variables.tf</span><br></pre></td></tr></table></figure>

<h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><h3 id="modules-aliyun-aliyun-alikafka-mod-demo-main-tf"><a href="#modules-aliyun-aliyun-alikafka-mod-demo-main-tf" class="headerlink" title="&#x2F;modules&#x2F;aliyun&#x2F;aliyun_alikafka_mod_demo&#x2F;main.tf"></a>&#x2F;modules&#x2F;aliyun&#x2F;aliyun_alikafka_mod_demo&#x2F;main.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    alicloud = &#123;</span><br><span class="line">      source  = &quot;aliyun/alicloud&quot;</span><br><span class="line">      version = &quot;1.225.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">provider &quot;alicloud&quot; &#123;</span><br><span class="line">  region = var.region</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;alicloud_alikafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">  name          = var.instance_name</span><br><span class="line">  deploy_type   = var.deploy_type</span><br><span class="line">  disk_size     = var.disk_size</span><br><span class="line">  disk_type     = var.disk_type</span><br><span class="line">  vswitch_id    = var.vswitch_id</span><br><span class="line">  partition_num = var.partition_num</span><br><span class="line">  io_max        = var.io_max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="modules-aliyun-aliyun-alikafka-mod-demo-variables-tf"><a href="#modules-aliyun-aliyun-alikafka-mod-demo-variables-tf" class="headerlink" title="&#x2F;modules&#x2F;aliyun&#x2F;aliyun_alikafka_mod_demo&#x2F;variables.tf"></a>&#x2F;modules&#x2F;aliyun&#x2F;aliyun_alikafka_mod_demo&#x2F;variables.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">variable &quot;region&quot; &#123;</span><br><span class="line">  description = &quot;地域&quot;</span><br><span class="line">  type        = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;instance_name&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例名&quot;</span><br><span class="line">  type        = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;deploy_type&quot; &#123;</span><br><span class="line">  // - 4: eip/vpc instance；- 5: vpc instance.</span><br><span class="line">  description = &quot;部署类型&quot;</span><br><span class="line">  type        = number</span><br><span class="line">  default = 5</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([4, 5], var.deploy_type)</span><br><span class="line">    error_message = &quot;The deploy_type must be one of 4, 5&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;disk_size&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例磁盘规格&quot;</span><br><span class="line">  type = number</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([500, 1000], var.disk_size)</span><br><span class="line">    error_message = &quot;The disk_size must be one of 200, 400&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;disk_type&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">0: efficient cloud disk , 1: SSD.</span></span><br><span class="line">  description = &quot;磁盘类型&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 1</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([0, 1], var.disk_type)</span><br><span class="line">    error_message = &quot;The disk_type must be empty, or one of 0, 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;vswitch_id&quot; &#123;</span><br><span class="line">  description = &quot;绑定虚拟交换机id&quot;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;partition_num&quot; &#123;</span><br><span class="line">  description = &quot;分区数量&quot;</span><br><span class="line">  type = number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">variable &quot;io_max&quot; &#123;</span><br><span class="line">  description = &quot;io的最大值&quot;</span><br><span class="line">  type = number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="aliyun-aliyun-alikafka-demo-aliyun-china-pt-7111-alikafka-demo-202502061910-backend-tf"><a href="#aliyun-aliyun-alikafka-demo-aliyun-china-pt-7111-alikafka-demo-202502061910-backend-tf" class="headerlink" title="&#x2F;aliyun&#x2F;aliyun_alikafka_demo&#x2F;aliyun_china_pt_7111&#x2F;alikafka_demo_202502061910&#x2F;backend.tf"></a>&#x2F;aliyun&#x2F;aliyun_alikafka_demo&#x2F;aliyun_china_pt_7111&#x2F;alikafka_demo_202502061910&#x2F;backend.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  backend &quot;oss&quot; &#123;</span><br><span class="line">    endpoint = &quot;oss-cn-hangzhou.aliyuncs.com&quot;</span><br><span class="line">    bucket   = &quot;dz-devops&quot; # 替换为你的 OSS Bucket 名称</span><br><span class="line">    prefix = &quot;terraform_state//aliyun/aliyun_alikafka_demo/aliyun_china_pt_7111/alikafka_demo_202502061910&quot;</span><br><span class="line">    key      = &quot;terraform.tfstate&quot; # 存储状态文件的路径和名称</span><br><span class="line">    region   = &quot;cn-hangzhou&quot;       # OSS 的地域（根据你的实际情况调整）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="aliyun-aliyun-alikafka-demo-aliyun-china-pt-7111-alikafka-demo-202502061910-main-tf"><a href="#aliyun-aliyun-alikafka-demo-aliyun-china-pt-7111-alikafka-demo-202502061910-main-tf" class="headerlink" title="&#x2F;aliyun&#x2F;aliyun_alikafka_demo&#x2F;aliyun_china_pt_7111&#x2F;alikafka_demo_202502061910&#x2F;main.tf"></a>&#x2F;aliyun&#x2F;aliyun_alikafka_demo&#x2F;aliyun_china_pt_7111&#x2F;alikafka_demo_202502061910&#x2F;main.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">module &quot;alikafka_instance&quot; &#123;</span><br><span class="line">  source        = &quot;../../../../modules/aliyun/aliyun_alikafka_mod_demo&quot;</span><br><span class="line">  region        = &quot;cn-hangzhou&quot;</span><br><span class="line">  disk_size     = 500</span><br><span class="line">  instance_name = &quot;alikafka-testV2&quot;</span><br><span class="line">  deploy_type   = 5</span><br><span class="line">  vswitch_id    = &quot;vsw-bp1co65f3q2s0bis9yfkg&quot;</span><br><span class="line">  partition_num = 50</span><br><span class="line">  io_max        = 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><h3 id="获取-AK-SK"><a href="#获取-AK-SK" class="headerlink" title="获取 AK&#x2F;SK"></a>获取 AK&#x2F;SK</h3><p>在首次使用 Terraform 之前，需要前往腾讯云的<a href="https://console.cloud.tencent.com/cam/capi">云 API 密钥页面</a>申请安全凭证SecretId和SecretKey2。若已有可使用的安全凭证，则跳过该步骤2。具体步骤如下2：</p>
<ol>
<li>登录腾讯云<a href="https://console.cloud.tencent.com/cam">访问管理控制台</a>，在左侧导航栏，选择访问密钥&gt;API 密钥管理。</li>
<li>在API 密钥管理页面，单击新建密钥，即可以创建一对SecretId&#x2F;SecretKey。</li>
</ol>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>将获取到的SecretId和SecretKey设置为环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export TENCENTCLOUD_SECRET_ID=your_secret_id</span><br><span class="line">export TENCENTCLOUD_SECRET_KEY=your_secret_key</span><br></pre></td></tr></table></figure>

<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>进入项目根目录，alikafka_demo_202502061910目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./aliyun/aliyun_alikafka_demo/aliyun_china_pt_7111/alikafka_demo_202502061910</span><br></pre></td></tr></table></figure>

<p>初始化 Terraform 项目:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xxx替换为实际backend的ak，将yyy替换为实际backend的sk</span></span><br><span class="line">terraform init -backend-config=&quot;access_key=xxx&quot; -backend-config=&quot;secret_key=yyy&quot;</span><br></pre></td></tr></table></figure>

<p>该命令会下载所需的插件和依赖，并初始化后端配置。<br>类似的输出（首次使用某一个provier时，会先下载）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Initializing the backend...</span><br><span class="line"></span><br><span class="line">Successfully configured the backend &quot;oss&quot;! Terraform will automatically</span><br><span class="line">use this backend unless the backend configuration changes.</span><br><span class="line">Initializing modules...</span><br><span class="line">Initializing provider plugins...</span><br><span class="line">- Reusing previous version of aliyun/alicloud from the dependency lock file</span><br><span class="line">- Using previously-installed aliyun/alicloud v1.225.0</span><br><span class="line"></span><br><span class="line">Terraform has been successfully initialized!</span><br><span class="line"></span><br><span class="line">You may now begin working with Terraform. Try running &quot;terraform plan&quot; to see</span><br><span class="line">any changes that are required for your infrastructure. All Terraform commands</span><br><span class="line">should now work.</span><br><span class="line"></span><br><span class="line">If you ever set or change modules or backend configuration for Terraform,</span><br><span class="line">rerun this command to reinitialize your working directory. If you forget, other</span><br><span class="line">commands will detect it and remind you to do so if necessary.</span><br></pre></td></tr></table></figure>

<p>预览计划变更：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform plan</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.alikafka_instance.alicloud_alikafka_instance.this will be created</span></span><br><span class="line">  + resource &quot;alicloud_alikafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      + config            = (known after apply)</span><br><span class="line">      + deploy_type       = 5</span><br><span class="line">      + disk_size         = 500</span><br><span class="line">      + disk_type         = 1</span><br><span class="line">      + eip_max           = (known after apply)</span><br><span class="line">      + end_point         = (known after apply)</span><br><span class="line">      + group_left        = (known after apply)</span><br><span class="line">      + group_used        = (known after apply)</span><br><span class="line">      + id                = (known after apply)</span><br><span class="line">      + io_max            = 20</span><br><span class="line">      + io_max_spec       = (known after apply)</span><br><span class="line">      + is_partition_buy  = (known after apply)</span><br><span class="line">      + name              = &quot;alikafka-testV2&quot;</span><br><span class="line">      + paid_type         = &quot;PostPaid&quot;</span><br><span class="line">      + partition_left    = (known after apply)</span><br><span class="line">      + partition_num     = 50</span><br><span class="line">      + partition_used    = (known after apply)</span><br><span class="line">      + resource_group_id = (known after apply)</span><br><span class="line">      + security_group    = (known after apply)</span><br><span class="line">      + service_version   = (known after apply)</span><br><span class="line">      + spec_type         = &quot;normal&quot;</span><br><span class="line">      + status            = (known after apply)</span><br><span class="line">      + topic_left        = (known after apply)</span><br><span class="line">      + topic_num_of_buy  = (known after apply)</span><br><span class="line">      + topic_quota       = (known after apply)</span><br><span class="line">      + topic_used        = (known after apply)</span><br><span class="line">      + vpc_id            = (known after apply)</span><br><span class="line">      + vswitch_id        = &quot;vsw-bp1co65f3q2s0bis9yfkg&quot;</span><br><span class="line">      + zone_id           = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">Note: You didn&#x27;t use the -out option to save this plan, so Terraform can&#x27;t guarantee to take exactly these actions if you run &quot;terraform apply&quot; now.</span><br></pre></td></tr></table></figure>

<p>执行变更：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform apply</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.alikafka_instance.alicloud_alikafka_instance.this will be created</span></span><br><span class="line">  + resource &quot;alicloud_alikafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      + config            = (known after apply)</span><br><span class="line">      + deploy_type       = 5</span><br><span class="line">      + disk_size         = 500</span><br><span class="line">      + disk_type         = 1</span><br><span class="line">      + eip_max           = (known after apply)</span><br><span class="line">      + end_point         = (known after apply)</span><br><span class="line">      + group_left        = (known after apply)</span><br><span class="line">      + group_used        = (known after apply)</span><br><span class="line">      + id                = (known after apply)</span><br><span class="line">      + io_max            = 20</span><br><span class="line">      + io_max_spec       = (known after apply)</span><br><span class="line">      + is_partition_buy  = (known after apply)</span><br><span class="line">      + name              = &quot;alikafka-testV2&quot;</span><br><span class="line">      + paid_type         = &quot;PostPaid&quot;</span><br><span class="line">      + partition_left    = (known after apply)</span><br><span class="line">      + partition_num     = 50</span><br><span class="line">      + partition_used    = (known after apply)</span><br><span class="line">      + resource_group_id = (known after apply)</span><br><span class="line">      + security_group    = (known after apply)</span><br><span class="line">      + service_version   = (known after apply)</span><br><span class="line">      + spec_type         = &quot;normal&quot;</span><br><span class="line">      + status            = (known after apply)</span><br><span class="line">      + topic_left        = (known after apply)</span><br><span class="line">      + topic_num_of_buy  = (known after apply)</span><br><span class="line">      + topic_quota       = (known after apply)</span><br><span class="line">      + topic_used        = (known after apply)</span><br><span class="line">      + vpc_id            = (known after apply)</span><br><span class="line">      + vswitch_id        = &quot;vsw-bp1co65f3q2s0bis9yfkg&quot;</span><br><span class="line">      + zone_id           = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">Do you want to perform these actions?</span><br><span class="line">  Terraform will perform the actions described above.</span><br><span class="line">  Only &#x27;yes&#x27; will be accepted to approve.</span><br><span class="line"></span><br><span class="line">  Enter a value: yes</span><br><span class="line"></span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Creating...</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [50s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m0s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m50s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m0s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m50s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m0s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m50s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [4m0s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [4m10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [4m20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [4m30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [4m40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Creation complete after 4m45s [id=alikafka_post-cn-0gx44g6dm006]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure>

<h3 id="验证创建"><a href="#验证创建" class="headerlink" title="验证创建"></a>验证创建</h3><p>在前端查看是否成功创建实例：<br><img src="/img.png" alt="img.png"></p>
<h3 id="销毁资源"><a href="#销毁资源" class="headerlink" title="销毁资源"></a>销毁资源</h3><p>执行下面的命令进行销毁：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform destroy</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Refreshing state... [id=alikafka_post-cn-0gx44g6dm006]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  - destroy</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.alikafka_instance.alicloud_alikafka_instance.this will be destroyed</span></span><br><span class="line">  - resource &quot;alicloud_alikafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      - config            = jsonencode(</span><br><span class="line">            &#123;</span><br><span class="line">              - &quot;cloud.maxTieredStoreSpace&quot;           = &quot;0&quot;</span><br><span class="line">              - &quot;enable.acl&quot;                          = &quot;false&quot;</span><br><span class="line">              - &quot;enable.compact&quot;                      = &quot;true&quot;</span><br><span class="line">              - &quot;enable.tiered&quot;                       = &quot;false&quot;</span><br><span class="line">              - &quot;enable.vpc_sasl_ssl&quot;                 = &quot;false&quot;</span><br><span class="line">              - &quot;kafka.log.retention.hours&quot;           = &quot;72&quot;</span><br><span class="line">              - &quot;kafka.message.max.bytes&quot;             = &quot;1048576&quot;</span><br><span class="line">              - &quot;kafka.offsets.retention.minutes&quot;     = &quot;10080&quot;</span><br><span class="line">              - &quot;kafka.ssl.bit&quot;                       = &quot;1024&quot;</span><br><span class="line">              - &quot;message.timestamp.difference.max.ms&quot; = &quot;9223372036854775807&quot;</span><br><span class="line">              - &quot;message.timestamp.type&quot;              = &quot;CreateTime&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ) -&gt; null</span><br><span class="line">      - deploy_type       = 5 -&gt; null</span><br><span class="line">      - disk_size         = 500 -&gt; null</span><br><span class="line">      - disk_type         = 1 -&gt; null</span><br><span class="line">      - eip_max           = 0 -&gt; null</span><br><span class="line">      - end_point         = &quot;172.31.1.64:9092,172.31.1.66:9092,172.31.1.65:9092&quot; -&gt; null</span><br><span class="line">      - group_left        = 2100 -&gt; null</span><br><span class="line">      - group_used        = 0 -&gt; null</span><br><span class="line">      - id                = &quot;alikafka_post-cn-0gx44g6dm006&quot; -&gt; null</span><br><span class="line">      - io_max            = 20 -&gt; null</span><br><span class="line">      - io_max_spec       = &quot;alikafka.hw.2xlarge&quot; -&gt; null</span><br><span class="line">      - is_partition_buy  = 1 -&gt; null</span><br><span class="line">      - name              = &quot;alikafka-testV2&quot; -&gt; null</span><br><span class="line">      - paid_type         = &quot;PostPaid&quot; -&gt; null</span><br><span class="line">      - partition_left    = 1050 -&gt; null</span><br><span class="line">      - partition_num     = 50 -&gt; null</span><br><span class="line">      - partition_used    = 0 -&gt; null</span><br><span class="line">      - resource_group_id = &quot;rg-acfmzpn54i5ejry&quot; -&gt; null</span><br><span class="line">      - security_group    = &quot;sg-bp184o2lwjnssf12wf3w&quot; -&gt; null</span><br><span class="line">      - service_version   = &quot;2.2.0&quot; -&gt; null</span><br><span class="line">      - spec_type         = &quot;normal&quot; -&gt; null</span><br><span class="line">      - status            = 5 -&gt; null</span><br><span class="line">      - tags              = &#123;&#125; -&gt; null</span><br><span class="line">      - topic_left        = 1050 -&gt; null</span><br><span class="line">      - topic_num_of_buy  = 1050 -&gt; null</span><br><span class="line">      - topic_quota       = 1050 -&gt; null</span><br><span class="line">      - topic_used        = 0 -&gt; null</span><br><span class="line">      - vpc_id            = &quot;vpc-bp1sro6pb0sec14x7s05l&quot; -&gt; null</span><br><span class="line">      - vswitch_id        = &quot;vsw-bp1co65f3q2s0bis9yfkg&quot; -&gt; null</span><br><span class="line">      - zone_id           = &quot;zonei&quot; -&gt; null</span><br><span class="line">        # (1 unchanged attribute hidden)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 0 to add, 0 to change, 1 to destroy.</span><br><span class="line"></span><br><span class="line">Do you really want to destroy all resources?</span><br><span class="line">  Terraform will destroy all your managed infrastructure, as shown above.</span><br><span class="line">  There is no undo. Only &#x27;yes&#x27; will be accepted to confirm.</span><br><span class="line"></span><br><span class="line">  Enter a value: yes</span><br><span class="line"></span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Destroying... [id=alikafka_post-cn-0gx44g6dm006]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 50s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m1s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m11s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m21s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m31s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m41s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m51s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 2m1s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 2m11s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 2m21s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 2m31s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Destruction complete after 2m37s</span><br><span class="line"></span><br><span class="line">Destroy complete! Resources: 1 destroyed.</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>tencentcloud_ckafka_instance</title>
    <url>/2025/07/devops/terraform/tencentcloud_ckafka_instance/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>约定格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── aliyun                                             # 云厂商实例文件</span><br><span class="line">│   └── aliyun_ecs_mod_demo                           # 模型名</span><br><span class="line">│       └── aliyun_china_platform_7111                # 云账号名</span><br><span class="line">│           └── ecs_instance_name_20241224121212      # 实例名</span><br><span class="line">│               ├── backend.tf                        # 实例state文件保存说明：oss</span><br><span class="line">│               └── main.tf                           # 实例具体的参数</span><br><span class="line">├── modules                                            # 模型数据文件夹</span><br><span class="line">│   ├── aliyun                                        # 云厂商模型文件夹</span><br><span class="line">│   │   └── aliyun_ecs_mod_demo                       # 模型名</span><br><span class="line">│   │       ├── main.tf                               # 模型定义主文件</span><br><span class="line">│   │       ├── outputs.tf                            # 模型定义输出文件</span><br><span class="line">│   │       └── variables.tf                          # 模型定义参数文件</span><br><span class="line">│   └── tenmod                                         # 另一个云厂商模型</span><br><span class="line">└── tenent                                              # 另一个云厂商实例文件</span><br></pre></td></tr></table></figure>

<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── modules</span><br><span class="line">│   └── tcloud</span><br><span class="line">│       └── tcloud_ckafka_mod_demo</span><br><span class="line">│           ├── main.tf</span><br><span class="line">│           ├── outputs.tf</span><br><span class="line">│           └── variables.tf</span><br><span class="line">└── tcloud</span><br><span class="line">    └── tcloud_ckafka_demo</span><br><span class="line">        └── tcloud_china_game_x6</span><br><span class="line">            └── ckafaka_demo_202501221738</span><br><span class="line">                ├── backend.tf</span><br><span class="line">                └── main.tf</span><br></pre></td></tr></table></figure>

<h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><h3 id="modules-tcloud-tcloud-ckafka-mod-demo-main-tf"><a href="#modules-tcloud-tcloud-ckafka-mod-demo-main-tf" class="headerlink" title="&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;main.tf"></a>&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;main.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    tencentcloud = &#123;</span><br><span class="line">      source = &quot;tencentcloudstack/tencentcloud&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;tencentcloud&quot; &#123;</span><br><span class="line">  region = var.region</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;tencentcloud_availability_zones_by_product&quot; &quot;zone&quot; &#123;</span><br><span class="line">  name    = var.availability_zone</span><br><span class="line">  product = &quot;ckafka&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;tencentcloud_ckafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">  instance_name      = var.instance_name</span><br><span class="line">  zone_id            = data.tencentcloud_availability_zones_by_product.zone.zones[0].id</span><br><span class="line">  vpc_id             = var.vpc_id</span><br><span class="line">  subnet_id          = var.vswitch_id</span><br><span class="line">  msg_retention_time = var.msg_retention_time</span><br><span class="line">  kafka_version      = var.kafka_version</span><br><span class="line">  disk_size          = var.disk_size</span><br><span class="line">  band_width         = var.band_width</span><br><span class="line">  disk_type          = var.disk_type</span><br><span class="line">  partition          = var.partition</span><br><span class="line">  charge_type        = var.charge_type</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  config &#123;</span><br><span class="line">    auto_create_topic_enable   = var.auto_create_topic_enable</span><br><span class="line">    default_num_partitions     = var.num_partitions</span><br><span class="line">    default_replication_factor = var.replication_factor</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dynamic_retention_config &#123;</span><br><span class="line">    enable = var.dynamic_retention_config_enable</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="modules-tcloud-tcloud-ckafka-mod-demo-outputs-tf"><a href="#modules-tcloud-tcloud-ckafka-mod-demo-outputs-tf" class="headerlink" title="&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;outputs.tf"></a>&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;outputs.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">output &quot;ckafka_instance_id&quot; &#123;</span><br><span class="line">  value = tencentcloud_ckafka_instance.this.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="modules-tcloud-tcloud-ckafka-mod-demo-variables-tf"><a href="#modules-tcloud-tcloud-ckafka-mod-demo-variables-tf" class="headerlink" title="&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;variables.tf"></a>&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;variables.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">variable &quot;region&quot; &#123;</span><br><span class="line">  description = &quot;地域&quot;</span><br><span class="line">  type        = string</span><br><span class="line">  default     = &quot;ap-shanghai&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;instance_name&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例名&quot;</span><br><span class="line">  type        = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;availability_zone&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">如ap-shanghai-2</span></span><br><span class="line">  description = &quot;可用区&quot;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;charge_type&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">PREPAID(预付费), POSTPAID_BY_HOUR(按量付费)</span></span><br><span class="line">  description = &quot;kafka实例计费方式&quot;</span><br><span class="line">  type = string</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([&quot;PREPAID&quot;, &quot;POSTPAID_BY_HOUR&quot;], var.charge_type)</span><br><span class="line">    error_message = &quot;The charge_type must be one of PREPAID, POSTPAID_BY_HOUR&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;kafka_version&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">0.10.2/1.1.1/2.4.1/2.8.1</span></span><br><span class="line">  description = &quot;kafka实例版本&quot;</span><br><span class="line">  type = string</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([&quot;0.10.2&quot;, &quot;1.1.1&quot;, &quot;2.4.1&quot;, &quot;2.4.2&quot;, &quot;2.8.1&quot;], var.kafka_version)</span><br><span class="line">    error_message = &quot;The kafka_version must be one of 0.10.2, 1.1.1, 2.4.1, 2.4.2, 2.8.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">variable &quot;vswitch_id&quot; &#123;</span><br><span class="line">  // 阿里云vswitch_id -&gt; 腾讯云subnet_id</span><br><span class="line">  description = &quot;绑定子网id&quot;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;vpc_id&quot; &#123;</span><br><span class="line">  description = &quot;绑定vpc_id&quot;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;disk_size&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">需满足当前实例的计费规格，此处预设200和400，可以根据需要修改</span></span><br><span class="line">  description = &quot;kafka实例磁盘规格&quot;</span><br><span class="line">  type = number</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([200, 400], var.disk_size)</span><br><span class="line">    error_message = &quot;The disk_size must be one of 200, 400&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;disk_type&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">专业版实例磁盘类型，标准版实例不需要填写，CLOUD_SSD(SSD云硬盘), CLOUD_BASIC(高性能云硬盘)</span></span><br><span class="line">  description = &quot;kafka专业版实例磁盘类型&quot;</span><br><span class="line">  type = string</span><br><span class="line">  default = &quot;&quot;</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([&quot;&quot;, &quot;CLOUD_SSD&quot;, &quot;CLOUD_BASIC&quot;], var.disk_type)</span><br><span class="line">    error_message = &quot;The disk_type must be empty, or one of CLOUD_SSD, CLOUD_BASIC&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;band_width&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">单位为MBps.</span></span><br><span class="line">  description = &quot;kafka实例带宽&quot;</span><br><span class="line">  type = number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;auto_create_topic_enable&quot; &#123;</span><br><span class="line">  description = &quot;是否自动创建topic&quot;</span><br><span class="line">  type = bool</span><br><span class="line">  default = true</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([true, false], var.auto_create_topic_enable)</span><br><span class="line">    error_message = &quot;The auto_create_topic_enable must be one of true, false&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;num_partitions&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例默认分区数&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;replication_factor&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例默认副本数&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;dynamic_retention_config_enable&quot; &#123;</span><br><span class="line">  description = &quot;是否启用动态消息保留时间配置&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 0</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([0, 1], var.dynamic_retention_config_enable)</span><br><span class="line">    error_message = &quot;The dynamic_retention_config_enable must be one of 0, 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;msg_retention_time&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">以分钟为单位</span></span><br><span class="line">  description = &quot;kafka实例日志的最大保留时间&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 10080</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;partition&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例分区大小&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="tcloud-tcloud-ckafka-demo-tcloud-china-game-x6-ckafaka-demo-202501221738-backend-tf"><a href="#tcloud-tcloud-ckafka-demo-tcloud-china-game-x6-ckafaka-demo-202501221738-backend-tf" class="headerlink" title="&#x2F;tcloud&#x2F;tcloud_ckafka_demo&#x2F;tcloud_china_game_x6&#x2F;ckafaka_demo_202501221738&#x2F;backend.tf"></a>&#x2F;tcloud&#x2F;tcloud_ckafka_demo&#x2F;tcloud_china_game_x6&#x2F;ckafaka_demo_202501221738&#x2F;backend.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  backend &quot;oss&quot; &#123;</span><br><span class="line">    endpoint = &quot;oss-cn-hangzhou.aliyuncs.com&quot;</span><br><span class="line">    bucket   = &quot;dz-devops&quot; # 替换为你的 OSS Bucket 名称</span><br><span class="line">    prefix = &quot;terraform_state/tcloud/tcloud_ckafka_demo/tcloud_china_game_x6/ckafka_demo_202501221738&quot;</span><br><span class="line">    key      = &quot;terraform.tfstate&quot; # 存储状态文件的路径和名称</span><br><span class="line">    region   = &quot;cn-hangzhou&quot;       # OSS 的地域（根据你的实际情况调整）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcloud-tcloud-ckafka-demo-tcloud-china-game-x6-ckafaka-demo-202501221738-main-tf"><a href="#tcloud-tcloud-ckafka-demo-tcloud-china-game-x6-ckafaka-demo-202501221738-main-tf" class="headerlink" title="&#x2F;tcloud&#x2F;tcloud_ckafka_demo&#x2F;tcloud_china_game_x6&#x2F;ckafaka_demo_202501221738&#x2F;main.tf"></a>&#x2F;tcloud&#x2F;tcloud_ckafka_demo&#x2F;tcloud_china_game_x6&#x2F;ckafaka_demo_202501221738&#x2F;main.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module &quot;ckafka_instance&quot; &#123;</span><br><span class="line">  source              = &quot;../../../../modules/tcloud/tcloud_ckafka_mod_demo&quot;</span><br><span class="line">  region              = &quot;ap-shanghai&quot;</span><br><span class="line">  instance_name       = &quot;ckafka-test&quot;</span><br><span class="line">  availability_zone   = &quot;ap-shanghai-2&quot;</span><br><span class="line">  charge_type         = &quot;POSTPAID_BY_HOUR&quot;</span><br><span class="line">  kafka_version       = &quot;2.4.2&quot;</span><br><span class="line">  vpc_id              = &quot;vpc-4tkroxts&quot;</span><br><span class="line">  vswitch_id          = &quot;subnet-oy1pqvzv&quot;</span><br><span class="line">  disk_size           = 200</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">disk_type           = <span class="string">&quot;CLOUD_BASIC&quot;</span></span></span><br><span class="line">  band_width          = 20</span><br><span class="line">  auto_create_topic_enable = true</span><br><span class="line">  num_partitions     = 3</span><br><span class="line">  replication_factor = 3</span><br><span class="line">  dynamic_retention_config_enable = 1</span><br><span class="line">  msg_retention_time = 1300</span><br><span class="line">  partition = 400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><h3 id="获取-AK-SK"><a href="#获取-AK-SK" class="headerlink" title="获取 AK&#x2F;SK"></a>获取 AK&#x2F;SK</h3><p>在首次使用 Terraform 之前，需要前往腾讯云的<a href="https://console.cloud.tencent.com/cam/capi">云 API 密钥页面</a>申请安全凭证SecretId和SecretKey2。若已有可使用的安全凭证，则跳过该步骤2。具体步骤如下2：</p>
<ol>
<li>登录腾讯云<a href="https://console.cloud.tencent.com/cam">访问管理控制台</a>，在左侧导航栏，选择访问密钥&gt;API 密钥管理。</li>
<li>在API 密钥管理页面，单击新建密钥，即可以创建一对SecretId&#x2F;SecretKey。</li>
</ol>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>将获取到的SecretId和SecretKey设置为环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export TENCENTCLOUD_SECRET_ID=your_secret_id</span><br><span class="line">export TENCENTCLOUD_SECRET_KEY=your_secret_key</span><br></pre></td></tr></table></figure>

<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>进入项目根目录，这里是ckafaka_demo_202501221738目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./tcloud/tcloud_ckafka_demo/tcloud_china_game_x6/ckafaka_demo_202501221738/</span><br></pre></td></tr></table></figure>

<p>初始化 Terraform 项目:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xxx替换为实际backend的ak，将yyy替换为实际backend的sk</span></span><br><span class="line">terraform init -backend-config=&quot;access_key=xxx&quot; -backend-config=&quot;secret_key=yyy&quot;</span><br></pre></td></tr></table></figure>

<p>该命令会下载所需的插件和依赖，并初始化后端配置。<br>类似的输出（首次使用某一个provier时，会先下载）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Initializing the backend...</span><br><span class="line"></span><br><span class="line">Successfully configured the backend &quot;oss&quot;! Terraform will automatically</span><br><span class="line">use this backend unless the backend configuration changes.</span><br><span class="line">Initializing modules...</span><br><span class="line">- ckafka_instance in ../../../../modules/tcloud/tcloud_ckafka_mod_demo</span><br><span class="line">Initializing provider plugins...</span><br><span class="line">- Finding latest version of tencentcloudstack/tencentcloud...</span><br><span class="line">- Installing tencentcloudstack/tencentcloud v1.81.162...</span><br><span class="line">- Installed tencentcloudstack/tencentcloud v1.81.162 (signed by a HashiCorp partner, key ID 84F69E1C1BECF459)</span><br><span class="line">Partner and community providers are signed by their developers.</span><br><span class="line">If you&#x27;d like to know more about provider signing, you can read about it here:</span><br><span class="line">https://www.terraform.io/docs/cli/plugins/signing.html</span><br><span class="line">Terraform has created a lock file .terraform.lock.hcl to record the provider</span><br><span class="line">selections it made above. Include this file in your version control repository</span><br><span class="line">so that Terraform can guarantee to make the same selections by default when</span><br><span class="line">you run &quot;terraform init&quot; in the future.</span><br><span class="line"></span><br><span class="line">Terraform has been successfully initialized!</span><br><span class="line"></span><br><span class="line">You may now begin working with Terraform. Try running &quot;terraform plan&quot; to see</span><br><span class="line">any changes that are required for your infrastructure. All Terraform commands</span><br><span class="line">should now work.</span><br><span class="line"></span><br><span class="line">If you ever set or change modules or backend configuration for Terraform,</span><br><span class="line">rerun this command to reinitialize your working directory. If you forget, other</span><br><span class="line">commands will detect it and remind you to do so if necessary.</span><br></pre></td></tr></table></figure>

<h3 id="预览计划变更："><a href="#预览计划变更：" class="headerlink" title="预览计划变更："></a>预览计划变更：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform plan</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Reading...</span><br><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Read complete after 0s [id=2066006299]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.ckafka_instance.tencentcloud_ckafka_instance.this will be created</span></span><br><span class="line">  + resource &quot;tencentcloud_ckafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      + band_width          = 20</span><br><span class="line">      + charge_type         = &quot;POSTPAID_BY_HOUR&quot;</span><br><span class="line">      + disk_size           = 200</span><br><span class="line">      + disk_type           = &quot;CLOUD_BASIC&quot;</span><br><span class="line">      + id                  = (known after apply)</span><br><span class="line">      + instance_name       = &quot;ckafka-test&quot;</span><br><span class="line">      + instance_type       = (known after apply)</span><br><span class="line">      + kafka_version       = &quot;kafka_version&quot;</span><br><span class="line">      + max_message_byte    = (known after apply)</span><br><span class="line">      + msg_retention_time  = 1300</span><br><span class="line">      + partition           = 400</span><br><span class="line">      + public_network      = (known after apply)</span><br><span class="line">      + renew_flag          = (known after apply)</span><br><span class="line">      + specifications_type = &quot;profession&quot;</span><br><span class="line">      + subnet_id           = &quot;subnet-oy1pqvzv&quot;</span><br><span class="line">      + tag_set             = (known after apply)</span><br><span class="line">      + upgrade_strategy    = 1</span><br><span class="line">      + vip                 = (known after apply)</span><br><span class="line">      + vpc_id              = &quot;vpc-4tkroxts&quot;</span><br><span class="line">      + vport               = (known after apply)</span><br><span class="line">      + zone_id             = 200002</span><br><span class="line"></span><br><span class="line">      + config &#123;</span><br><span class="line">          + auto_create_topic_enable   = true</span><br><span class="line">          + default_num_partitions     = 3</span><br><span class="line">          + default_replication_factor = 3</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      + dynamic_retention_config &#123;</span><br><span class="line">          + bottom_retention        = (known after apply)</span><br><span class="line">          + disk_quota_percentage   = (known after apply)</span><br><span class="line">          + enable                  = 1</span><br><span class="line">          + step_forward_percentage = (known after apply)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      + tags (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">Note: You didn&#x27;t use the -out option to save this plan, so Terraform can&#x27;t guarantee to take exactly these actions if you run &quot;terraform apply&quot; now.</span><br></pre></td></tr></table></figure>

<p>执行变更：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform apply</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Reading...</span><br><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Read complete after 1s [id=2066006299]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.ckafka_instance.tencentcloud_ckafka_instance.this will be created</span></span><br><span class="line">  + resource &quot;tencentcloud_ckafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      + band_width          = 20</span><br><span class="line">      + charge_type         = &quot;POSTPAID_BY_HOUR&quot;</span><br><span class="line">      + disk_size           = 200</span><br><span class="line">      + disk_type           = &quot;CLOUD_BASIC&quot;</span><br><span class="line">      + id                  = (known after apply)</span><br><span class="line">      + instance_name       = &quot;ckafka-test&quot;</span><br><span class="line">      + instance_type       = (known after apply)</span><br><span class="line">      + kafka_version       = &quot;kafka_version&quot;</span><br><span class="line">      + max_message_byte    = (known after apply)</span><br><span class="line">      + msg_retention_time  = 1300</span><br><span class="line">      + partition           = 400</span><br><span class="line">      + public_network      = (known after apply)</span><br><span class="line">      + renew_flag          = (known after apply)</span><br><span class="line">      + specifications_type = &quot;profession&quot;</span><br><span class="line">      + subnet_id           = &quot;subnet-oy1pqvzv&quot;</span><br><span class="line">      + tag_set             = (known after apply)</span><br><span class="line">      + upgrade_strategy    = 1</span><br><span class="line">      + vip                 = (known after apply)</span><br><span class="line">      + vpc_id              = &quot;vpc-4tkroxts&quot;</span><br><span class="line">      + vport               = (known after apply)</span><br><span class="line">      + zone_id             = 200002</span><br><span class="line"></span><br><span class="line">      + config &#123;</span><br><span class="line">          + auto_create_topic_enable   = true</span><br><span class="line">          + default_num_partitions     = 3</span><br><span class="line">          + default_replication_factor = 3</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      + dynamic_retention_config &#123;</span><br><span class="line">          + bottom_retention        = (known after apply)</span><br><span class="line">          + disk_quota_percentage   = (known after apply)</span><br><span class="line">          + enable                  = 1</span><br><span class="line">          + step_forward_percentage = (known after apply)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      + tags (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">Do you want to perform these actions?</span><br><span class="line">  Terraform will perform the actions described above.</span><br><span class="line">  Only &#x27;yes&#x27; will be accepted to approve.</span><br><span class="line"></span><br><span class="line">  Enter a value: yes</span><br><span class="line"></span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Creating...</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [10s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [20s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [30s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [40s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [50s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m0s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m10s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m20s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m30s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m40s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m50s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m0s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m10s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m20s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m30s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m40s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m50s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [3m0s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Creation complete after 3m7s [id=ckafka-9jnda3jn]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure>

<h3 id="验证创建"><a href="#验证创建" class="headerlink" title="验证创建"></a>验证创建</h3><p>在前端查看是否成功创建实例：<br><img src="/img_1.png" alt="img_1.png"></p>
<h3 id="销毁资源"><a href="#销毁资源" class="headerlink" title="销毁资源"></a>销毁资源</h3><p>执行下面的命令进行销毁：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform destroy</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Reading...</span><br><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Read complete after 1s [id=2066006299]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Refreshing state... [id=ckafka-9jnda3jn]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  - destroy</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.ckafka_instance.tencentcloud_ckafka_instance.this will be destroyed</span></span><br><span class="line">  - resource &quot;tencentcloud_ckafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      - band_width          = 20 -&gt; null</span><br><span class="line">      - charge_type         = &quot;POSTPAID_BY_HOUR&quot; -&gt; null</span><br><span class="line">      - disk_size           = 200 -&gt; null</span><br><span class="line">      - disk_type           = &quot;CLOUD_BASIC&quot; -&gt; null</span><br><span class="line">      - id                  = &quot;ckafka-9jnda3jn&quot; -&gt; null</span><br><span class="line">      - instance_name       = &quot;ckafka-test&quot; -&gt; null</span><br><span class="line">      - instance_type       = 1 -&gt; null</span><br><span class="line">      - kafka_version       = &quot;0.10.2.1&quot; -&gt; null</span><br><span class="line">      - msg_retention_time  = 1300 -&gt; null</span><br><span class="line">      - partition           = 400 -&gt; null</span><br><span class="line">      - public_network      = 3 -&gt; null</span><br><span class="line">      - renew_flag          = 0 -&gt; null</span><br><span class="line">      - specifications_type = &quot;profession&quot; -&gt; null</span><br><span class="line">      - subnet_id           = &quot;subnet-oy1pqvzv&quot; -&gt; null</span><br><span class="line">      - tag_set             = &#123;&#125; -&gt; null</span><br><span class="line">      - upgrade_strategy    = 1 -&gt; null</span><br><span class="line">      - vip                 = &quot;172.17.0.3&quot; -&gt; null</span><br><span class="line">      - vpc_id              = &quot;vpc-4tkroxts&quot; -&gt; null</span><br><span class="line">      - vport               = &quot;9092&quot; -&gt; null</span><br><span class="line">      - zone_id             = 200002 -&gt; null</span><br><span class="line"></span><br><span class="line">      - config &#123;</span><br><span class="line">          - auto_create_topic_enable   = true -&gt; null</span><br><span class="line">          - default_num_partitions     = 3 -&gt; null</span><br><span class="line">          - default_replication_factor = 3 -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      - dynamic_retention_config &#123;</span><br><span class="line">          - bottom_retention        = 0 -&gt; null</span><br><span class="line">          - disk_quota_percentage   = 0 -&gt; null</span><br><span class="line">          - enable                  = 1 -&gt; null</span><br><span class="line">          - step_forward_percentage = 0 -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 0 to add, 0 to change, 1 to destroy.</span><br><span class="line"></span><br><span class="line">Do you really want to destroy all resources?</span><br><span class="line">  Terraform will destroy all your managed infrastructure, as shown above.</span><br><span class="line">  There is no undo. Only &#x27;yes&#x27; will be accepted to confirm.</span><br><span class="line"></span><br><span class="line">  Enter a value: yes</span><br><span class="line"></span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Destroying... [id=ckafka-9jnda3jn]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Destruction complete after 5s</span><br><span class="line"></span><br><span class="line">Destroy complete! Resources: 1 destroyed.</span><br></pre></td></tr></table></figure>

<h3 id="验证销毁"><a href="#验证销毁" class="headerlink" title="验证销毁"></a>验证销毁</h3><p><img src="/img_2.png" alt="img_2.png"></p>
]]></content>
  </entry>
  <entry>
    <title>git环境配置</title>
    <url>/2025/07/devops/environment/git%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="设置用户签名"><a href="#设置用户签名" class="headerlink" title="设置用户签名"></a>设置用户签名</h2><p>配置用户名： git config –global user.name 你的用户名<br>配置邮箱： git config –global user.email 注册的邮箱</p>
<p>配置好之后，可以用git config –global –list命令查看配置是否OK</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global --list</span></span><br><span class="line">user.name=xxx</span><br><span class="line">user.email=xxx@163.com</span><br></pre></td></tr></table></figure>

<h2 id="设置sshKey"><a href="#设置sshKey" class="headerlink" title="设置sshKey"></a>设置sshKey</h2><p>生成新的rsa密钥：ssh-keygen -t rsa -C ‘注册GitHub的邮箱’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C xxx@163.com</span><br></pre></td></tr></table></figure>

<p>一直回车就可以，即不设置密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C xxx@163.com</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/king/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /home/king/.ssh/id_rsa</span><br><span class="line">Your public key has been saved in /home/king/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:n+yyy xxx@163.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 3072]----+</span><br><span class="line">|    .*=.+.       |</span><br><span class="line">|    = +=o= o     |</span><br><span class="line">|     * ++ o .    |</span><br><span class="line">|  o . o..  .     |</span><br><span class="line">| o * .  S o      |</span><br><span class="line">|. X o  o = +     |</span><br><span class="line">| + + .. = *      |</span><br><span class="line">|..o .  o E       |</span><br><span class="line">|.o==    .        |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>

<p>此时已经生成了ssh ras的密钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> <span class="variable">$HOME</span>/.ssh</span></span><br><span class="line">authorized_keys  id_rsa  id_rsa.pub  known_hosts</span><br></pre></td></tr></table></figure>

<h2 id="设置github的SSH-key"><a href="#设置github的SSH-key" class="headerlink" title="设置github的SSH key"></a>设置github的SSH key</h2><p><img src="/img.png" alt="img.png"><br><img src="/img_1.png" alt="img_1.png"><br><img src="/img_2.png" alt="img_2.png"></p>
<p>将上面生成的ssh公钥复制进去。<br><img src="/img_3.png" alt="img_3.png"></p>
]]></content>
  </entry>
  <entry>
    <title>NPD介绍</title>
    <url>/2025/07/devops/npd/NPD%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>官方文档库地址：<a href="https://github.com/kubernetes/node-problem-detector">https://github.com/kubernetes/node-problem-detector</a></p>
<p>node-problem-detector 旨在使集群管理堆栈中的上游层能够看到各种节点问题。</p>
<p>它是一个在每个节点上运行的守护进程，检测节点问题并将其报告给apiserver。</p>
<p>node-problem-detector 可以作为 DaemonSet 运行，也可以独立运行。</p>
<p>现在它作为 GKE集群中默认启用的Kubernetes Addon运行。它也作为AKS Linux Extension的一部分在 AKS 中默认启用。</p>
<h2 id="1-2-背景"><a href="#1-2-背景" class="headerlink" title="1.2 背景"></a>1.2 背景</h2><p>大量节点问题可能会影响节点上运行的 pod，例如：</p>
<ul>
<li>基础设施守护进程问题：ntp 服务关闭；</li>
<li>硬件问题：CPU、内存或磁盘损坏；</li>
<li>内核问题：内核死锁、文件系统损坏；</li>
<li>容器运行时问题：运行时守护进程无响应；</li>
<li>…</li>
</ul>
<p>目前，这些问题对于集群管理堆栈中的上游层是不可见的，因此 Kubernetes 将继续将 pod 调度到坏节点。<br>为了解决这个问题，我们引入了这个新的守护进程node-problem-detector来从各种守护进程收集节点问题，并将它们提供给上游层。一旦上游层能够看到这些问题，我们就可以讨论 <a href="https://github.com/kubernetes/node-problem-detector?tab=readme-ov-file#remedy-systems">remedy systems</a>了。</p>
<h2 id="1-3-Problem-API"><a href="#1-3-Problem-API" class="headerlink" title="1.3 Problem API"></a>1.3 Problem API</h2><p>node-problem-detector 使用Event并向NodeConditionapiserver 报告问题。</p>
<ul>
<li>NodeCondition：导致节点无法用于 pod 的永久性问题应报告为NodeCondition。</li>
<li>Event：对 pod 影响有限但具有参考意义的临时问题应报告为Event。</li>
</ul>
<h2 id="1-4-Problem-Daemon"><a href="#1-4-Problem-Daemon" class="headerlink" title="1.4 Problem Daemon"></a>1.4 Problem Daemon</h2><p>问题守护进程是 node-problem-detector 的一个子守护进程。它监视特定类型的节点问题并将其报告给 node-problem-detector。<br>守护进程可能是：</p>
<ul>
<li>专为 Kubernetes 专用用例设计的微型守护进程。</li>
<li>与节点问题检测器集成的现有节点健康监控守护进程。</li>
</ul>
<p>目前，问题守护进程在 node-problem-detector 二进制文件中以 goroutine 的形式运行。</p>
<p>未来，我们会将 node-problem-detector和问题守护进程分离到不同的容器中，并使用 pod 规范将它们组合在一起。</p>
<p>每种类型的问题守护进程都可以通过设置相应的构建标签在编译时禁用。</p>
<p>如果在编译时禁用它们，则它们的所有构建依赖项、全局变量和后台goroutine 都将从编译的可执行文件中剔除。</p>
<p>支持的守护进程列表：</p>
<table>
<thead>
<tr>
<th>问题守护进程类型</th>
<th>节点状态</th>
<th>解释</th>
<th>配置</th>
<th>禁用构建标签</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/systemlogmonitor">SystemLogMonitor</a></td>
<td>KernelDeadlock ReadonlyFilesystem FrequentKubeletRestart FrequentDockerRestart FrequentContainerdRestart</td>
<td>系统日志监视器监视系统日志并根据预定义的规则报告问题和指标。</td>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor-filelog.json">filelog</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor.json">kmsg</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor-counter.json">kernel</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/systemd-monitor-counter.json">abrt</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/systemd-monitor-counter.json">systemd</a></td>
<td>disable_system_log_monitor</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/systemstatsmonitor">SystemStatsMonitor</a></td>
<td>None(Could be added in the future)</td>
<td>节点问题检测器的系统统计监视器，用于收集各种与健康相关的系统统计信息作为指标。请参阅<a href="https://docs.google.com/document/d/1SeaUz6kBavI283Dq8GBpoEUDrHA2a795xtw0OvjM568/edit">此处</a>的提案。</td>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/system-stats-monitor.json">system-stats-monitor</a></td>
<td>disable_system_stats_monitor</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/custompluginmonitor">CustomPluginMonitor</a></td>
<td>On-demand(According to users configuration), existing example: NTPProblem</td>
<td>一个自定义的 node-problem-detector 插件监控器，用于调用和检查各种节点问题，并使用用户定义的检查脚本。请参阅<a href="https://docs.google.com/document/d/1jK_5YloSYtboj-DtfjmYKxfNnUxCAvohLnsH5aGCAYQ/edit#">此处</a>的提案。</td>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/4ad49bbd84b8ced45ac825eac01ec93d9235935e/config/custom-plugin-monitor.json">example</a></td>
<td>disable_custom_plugin_monitor</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/healthchecker">HealthChecker</a></td>
<td>KubeletUnhealthy ContainerRuntimeUnhealthy</td>
<td>节点问题检测器的健康检查器用于检查 kubelet 和容器运行时的健康状况。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-5-Exporter"><a href="#1-5-Exporter" class="headerlink" title="1.5 Exporter"></a>1.5 Exporter</h2><p>exporter 是 node-problem-detector 的一个组件。</p>
<p>它向某些后端报告节点问题 和&#x2F;或 指标。</p>
<p>其中一些可以在编译时使用构建标记禁用。支持的导出器列表：</p>
<table>
<thead>
<tr>
<th>Exporter</th>
<th>解释</th>
<th>禁用构建标签</th>
</tr>
</thead>
<tbody><tr>
<td>Kubernetes exporter</td>
<td>Kubernetes 导出器向 Kubernetes API 服务器报告节点问题：临时问题报告为事件，永久问题报告为节点状况。</td>
<td></td>
</tr>
<tr>
<td>Prometheus exporter</td>
<td>Prometheus 导出器将节点问题和指标本地报告为 Prometheus 指标</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/exporter/stackdriver-exporter.json">Stackdriver exporter</a></td>
<td>Stackdriver 导出器向 Stackdriver Monitoring API 报告节点问题和指标。</td>
<td>disable_stackdriver_exporter</td>
</tr>
</tbody></table>
<h2 id="1-6-用法"><a href="#1-6-用法" class="headerlink" title="1.6 用法"></a>1.6 用法</h2><h3 id="1-6-1-标志"><a href="#1-6-1-标志" class="headerlink" title="1.6.1 标志"></a>1.6.1 标志</h3><ul>
<li>–version：打印节点问题检测器的当前版本。</li>
<li>–hostname-override：node-problem-detector 用于更新状态和发出事件的自定义节点名称。node-problem-detector 首先从hostname-override获取节点名称，然后从NODE_NAME环境变量 获取，最后返回到os.Hostname。</li>
</ul>
<h3 id="1-6-2-对于系统日志监控"><a href="#1-6-2-对于系统日志监控" class="headerlink" title="1.6.2 对于系统日志监控"></a>1.6.2 对于系统日志监控</h3><ul>
<li>–config.system-log-monitor：系统日志监视器配置文件路径列表，以逗号分隔，例如 config&#x2F;kernel-monitor.json。节点问题检测器将为每个配置启动单独的日志监视器。您可以使用不同的日志监视器来监视不同的系统日志。</li>
</ul>
<h3 id="1-6-3-对于系统统计监控"><a href="#1-6-3-对于系统统计监控" class="headerlink" title="1.6.3 对于系统统计监控"></a>1.6.3 对于系统统计监控</h3><ul>
<li>–config.system-stats-monitor：系统统计监控配置文件的路径列表，以逗号分隔，例如 <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/system-stats-monitor.json">config&#x2F;system-stats-monitor.json</a>。节点问题检测器将为每个配置启动一个单独的系统统计监控器。您可以使用不同的系统统计监控器来监控与问题相关的不同系统统计信息。</li>
</ul>
<h3 id="1-6-4-对于自定义插件监视器"><a href="#1-6-4-对于自定义插件监视器" class="headerlink" title="1.6.4 对于自定义插件监视器"></a>1.6.4 对于自定义插件监视器</h3><ul>
<li>–config.custom-plugin-monitor：自定义插件监控配置文件路径列表，以逗号分隔，例如 <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/custom-plugin-monitor.json">config&#x2F;custom-plugin-monitor.json</a>。节点问题检测器将为每个配置启动一个单独的自定义插件监控。您可以使用不同的自定义插件监控来监控不同的节点问题。</li>
</ul>
<h3 id="1-6-5-对于健康检查者"><a href="#1-6-5-对于健康检查者" class="headerlink" title="1.6.5 对于健康检查者"></a>1.6.5 对于健康检查者</h3><ul>
<li>–enable-k8s-exporter：启用向 Kubernetes API 服务器报告，默认为true。</li>
<li>–apiserver-override：用于自定义 node-problem-detector 如何连接 apiserver 的 URI 参数。如果–enable-k8s-exporter是，则忽略此参数。格式与<a href="https://github.com/kubernetes/heapster">Heapster</a> 的标志false相同。例如，要无需身份验证即可运行，请使用以下配置： <a href="https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md#kubernetes">source</a></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://APISERVER_IP:APISERVER_PORT?inClusterConfig=false</span><br></pre></td></tr></table></figure>

<p>请参阅<a href="https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md#kubernetes">heapster 文档</a><br>以获取可用选项的完整列表。</p>
<ul>
<li>–address：绑定节点问题检测服务器的地址。</li>
<li>–port：绑定节点问题检测服务器的端口。使用 0 表示禁用。</li>
</ul>
<h3 id="1-6-6-对于-Prometheus-exporter"><a href="#1-6-6-对于-Prometheus-exporter" class="headerlink" title="1.6.6 对于 Prometheus exporter"></a>1.6.6 对于 Prometheus exporter</h3><ul>
<li>–prometheus-address：绑定Prometheus抓取端点的地址，默认为127.0.0.1。</li>
<li>–prometheus-port：绑定 Prometheus 抓取端点的端口，默认为 20257。使用 0 表示禁用。</li>
</ul>
<h3 id="1-6-7-对于-Stackdriver-exporter"><a href="#1-6-7-对于-Stackdriver-exporter" class="headerlink" title="1.6.7 对于 Stackdriver exporter"></a>1.6.7 对于 Stackdriver exporter</h3><ul>
<li>–exporter.stackdriver：Stackdriver 导出器配置文件的路径，例如config&#x2F;exporter&#x2F;stackdriver-exporter.json，默认为空字符串。设置为空字符串即可禁用。</li>
</ul>
<h3 id="1-6-8-已弃用的标志"><a href="#1-6-8-已弃用的标志" class="headerlink" title="1.6.8 已弃用的标志"></a>1.6.8 已弃用的标志</h3><ul>
<li>–system-log-monitors：系统日志监控配置文件的路径列表，以逗号分隔。此选项已弃用，由–config.system-log-monitor替代，并将被删除。如果同时设置–system-log-monitors和 –config.system-log-monitor ， NPD 将崩溃。</li>
<li>–custom-plugin-monitors：自定义插件监控配置文件的路径列表，以逗号分隔。此选项已弃用，由–config.custom-plugin-monitor替代，并将被删除。如果同时设置–custom-plugin-monitors和 –config.custom-plugin-monitor，NPD 将崩溃。</li>
</ul>
<h2 id="1-7-构建镜像"><a href="#1-7-构建镜像" class="headerlink" title="1.7 构建镜像"></a>1.7 构建镜像</h2><ul>
<li>安装libsystemdARM GCC 工具链的开发依赖项<ul>
<li>Debian &#x2F; Ubuntu：apt install libsystemd-dev gcc-aarch64-linux-gnu</li>
</ul>
</li>
<li>git clone <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;</a>:kubernetes&#x2F;node-problem-detector.git</li>
<li>在顶层目录中运行make。它将：<ul>
<li>构建二进制文件。</li>
<li>构建docker镜像。二进制文件和config&#x2F;被复制到docker镜像中。</li>
</ul>
</li>
</ul>
<p>如果您不需要某些类别的问题守护进程，您可以选择在编译时禁用它们。这是保持 node-problem-detector运行时紧凑且没有不必要代码（例如全局变量、goroutines 等）的最佳方法。</p>
<p>您可以通过BUILD_TAGS在运行之前设置环境变量来实现这一点make。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BUILD_TAGS=&quot;disable_custom_plugin_monitor disable_system_stats_monitor&quot; make</span><br></pre></td></tr></table></figure>

<p>上述命令将在不使用<a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/custompluginmonitor">自定义插件监视器</a>和<a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/systemstatsmonitor">系统统计监视器</a>的情况下编译node-problem-detector 。查看<a href="https://github.com/kubernetes/node-problem-detector#problem-daemon">问题守护进程</a>部分，了解如何在编译时禁用每个问题守护进程。</p>
<h2 id="1-8-推送镜像"><a href="#1-8-推送镜像" class="headerlink" title="1.8 推送镜像"></a>1.8 推送镜像</h2><p><code>make push</code>将 docker 镜像上传到注册表。默认情况下，镜像将上传到 <code>staging-k8s.gcr.io</code>。可以轻松修改<code>Makefile</code>以将镜像推送到另一个注册表。</p>
<h2 id="1-9-安装"><a href="#1-9-安装" class="headerlink" title="1.9 安装"></a>1.9 安装</h2><p>将 node-problem-detector<br>安装到集群中的最简单方法是使用<a href="https://github.com/deliveryhero/helm-charts/tree/master/stable/node-problem-detector">Helm 图表</a>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm repo add deliveryhero https://charts.deliveryhero.io/</span><br><span class="line">helm install --generate-name deliveryhero/node-problem-detector</span><br></pre></td></tr></table></figure>

<p>或者，手动安装 node-problem-detector：</p>
<p>编辑<a href="https://github.com/kubernetes/node-problem-detector/blob/master/deployment/node-problem-detector.yaml">node-problem-detector.yaml</a>以适应您的环境。将<code>log</code>卷设置为您的系统日志目录（由 SystemLogMonitor 使用）。您可以使用 ConfigMap 覆盖<code>config</code> pod 内的目录。</p>
<p>编辑<a href="https://github.com/kubernetes/node-problem-detector/blob/master/deployment/node-problem-detector-config.yaml">node-problem-detector-config.yaml</a>来配置 node-problem-detector。</p>
<ul>
<li>编辑<a href="https://github.com/kubernetes/node-problem-detector/blob/master/deployment/rbac.yaml">rbac.yaml</a>以适合您的环境。</li>
<li>使用 创建 ServiceAccount 和 ClusterRoleBinding <code>kubectl create -f rbac.yaml</code>。</li>
<li>使用 创建 ConfigMap <code>kubectl create -f node-problem-detector-config.yaml</code>。</li>
<li>使用 创建 DaemonSet <code>kubectl create -f node-problem-detector.yaml</code>。</li>
</ul>
<h2 id="1-10-开始独立运行"><a href="#1-10-开始独立运行" class="headerlink" title="1.10 开始独立运行"></a>1.10 开始独立运行</h2><p>要独立运行 node-problem-detector，您应该设置inClusterConfig为false，并且教 node-problem-detector 如何 访问 apiserver，也就是apiserver-override。</p>
<p>要使用不安全的 apiserver 连接独立运行 node-problem-detector：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node-problem-detector --apiserver-override=http://APISERVER_IP:APISERVER_INSECURE_PORT?inClusterConfig=false</span><br></pre></td></tr></table></figure>

<p>更多场景请见<a href="https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md#kubernetes">此处</a></p>
<h2 id="1-11-试用"><a href="#1-11-试用" class="headerlink" title="1.11 试用"></a>1.11 试用</h2><p>您可以在正在运行的集群中尝试使用 node-problem-detector，方法是将消息注入到 node-problem-detector 正在监视的日志中。</p>
<p>例如，假设 node-problem-detector 正在使用KernelMonitor。</p>
<p>在您的机器上运行<code>kubectl get events -w</code>。在节点上运行<code>sudo sh -c &quot;echo &#39;kernel: BUG: unable to handle kernel NULL pointer dereference at TESTING&#39; &gt;&gt; /dev/kmsg&quot;</code>。然后您应该会看到该KernelOopss事件。</p>
<p>添加新规则或开发节点问题检测器时，在独立模式下在本地工作站上进行测试可能更容易。</p>
<p>对于 API 服务器，一种简单的方法是使用kubectl proxy正在运行的集群的 API 服务器在本地可用。</p>
<p>您会收到一些错误，因为 API 服务器无法识别您的本地工作站。但无论如何，您仍然应该能够测试您的新规则。</p>
<p>例如，测试KernelMonitor规则：</p>
<ul>
<li><code>make</code>（本地构建node-problem-detector）</li>
<li><code>kubectl proxy --port=8080</code>（使正在运行的集群的 API 服务器在本地可用）</li>
<li>将KernelMonitor更新到您的本地内核日志目录<code>logPath</code>。例如，在某些 Linux 系统上，它是<code>/run/log/journal</code>, 而不是<code>/var/log/journal</code>。</li>
<li><code>./bin/node-problem-detector --logtostderr --apiserver-override=http://127.0.0.1:8080?inClusterConfig=false --config.system-log-monitor=config/kernel-monitor.json --config.system-stats-monitor=config/system-stats-monitor.json --port=20256 --prometheus-port=2025</code>（或指向任何 API 服务器地址：端口和 Prometheus 端口）</li>
<li><code>sudo sh -c &quot;echo &#39;kernel: BUG: unable to handle kernel NULL pointer dereference at TESTING&#39; &gt;&gt; /dev/kmsg&quot;</code></li>
<li>您可以<code>KernelOops</code>在节点问题检测器日志中看到事件。</li>
<li><code>sudo sh -c &quot;echo &#39;kernel: INFO: task docker:20744 blocked for more than 120 seconds.&#39; &gt;&gt; /dev/kmsg&quot;</code></li>
<li>您可以在node-problem-detector log看DockerHung event和状态</li>
<li>您可以在<a href="http://127.0.0.1:20256/conditions%E6%9F%A5%E7%9C%8B%60DockerHung%60%E7%8A%B6%E6%80%81">http://127.0.0.1:20256/conditions查看DockerHung状态</a></li>
<li>您可以在<a href="http://127.0.0.1:20257/metrics%E4%B8%8A%E6%9F%A5%E7%9C%8B">http://127.0.0.1:20257/metrics</a>上查看 Prometheus 格式的磁盘相关系统指标。</li>
</ul>
<p>注： 您可以在<a href="https://github.com/kubernetes/node-problem-detector/tree/master/test/kernel_log_generator/problems">test&#x2F;kernel_log_generator&#x2F;problems</a>下查看更多规则示例。</p>
<ul>
<li>对于<a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor.json">KernelMonitor</a><br>消息注入，所有消息都应该有kernel: 前缀（另请注意，后面有一个空格:）；或者使用<a href="https://github.com/kubernetes/node-problem-detector/blob/master/test/kernel_log_generator/generator.sh">generator.sh</a>。</li>
<li>要将其他日志（如 systemd 日志）注入 journald，请使用<code>echo &#39;Some systemd message&#39; | systemd-cat -t systemd</code>。</li>
</ul>
<h2 id="1-12-Remedy-Systems"><a href="#1-12-Remedy-Systems" class="headerlink" title="1.12 Remedy Systems"></a>1.12 Remedy Systems</h2><p>Remedy Systems是一个或多个旨在尝试解决node-problem-detector检测到的问题的过程。</p>
<p>Remedy Systems会观察node-problem-detector发出的事件 和&#x2F;或 节点状况，并采取措施使 Kubernetes 集群恢复健康状态。</p>
<p>补救系统有以下几种：</p>
<ul>
<li><a href="https://github.com/planetlabs/draino">Draino</a> 根据标签和节点条件自动排空 Kubernetes节点。与所有提供的标签和任何提供的节点条件匹配的节点将被阻止立即接受新 pod（也称为“封锁”），并在可配置的时间后<a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/">排空</a>。Draino可以与 <a href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler">Cluster Autoscaler</a>结合使用，以自动终止排空的节点。请参阅 <a href="https://github.com/kubernetes/node-problem-detector/issues/199">此问题</a> ，了解 Draino的示例生产用例。</li>
<li><a href="https://github.com/kubernetes-sigs/descheduler">Descheduler</a> 取消调度策略RemovePodsViolatingNodeTaints会驱逐节点上违反NoSchedule污染的Pod。必须启用k8s调度程序的TaintNodesByCondition功能。</li>
<li><a href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler">Cluster Autoscaler</a> 可用于自动终止耗尽的节点。</li>
<li><a href="https://github.com/medik8s">mediK8S</a> 是一个基于<a href="https://github.com/medik8s/node-healthcheck-operator">Node Health Check Operator (NHC)</a>构建的自动修复系统的总体项目，该系统监控节点状况并使用修复 API将修复委托给外部修复程序。</li>
<li><a href="https://github.com/medik8s/poison-pill">Poison-Pill</a>是一个修复程序，它将重新启动节点并确保所有有状态的工作负载都得到重新安排。如果集群具有足够的健康容量，NHC支持有条件地进行修复，或者手动暂停任何操作以最大限度地减少集群中断。</li>
<li><a href="https://cluster-api.sigs.k8s.io/">Cluster API</a> 的<a href="https://cluster-api.sigs.k8s.io/developer/architecture/controllers/machine-health-check">MachineHealthCheck</a>负责修复不健康的机器。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Npd代码结构了解</title>
    <url>/2025/07/devops/npd/Npd%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="1-pkg目录结构"><a href="#1-pkg目录结构" class="headerlink" title="1 pkg目录结构"></a>1 pkg目录结构</h1><p>这里是各个monitor的实现。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── custompluginmonitor             -&gt; 用于实现自定义监视插件。node-problem-detector 支持通过插件监视特定状态或事件，此目录中包含与用户自定义插件相关的代码。</span><br><span class="line">├── exporters                       -&gt; 用于包含导出器（exporters）的实现，导出器负责将监视到的数据发送到外部系统，比如监控系统（例如 Prometheus）。导出器在数据收集和监控集成中起到关键作用。</span><br><span class="line">├── healthchecker                   -&gt; 实现健康检查逻辑，确保 node-problem-detector 本身和其他依赖的组件处于健康状态。这是监控和维护软件稳定性的重要部分。</span><br><span class="line">├── logcounter                      -&gt; 实现了 logcounter 的功能，通常用于计数和分析系统日志，以检测异常行为或问题。它可以与系统日志监控结合使用。</span><br><span class="line">├── problemdaemon                   -&gt; 实现问题守护程序。这个守护程序负责监测和识别节点中的问题，通过问题发现机制收集指标并生成告警。</span><br><span class="line">├── problemdetector                 -&gt; 包含问题检测的核心逻辑。这是 node-problem-detector 的主要功能部分，负责从不同的来源收集信息，并根据这些信息识别和报告节点问题。</span><br><span class="line">├── problemmetrics                  -&gt; 包含问题指标的实现，用于收集、处理和导出有关节点状态和问题的数据。这些指标可以展示在监控界面上，帮助用户理解系统的健康状况。</span><br><span class="line">├── systemlogmonitor                -&gt; 实现了系统日志监控的功能。它处理系统日志，分析日志内容，以检测可能导致问题的事件和错误。</span><br><span class="line">├── systemstatsmonitor              -&gt; 用于监控系统的各种统计数据，例如 CPU 使用率、内存使用情况等。它负责收集和报告这些统计信息，以帮助验证节点的健康状态。</span><br><span class="line">├── types                           -&gt; 用于定义项目中使用的各种类型结构体和常量。这些类型通常用于数据传输和处理，为核心逻辑提供数据模型。</span><br><span class="line">├── util                            -&gt; 包含一些公用工具函数和库，这些函数可以在其他模块中复用，提高代码的可维护性和可读性。</span><br><span class="line">└── version                         -&gt; 保存与版本相关的信息和结构。它用于管理版本号并提供版本信息的功能</span><br></pre></td></tr></table></figure>

<h1 id="2-problemdaemon"><a href="#2-problemdaemon" class="headerlink" title="2 problemdaemon"></a>2 problemdaemon</h1><h2 id="2-1-Register"><a href="#2-1-Register" class="headerlink" title="2.1 Register"></a>2.1 Register</h2><p>pkg&#x2F;problemdaemon&#x2F;problem_daemon.go:32</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">        handlers = make(map[types.ProblemDaemonType]types.ProblemDaemonHandler)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Register registers a problem daemon factory method, which will be used to create the problem daemon.</span><br><span class="line">func Register(problemDaemonType types.ProblemDaemonType, handler types.ProblemDaemonHandler) &#123;</span><br><span class="line">        handlers[problemDaemonType] = handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册一个问题守护进程工厂方法。<br>参数：</p>
<ul>
<li>problemDaemonType: 需要注册的守护进程类型。</li>
<li>handler: 对应的处理器，其中包含创建守护进程的方法。<br>作用：将指定类型的处理器添加到 handlers 映射中，以便后续根据类型获取对应的处理器。</li>
</ul>
<h2 id="2-2-GetProblemDaemonNames"><a href="#2-2-GetProblemDaemonNames" class="headerlink" title="2.2 GetProblemDaemonNames"></a>2.2 GetProblemDaemonNames</h2><p>pkg&#x2F;problemdaemon&#x2F;problem_daemon.go:37</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// GetProblemDaemonNames retrieves all available problem daemon types.</span><br><span class="line">func GetProblemDaemonNames() []types.ProblemDaemonType &#123;</span><br><span class="line">        problemDaemonTypes := []types.ProblemDaemonType&#123;&#125;</span><br><span class="line">        for problemDaemonType := range handlers &#123;</span><br><span class="line">                problemDaemonTypes = append(problemDaemonTypes, problemDaemonType)</span><br><span class="line">        &#125;</span><br><span class="line">        return problemDaemonTypes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检索所有可用的问题守护进程类型。</p>
<p>返回值：返回一个包含所有注册的守护进程类型的切片。</p>
<p>实现细节：遍历 handlers 映射，将每种问题守护进程类型添加到返回的切片中。</p>
<h2 id="2-3-GetProblemDaemonHandlerOrDie"><a href="#2-3-GetProblemDaemonHandlerOrDie" class="headerlink" title="2.3 GetProblemDaemonHandlerOrDie"></a>2.3 GetProblemDaemonHandlerOrDie</h2><p>pkg&#x2F;problemdaemon&#x2F;problem_daemon.go:46</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// GetProblemDaemonHandlerOrDie retrieves the ProblemDaemonHandler for a specific type of problem daemon, panic if error occurs..</span><br><span class="line">func GetProblemDaemonHandlerOrDie(problemDaemonType types.ProblemDaemonType) types.ProblemDaemonHandler &#123;</span><br><span class="line">        handler, ok := handlers[problemDaemonType]</span><br><span class="line">        if !ok &#123;</span><br><span class="line">                panic(fmt.Sprintf(&quot;Problem daemon handler for %v does not exist&quot;, problemDaemonType))</span><br><span class="line">        &#125;</span><br><span class="line">        return handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取特定类型问题守护进程的处理器。</p>
<p>参数：问题守护进程类型。</p>
<p>返回值：返回对应的处理器。</p>
<p>实现细节：如果指定类型没有找到对应的处理器，则触发恐慌（panic），这通常用于在初始化时确保配置的有效性。</p>
<h2 id="2-4-NewProblemDaemons"><a href="#2-4-NewProblemDaemons" class="headerlink" title="2.4 NewProblemDaemons"></a>2.4 NewProblemDaemons</h2><p>pkg&#x2F;problemdaemon&#x2F;problem_daemon.go:55</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// NewProblemDaemons creates all problem daemons based on the configurations provided.</span><br><span class="line">func NewProblemDaemons(monitorConfigPaths types.ProblemDaemonConfigPathMap) []types.Monitor &#123;</span><br><span class="line">        problemDaemonMap := make(map[string]types.Monitor)</span><br><span class="line">        for problemDaemonType, configs := range monitorConfigPaths &#123;</span><br><span class="line">                for _, config := range *configs &#123;</span><br><span class="line">                        if _, ok := problemDaemonMap[config]; ok &#123;</span><br><span class="line">                                // Skip the config if it&#x27;s duplicated.</span><br><span class="line">                                klog.Warningf(&quot;Duplicated problem daemon configuration %q&quot;, config)</span><br><span class="line">                                continue</span><br><span class="line">                        &#125;</span><br><span class="line">                        problemDaemonMap[config] = handlers[problemDaemonType].CreateProblemDaemonOrDie(config)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        problemDaemons := []types.Monitor&#123;&#125;</span><br><span class="line">        for _, problemDaemon := range problemDaemonMap &#123;</span><br><span class="line">                problemDaemons = append(problemDaemons, problemDaemon)</span><br><span class="line">        &#125;</span><br><span class="line">        return problemDaemons</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据提供的配置创建所有问题守护进程。</p>
<p>参数：</p>
<p>monitorConfigPaths: 包含每种问题守护进程类型及其对应配置路径的映射。<br>返回值：返回创建的所有 Monitor 实例的切片。<br>实现细节</p>
<ul>
<li>创建空映射：使用 problemDaemonMap 存储已创建的守护进程，以避免重复。</li>
<li>遍历配置：<ul>
<li>对于配置中的每种问题守护进程类型及其相应的配置路径，检查是否已经创建。</li>
<li>如果配置已存在，则记录警告并跳过。</li>
<li>使用注册的处理器创建新的问题守护进程并将其添加到映射中。</li>
</ul>
</li>
<li>返回值构建：将地图中的所有守护进程转换为切片并返回。</li>
</ul>
<h1 id="3-problem-detector"><a href="#3-problem-detector" class="headerlink" title="3 problem_detector"></a>3 problem_detector</h1><h2 id="3-1-problemDetector定义"><a href="#3-1-problemDetector定义" class="headerlink" title="3.1 problemDetector定义"></a>3.1 problemDetector定义</h2><p>pkg&#x2F;problemdetector&#x2F;problem_detector.go:33</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// ProblemDetector collects statuses from all problem daemons and update the node condition and send node event.</span><br><span class="line">type ProblemDetector interface &#123;</span><br><span class="line">        Run(context.Context) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type problemDetector struct &#123;</span><br><span class="line">        monitors  []types.Monitor</span><br><span class="line">        exporters []types.Exporter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段：</p>
<p>monitors: 存储监控器的切片，用于收集问题状态。</p>
<p>exporters: 存储导出器的切片，用于将收集到的状态发送到外部系统或用户。</p>
<p>方法说明： Run(context.Context) error 启动问题检测器，并在上下文被取消或出现错误时返回错误。</p>
<h2 id="3-2-NewProblemDetector"><a href="#3-2-NewProblemDetector" class="headerlink" title="3.2 NewProblemDetector"></a>3.2 NewProblemDetector</h2><p>pkg&#x2F;problemdetector&#x2F;problem_detector.go:40</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// NewProblemDetector creates the problem detector. Currently we just directly passed in the problem daemons, but</span><br><span class="line">// in the future we may want to let the problem daemons register themselves.</span><br><span class="line">func NewProblemDetector(monitors []types.Monitor, exporters []types.Exporter) ProblemDetector &#123;</span><br><span class="line">        return &amp;problemDetector&#123;</span><br><span class="line">                monitors:  monitors,</span><br><span class="line">                exporters: exporters,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个新的问题检测器实例。</p>
<p>参数：</p>
<p>monitors: 监控器数组，用于检测不同问题。</p>
<p>exporters: 导出器数组，用于将状态发送给外部系统。</p>
<p>返回值：返回实现 ProblemDetector 接口的新的 problemDetector 实例。</p>
<h2 id="3-3-Run"><a href="#3-3-Run" class="headerlink" title="3.3 Run"></a>3.3 Run</h2><p>pkg&#x2F;problemdetector&#x2F;problem_detector.go:48</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// Run starts the problem detector.</span><br><span class="line">func (p *problemDetector) Run(ctx context.Context) error &#123;</span><br><span class="line">        // Start the log monitors one by one.</span><br><span class="line">        var chans []&lt;-chan *types.Status</span><br><span class="line">        failureCount := 0</span><br><span class="line">        for _, m := range p.monitors &#123;</span><br><span class="line">                ch, err := m.Start()</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        // Do not return error and keep on trying the following config files.</span><br><span class="line">                        klog.Errorf(&quot;Failed to start problem daemon %v: %v&quot;, m, err)</span><br><span class="line">                        failureCount++</span><br><span class="line">                        continue</span><br><span class="line">                &#125;</span><br><span class="line">                if ch != nil &#123;</span><br><span class="line">                        chans = append(chans, ch)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        allMonitors := p.monitors</span><br><span class="line"></span><br><span class="line">        if len(allMonitors) == failureCount &#123;</span><br><span class="line">                return fmt.Errorf(&quot;no problem daemon is successfully setup&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        defer func() &#123;</span><br><span class="line">                for _, m := range allMonitors &#123;</span><br><span class="line">                        m.Stop()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        ch := groupChannel(chans)</span><br><span class="line">        klog.Info(&quot;Problem detector started&quot;)</span><br><span class="line"></span><br><span class="line">        for &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-ctx.Done():</span><br><span class="line">                        return nil</span><br><span class="line">                case status := &lt;-ch:</span><br><span class="line">                        for _, exporter := range p.exporters &#123;</span><br><span class="line">                                exporter.ExportProblems(status)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行问题检测器的主要运行逻辑。</p>
<p>实现细节：</p>
<ul>
<li>开始监控器：遍历并启动每个监控器。</li>
<li>如果启动失败，记录错误并增加失败计数。</li>
<li>如果成功，则将返回的通道添加到 chans 切片。</li>
<li>检查失败情况：如果所有监控器都失败，则返回错误。</li>
<li>延迟关闭：在函数结束时停止所有监控器。</li>
<li>通道组合：调用 groupChannel 函数，用于将所有监控器的状态通道组合成单一通道。</li>
<li>监听状态：使用 select 不断监听上下文和监控器的状态。</li>
<li>如果收到状态，从所有导出器导出问题。</li>
</ul>
<h2 id="3-4-groupChannel"><a href="#3-4-groupChannel" class="headerlink" title="3.4 groupChannel"></a>3.4 groupChannel</h2><p>pkg&#x2F;problemdetector&#x2F;problem_detector.go:91</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func groupChannel(chans []&lt;-chan *types.Status) &lt;-chan *types.Status &#123;</span><br><span class="line">        statuses := make(chan *types.Status)</span><br><span class="line">        for _, ch := range chans &#123;</span><br><span class="line">                go func(c &lt;-chan *types.Status) &#123;</span><br><span class="line">                        for status := range c &#123;</span><br><span class="line">                                statuses &lt;- status</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;(ch)</span><br><span class="line">        &#125;</span><br><span class="line">        return statuses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将多个状态通道组合为一个通道。</p>
<p>参数：切片 chans，包含多个状态通道。</p>
<p>返回值：返回一个新的通道 statuses，用于接收来自所有监控器的状态。</p>
<p>实现细节</p>
<p>启动多个 goroutine，每个 goroutine 从一个监控器的通道读取状态，并将其转发到新的 statuses 通道中。</p>
<h1 id="4-problemmetrics"><a href="#4-problemmetrics" class="headerlink" title="4 problemmetrics"></a>4 problemmetrics</h1><h2 id="4-1-ProblemMetricsManager定义"><a href="#4-1-ProblemMetricsManager定义" class="headerlink" title="4.1 ProblemMetricsManager定义"></a>4.1 ProblemMetricsManager定义</h2><p>pkg&#x2F;problemmetrics&#x2F;problem_metrics.go:40</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// ProblemMetricsManager manages problem-converted metrics.</span><br><span class="line">// ProblemMetricsManager is thread-safe.</span><br><span class="line">type ProblemMetricsManager struct &#123;</span><br><span class="line">        problemCounter           metrics.Int64MetricInterface</span><br><span class="line">        problemGauge             metrics.Int64MetricInterface</span><br><span class="line">        problemTypeToReason      map[string]string</span><br><span class="line">        problemTypeToReasonMutex sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段：</p>
<ul>
<li>problemCounter: 一个整型指标接口，用于计数特定问题发生的次数。</li>
<li>problemGauge: 一个整型指标接口，用于表示特定问题是否对节点产生影响。</li>
<li>problemTypeToReason: 一个映射，保存问题类型与原因的关系。</li>
<li>problemTypeToReasonMutex: 一个互斥锁，用于保护 problemTypeToReason 的并发访问。</li>
</ul>
<h2 id="4-2-init"><a href="#4-2-init" class="headerlink" title="4.2 init"></a>4.2 init</h2><p>pkg&#x2F;problemmetrics&#x2F;problem_metrics.go:31</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// GlobalProblemMetricsManager is a singleton of ProblemMetricsManager,</span><br><span class="line">// which should be used to manage all problem-converted metrics across all</span><br><span class="line">// problem daemons.</span><br><span class="line">var GlobalProblemMetricsManager *ProblemMetricsManager</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">        GlobalProblemMetricsManager = NewProblemMetricsManagerOrDie()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GlobalProblemMetricsManager: 全局唯一的 ProblemMetricsManager 实例，用于管理所有问题相关的指标。</p>
<p>init 函数: 在程序启动时初始化 GlobalProblemMetricsManager，确保其可用。</p>
<h2 id="4-3-NewProblemMetricsManagerOrDie"><a href="#4-3-NewProblemMetricsManagerOrDie" class="headerlink" title="4.3 NewProblemMetricsManagerOrDie"></a>4.3 NewProblemMetricsManagerOrDie</h2><p>pkg&#x2F;problemmetrics&#x2F;problem_metrics.go:47</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func NewProblemMetricsManagerOrDie() *ProblemMetricsManager &#123;</span><br><span class="line">        pmm := ProblemMetricsManager&#123;&#125;</span><br><span class="line"></span><br><span class="line">        var err error</span><br><span class="line">        pmm.problemCounter, err = metrics.NewInt64Metric(</span><br><span class="line">                metrics.ProblemCounterID,</span><br><span class="line">                string(metrics.ProblemCounterID),</span><br><span class="line">                &quot;Number of times a specific type of problem have occurred.&quot;,</span><br><span class="line">                &quot;1&quot;,</span><br><span class="line">                metrics.Sum,</span><br><span class="line">                []string&#123;&quot;reason&quot;&#125;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                klog.Fatalf(&quot;Failed to create problem_counter metric: %v&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pmm.problemGauge, err = metrics.NewInt64Metric(</span><br><span class="line">                metrics.ProblemGaugeID,</span><br><span class="line">                string(metrics.ProblemGaugeID),</span><br><span class="line">                &quot;Whether a specific type of problem is affecting the node or not.&quot;,</span><br><span class="line">                &quot;1&quot;,</span><br><span class="line">                metrics.LastValue,</span><br><span class="line">                []string&#123;&quot;type&quot;, &quot;reason&quot;&#125;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                klog.Fatalf(&quot;Failed to create problem_gauge metric: %v&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pmm.problemTypeToReason = make(map[string]string)</span><br><span class="line"></span><br><span class="line">        return &amp;pmm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建并初始化 ProblemMetricsManager 实例。</p>
<p>实现细节：</p>
<p>创建 problemCounter 指标，用于记录特定问题的发生次数，接收标签 reason。</p>
<p>创建 problemGauge 指标，用于指示特定问题是否正在影响节点，接收标签 type 和 reason。</p>
<p>如果创建指标失败，则程序会崩溃（Fatalf）。</p>
<p>初始化问题类型到原因的映射。</p>
<h2 id="4-4-IncrementProblemCounter"><a href="#4-4-IncrementProblemCounter" class="headerlink" title="4.4 IncrementProblemCounter"></a>4.4 IncrementProblemCounter</h2><p>pkg&#x2F;problemmetrics&#x2F;problem_metrics.go:79</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// IncrementProblemCounter increments the value of a problem counter.</span><br><span class="line">func (pmm *ProblemMetricsManager) IncrementProblemCounter(reason string, count int64) error &#123;</span><br><span class="line">        if pmm.problemCounter == nil &#123;</span><br><span class="line">                return errors.New(&quot;problem counter is being incremented before initialized.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pmm.problemCounter.Record(map[string]string&#123;&quot;reason&quot;: reason&#125;, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加问题计数器的值，根据 reason 标签记录统计数据。</p>
<p>参数：</p>
<p>reason: 问题发生的原因。</p>
<p>count: 要增加的数量。</p>
<p>返回值：返回可能的错误。</p>
<h2 id="4-5-SetProblemGauge"><a href="#4-5-SetProblemGauge" class="headerlink" title="4.5 SetProblemGauge"></a>4.5 SetProblemGauge</h2><p>pkg&#x2F;problemmetrics&#x2F;problem_metrics.go:88</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// SetProblemGauge sets the value of a problem gauge.</span><br><span class="line">func (pmm *ProblemMetricsManager) SetProblemGauge(problemType string, reason string, value bool) error &#123;</span><br><span class="line">        if pmm.problemGauge == nil &#123;</span><br><span class="line">                return errors.New(&quot;problem gauge is being set before initialized.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pmm.problemTypeToReasonMutex.Lock()</span><br><span class="line">        defer pmm.problemTypeToReasonMutex.Unlock()</span><br><span class="line"></span><br><span class="line">        // We clear the last reason, because the expected behavior is that at any point of time,</span><br><span class="line">        // for each type of permanent problem, there should be at most one reason got set to 1.</span><br><span class="line">        // This behavior is consistent with the behavior of node condition in Kubernetes.</span><br><span class="line">        // However, problemGauges with different &quot;type&quot; and &quot;reason&quot; are considered as different</span><br><span class="line">        // metrics in Prometheus. So we need to clear the previous metrics explicitly.</span><br><span class="line">        if lastReason, ok := pmm.problemTypeToReason[problemType]; ok &#123;</span><br><span class="line">                err := pmm.problemGauge.Record(map[string]string&#123;&quot;type&quot;: problemType, &quot;reason&quot;: lastReason&#125;, 0)</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        return fmt.Errorf(&quot;failed to clear previous reason %q for type %q: %v&quot;,</span><br><span class="line">                                problemType, lastReason, err)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pmm.problemTypeToReason[problemType] = reason</span><br><span class="line"></span><br><span class="line">        var valueInt int64</span><br><span class="line">        if value &#123;</span><br><span class="line">                valueInt = 1</span><br><span class="line">        &#125;</span><br><span class="line">        return pmm.problemGauge.Record(map[string]string&#123;&quot;type&quot;: problemType, &quot;reason&quot;: reason&#125;, valueInt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置问题量规的值，指示特定问题对节点的影响。</p>
<p>参数：</p>
<ul>
<li>problemType: 问题类型（例如，节点不可用）。</li>
<li>reason: 具体原因。</li>
<li>value: 表示问题的状态，true表示问题存在 (1)，false表示问题消失 (0)。</li>
</ul>
<p>实现细节：</p>
<ul>
<li>使用互斥锁保护对 problemTypeToReason 的并发访问。</li>
<li>清除之前的原因（如果存在），保证每个问题类型在任何时刻都最多只有一个原因被设置为 1。</li>
<li>记录新的量规值。</li>
</ul>
<h1 id="5-exporters"><a href="#5-exporters" class="headerlink" title="5 exporters"></a>5 exporters</h1><p>目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── k8sexporter</span><br><span class="line">│   ├── condition</span><br><span class="line">│   ├── k8s_exporter.go</span><br><span class="line">│   └── problemclient</span><br><span class="line">├── prometheusexporter</span><br><span class="line">│   └── prometheus_exporter.go</span><br><span class="line">├── register.go</span><br><span class="line">├── register_test.go</span><br><span class="line">└── stackdriver</span><br><span class="line">    ├── config</span><br><span class="line">    ├── gce</span><br><span class="line">    ├── stackdriver_exporter.go</span><br><span class="line">    └── stackdriver_exporter_test.go</span><br></pre></td></tr></table></figure>
<p>这里就涉及到了三个exporter，分别是k8sexporter、prometheusexporter、stackdriver_exporter</p>
<p>这三个是比较独立的，因为能力是完全不一样的，</p>
<ul>
<li>exporter：专注于将types.Status的event和conditation上报，并且会有一些http服务接口开放(healthz、conditions、&#x2F;debug&#x2F;pprof)，</li>
<li>prometheusexporter：直接用的prometheuse的库，简单理解就是为了让prometheuse可以采集到数据</li>
<li>stackdriver_exporter：处理与 Google Stackdriver 的集成，Stackdriver 是 Google Cloud 提供的监控和管理平台，该exporter负责将指标数据发送到<br>Stackdriver，以便在 Google Cloud 环境中监控应用程序和集群状态。</li>
</ul>
<p>这里来说说我的理解吧，prometheusexporter和stackdriver_exporter这两个exporter是为了将metric数据发送到对应的监控平台，而k8sexporter则是为了将types.Status发送到k8s，目前已经开始向register继承方向延展，如stackdriver_exporter已经使用该模式并且已经统一了struct的实现方法，但是prometheusexporter和k8sexporter还没完成演变，目前还是通过package直接调用的方式使用的。</p>
<p>这个模块就不进行代码级别解析了，整体是非常简单的。</p>
<h1 id="6-healthchecker"><a href="#6-healthchecker" class="headerlink" title="6 healthchecker"></a>6 healthchecker</h1><p>目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── health_checker.go</span><br><span class="line">├── health_checker_darwin.go</span><br><span class="line">├── health_checker_linux.go</span><br><span class="line">├── health_checker_test.go</span><br><span class="line">├── health_checker_windows.go</span><br><span class="line">└── types</span><br><span class="line">├── types.go</span><br><span class="line">├── types_test.go</span><br><span class="line">├── types_unix.go</span><br><span class="line">└── types_windows.go</span><br></pre></td></tr></table></figure>

<p>6.1 healthChecker定义<br>pkg&#x2F;healthchecker&#x2F;health_checker.go:31</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type healthChecker struct &#123;</span><br><span class="line">  component       string</span><br><span class="line">  service         string</span><br><span class="line">  enableRepair    bool</span><br><span class="line">  healthCheckFunc func () (bool, error)</span><br><span class="line">  // The repair is &quot;best-effort&quot; and ignores the error from the underlying actions.</span><br><span class="line">  // The bash commands to kill the process will fail if the service is down and hence ignore.</span><br><span class="line">  repairFunc         func ()</span><br><span class="line">  uptimeFunc         func () (time.Duration, error)</span><br><span class="line">  crictlPath         string</span><br><span class="line">  healthCheckTimeout time.Duration</span><br><span class="line">  coolDownTime       time.Duration</span><br><span class="line">  loopBackTime       time.Duration</span><br><span class="line">  logPatternsToCheck map[string]int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段含义：</p>
<ul>
<li>component：被检查的 Kubernetes 组件名称（如 Kubelet、Kube Proxy 等）。</li>
<li>service：服务名称或标识符。</li>
<li>enableRepair：布尔值，指示是否在发现服务不健康时尝试修复它。</li>
<li>healthCheckFunc：一个函数，用于执行健康检查，返回健康状态和可能的错误。</li>
<li>repairFunc：一个函数，用于尝试修复不健康的服务。</li>
<li>uptimeFunc：一个函数，用于获取服务的运行时间。</li>
<li>crictlPath：指向 CRI 工具的路径。</li>
<li>healthCheckTimeout：健康检查的超时设置。</li>
<li>coolDownTime：在尝试修复之前要求服务必须正常运行的时间。</li>
<li>loopBackTime：用于回溯检查日志的时间段。</li>
<li>logPatternsToCheck：一个映射，包含要检查的日志模式及其出现次数阈值。</li>
</ul>
<h2 id="6-2-NewHealthChecker"><a href="#6-2-NewHealthChecker" class="headerlink" title="6.2 NewHealthChecker"></a>6.2 NewHealthChecker</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:48</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// NewHealthChecker returns a new health checker configured with the given options.</span><br><span class="line">func NewHealthChecker(hco *options.HealthCheckerOptions) (types.HealthChecker, error) &#123;</span><br><span class="line">  hc := &amp;healthChecker&#123;</span><br><span class="line">    component:          hco.Component,</span><br><span class="line">    enableRepair:       hco.EnableRepair,</span><br><span class="line">    crictlPath:         hco.CriCtlPath,</span><br><span class="line">    healthCheckTimeout: hco.HealthCheckTimeout,</span><br><span class="line">    coolDownTime:       hco.CoolDownTime,</span><br><span class="line">    service:            hco.Service,</span><br><span class="line">    loopBackTime:       hco.LoopBackTime,</span><br><span class="line">    logPatternsToCheck: hco.LogPatterns.GetLogPatternCountMap(),</span><br><span class="line">  &#125;</span><br><span class="line">  hc.healthCheckFunc = getHealthCheckFunc(hco)</span><br><span class="line">  hc.repairFunc = getRepairFunc(hco)</span><br><span class="line">  hc.uptimeFunc = getUptimeFunc(hco.Service)</span><br><span class="line">  return hc, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NewHealthChecker会根据输入的options.HealthCheckerOptions来进行types.HealthChecker的构造。</p>
<h2 id="6-3-CheckHealth"><a href="#6-3-CheckHealth" class="headerlink" title="6.3 CheckHealth"></a>6.3 CheckHealth</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:67</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// CheckHealth checks for the health of the component and tries to repair if enabled.</span><br><span class="line">// Returns true if healthy, false otherwise.</span><br><span class="line">func (hc *healthChecker) CheckHealth() (bool, error) &#123;</span><br><span class="line">        healthy, err := hc.healthCheckFunc()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return healthy, err</span><br><span class="line">        &#125;</span><br><span class="line">        logPatternHealthy, err := logPatternHealthCheck(hc.service, hc.loopBackTime, hc.logPatternsToCheck)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return logPatternHealthy, err</span><br><span class="line">        &#125;</span><br><span class="line">        if healthy &amp;&amp; logPatternHealthy &#123;</span><br><span class="line">                return true, nil</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // The service is unhealthy.</span><br><span class="line">        // Attempt repair based on flag.</span><br><span class="line">        if hc.enableRepair &#123;</span><br><span class="line">                // repair if the service has been up for the cool down period.</span><br><span class="line">                uptime, err := hc.uptimeFunc()</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        klog.Infof(&quot;error in getting uptime for %v: %v\n&quot;, hc.component, err)</span><br><span class="line">                        return false, nil</span><br><span class="line">                &#125;</span><br><span class="line">                klog.Infof(&quot;%v is unhealthy, component uptime: %v\n&quot;, hc.component, uptime)</span><br><span class="line">                if uptime &gt; hc.coolDownTime &#123;</span><br><span class="line">                        klog.Infof(&quot;%v cooldown period of %v exceeded, repairing&quot;, hc.component, hc.coolDownTime)</span><br><span class="line">                        hc.repairFunc()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查组件的健康状态，返回是否健康，并在不健康的情况下尝试修复。</p>
<p>逻辑：</p>
<ul>
<li>调用 healthCheckFunc 执行健康检查。</li>
<li>使用 logPatternHealthCheck 检查日志模式。</li>
<li>如果组件不健康且启用了修复，检查组件的运行时间并调用修复函数。</li>
</ul>
<h2 id="6-4-logPatternHealthCheck"><a href="#6-4-logPatternHealthCheck" class="headerlink" title="6.4 logPatternHealthCheck"></a>6.4 logPatternHealthCheck</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// logPatternHealthCheck checks for the provided logPattern occurrences in the service logs.</span><br><span class="line">// Returns true if the pattern is empty or does not exist logThresholdCount times since start of service, false otherwise.</span><br><span class="line">func logPatternHealthCheck(service string, loopBackTime time.Duration, logPatternsToCheck map[string]int) (bool, error) &#123;</span><br><span class="line">        if len(logPatternsToCheck) == 0 &#123;</span><br><span class="line">                return true, nil</span><br><span class="line">        &#125;</span><br><span class="line">        uptimeFunc := getUptimeFunc(service)</span><br><span class="line">        klog.Infof(&quot;Getting uptime for service: %v\n&quot;, service)</span><br><span class="line">        uptime, err := uptimeFunc()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                klog.Warningf(&quot;Failed to get the uptime: %+v&quot;, err)</span><br><span class="line">                return true, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logStartTime := time.Now().Add(-uptime).Format(types.LogParsingTimeLayout)</span><br><span class="line">        if loopBackTime &gt; 0 &amp;&amp; uptime &gt; loopBackTime &#123;</span><br><span class="line">                logStartTime = time.Now().Add(-loopBackTime).Format(types.LogParsingTimeLayout)</span><br><span class="line">        &#125;</span><br><span class="line">        for pattern, count := range logPatternsToCheck &#123;</span><br><span class="line">                healthy, err := checkForPattern(service, logStartTime, pattern, count)</span><br><span class="line">                if err != nil || !healthy &#123;</span><br><span class="line">                        return healthy, err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查服务日志中指定模式的出现次数。</p>
<p>参数：</p>
<ul>
<li>service：被监控的服务名称。</li>
<li>loopBackTime：用于确定要检查的日志时间范围。</li>
<li>logPatternsToCheck：要检查的日志模式及其出现的阈值。<br>返回值：布尔值表示健康状态和可能的错误。</li>
</ul>
<h2 id="6-5-healthCheckEndpointOKFunc"><a href="#6-5-healthCheckEndpointOKFunc" class="headerlink" title="6.5 healthCheckEndpointOKFunc"></a>6.5 healthCheckEndpointOKFunc</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:126</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// healthCheckEndpointOKFunc returns a function to check the status of an http endpoint</span><br><span class="line">func healthCheckEndpointOKFunc(endpoint string, timeout time.Duration) func() (bool, error) &#123;</span><br><span class="line">        return func() (bool, error) &#123;</span><br><span class="line">                httpClient := http.Client&#123;Timeout: timeout&#125;</span><br><span class="line">                response, err := httpClient.Get(endpoint)</span><br><span class="line">                if err != nil || response.StatusCode != http.StatusOK &#123;</span><br><span class="line">                        return false, nil</span><br><span class="line">                &#125;</span><br><span class="line">                return true, nil</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回一个函数，该函数检查给定 HTTP 端点的健康状态。</p>
<p>参数：端点 URI 和超时时间。</p>
<p>返回值：健康检查函数。</p>
<h2 id="6-6-getHealthCheckFunc"><a href="#6-6-getHealthCheckFunc" class="headerlink" title="6.6 getHealthCheckFunc"></a>6.6 getHealthCheckFunc</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:138</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// getHealthCheckFunc returns the health check function based on the component.</span><br><span class="line">func getHealthCheckFunc(hco *options.HealthCheckerOptions) func() (bool, error) &#123;</span><br><span class="line">        switch hco.Component &#123;</span><br><span class="line">        case types.KubeletComponent:</span><br><span class="line">                return healthCheckEndpointOKFunc(types.KubeletHealthCheckEndpoint(), hco.HealthCheckTimeout)</span><br><span class="line">        case types.KubeProxyComponent:</span><br><span class="line">                return healthCheckEndpointOKFunc(types.KubeProxyHealthCheckEndpoint(), hco.HealthCheckTimeout)</span><br><span class="line">        case types.DockerComponent:</span><br><span class="line">                return func() (bool, error) &#123;</span><br><span class="line">                        if _, err := execCommand(hco.HealthCheckTimeout, getDockerPath(), &quot;ps&quot;); err != nil &#123;</span><br><span class="line">                                return false, nil</span><br><span class="line">                        &#125;</span><br><span class="line">                        return true, nil</span><br><span class="line">                &#125;</span><br><span class="line">        case types.CRIComponent:</span><br><span class="line">                return func() (bool, error) &#123;</span><br><span class="line">                        _, err := execCommand(</span><br><span class="line">                                hco.HealthCheckTimeout,</span><br><span class="line">                                hco.CriCtlPath,</span><br><span class="line">                                &quot;--timeout=&quot;+hco.CriTimeout.String(),</span><br><span class="line">                                &quot;--runtime-endpoint=&quot;+hco.CriSocketPath,</span><br><span class="line">                                &quot;pods&quot;,</span><br><span class="line">                                &quot;--latest&quot;,</span><br><span class="line">                        )</span><br><span class="line">                        if err != nil &#123;</span><br><span class="line">                                return false, nil</span><br><span class="line">                        &#125;</span><br><span class="line">                        return true, nil</span><br><span class="line">                &#125;</span><br><span class="line">        default:</span><br><span class="line">                klog.Warningf(&quot;Unsupported component: %v&quot;, hco.Component)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据组件类型返回相应的健康检查方法。</p>
<p>参数：健康检查选项。</p>
<p>返回值：执行健康检查的函数。</p>
<h2 id="6-7-execCommand"><a href="#6-7-execCommand" class="headerlink" title="6.7 execCommand"></a>6.7 execCommand</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:174</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// execCommand executes the bash command and returns the (output, error) from command, error if timeout occurs.</span><br><span class="line">func execCommand(timeout time.Duration, command string, args ...string) (string, error) &#123;</span><br><span class="line">        ctx, cancel := context.WithTimeout(context.Background(), timeout)</span><br><span class="line">        defer cancel()</span><br><span class="line">        cmd := exec.CommandContext(ctx, command, args...)</span><br><span class="line">        out, err := cmd.CombinedOutput()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                klog.Infof(&quot;command %v failed: %v, %s\n&quot;, cmd, err, string(out))</span><br><span class="line">                return &quot;&quot;, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return strings.TrimSuffix(string(out), &quot;\n&quot;), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行给定的命令，并在指定的超时时间内返回输出和错误。</p>
<p>参数：超时时间、命令和参数。</p>
<p>返回值：命令的输出和错误信息。</p>
<h2 id="6-8-getUptimeFunc"><a href="#6-8-getUptimeFunc" class="headerlink" title="6.8 getUptimeFunc"></a>6.8 getUptimeFunc</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker_linux.go:32</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// getUptimeFunc returns the time for which the given service has been running.</span><br><span class="line">func getUptimeFunc(service string) func() (time.Duration, error) &#123;</span><br><span class="line">        return func() (time.Duration, error) &#123;</span><br><span class="line">                // Using InactiveExitTimestamp to capture the exact time when systemd tried starting the service. The service will</span><br><span class="line">                // transition from inactive -&gt; activating and the timestamp is captured.</span><br><span class="line">                // Source : https://www.freedesktop.org/wiki/Software/systemd/dbus/</span><br><span class="line">                // Using ActiveEnterTimestamp resulted in race condition where the service was repeatedly killed by plugin when</span><br><span class="line">                // RestartSec of systemd and invoke interval of plugin got in sync. The service was repeatedly killed in</span><br><span class="line">                // activating state and hence ActiveEnterTimestamp was never updated.</span><br><span class="line">                out, err := execCommand(types.CmdTimeout, &quot;systemctl&quot;, &quot;show&quot;, service, &quot;--property=InactiveExitTimestamp&quot;)</span><br><span class="line"></span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        return time.Duration(0), err</span><br><span class="line">                &#125;</span><br><span class="line">                val := strings.Split(out, &quot;=&quot;)</span><br><span class="line">                if len(val) &lt; 2 &#123;</span><br><span class="line">                        return time.Duration(0), errors.New(&quot;could not parse the service uptime time correctly&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                t, err := time.Parse(types.UptimeTimeLayout, val[1])</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        return time.Duration(0), err</span><br><span class="line">                &#125;</span><br><span class="line">                return time.Since(t), nil</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回一个函数，计算指定服务的运行时间。</p>
<p>参数：</p>
<ul>
<li><p>service string - 被监控服务的名称。</p>
</li>
<li><p>返回值：返回一个函数，该函数返回服务运行的持续时间或错误。</p>
</li>
<li><p>实现细节</p>
</li>
<li><p>使用 systemctl show 命令获取 InactiveExitTimestamp，这是服务从 inactive 状态转换时的时间戳。</p>
</li>
<li><p>解析命令的输出，将时间戳转换为 time.Time 类型，并计算自该时间以来的持续时间。</p>
</li>
<li><p>此方法可用于获取服务的当前运行时间，以便评估是否在修复之前达到冷却时间。</p>
</li>
</ul>
<h2 id="6-9-getRepairFunc"><a href="#6-9-getRepairFunc" class="headerlink" title="6.9 getRepairFunc"></a>6.9 getRepairFunc</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker_linux.go:58</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// getRepairFunc returns the repair function based on the component.</span><br><span class="line">func getRepairFunc(hco *options.HealthCheckerOptions) func() &#123;</span><br><span class="line">        // Use `systemctl kill` instead of `systemctl restart` for the repair function.</span><br><span class="line">        // We start to rely on the kernel message difference for the two commands to</span><br><span class="line">        // indicate if the component restart is due to an administrative plan (restart)</span><br><span class="line">        // or a system issue that needs repair (kill).</span><br><span class="line">        // See https://github.com/kubernetes/node-problem-detector/issues/847.</span><br><span class="line">        switch hco.Component &#123;</span><br><span class="line">        case types.DockerComponent:</span><br><span class="line">                // Use &quot;docker ps&quot; for docker health check. Not using crictl for docker to remove</span><br><span class="line">                // dependency on the kubelet.</span><br><span class="line">                return func() &#123;</span><br><span class="line">                        execCommand(types.CmdTimeout, &quot;pkill&quot;, &quot;-SIGUSR1&quot;, &quot;dockerd&quot;)</span><br><span class="line">                        execCommand(types.CmdTimeout, &quot;systemctl&quot;, &quot;kill&quot;, &quot;--kill-who=main&quot;, hco.Service)</span><br><span class="line">                &#125;</span><br><span class="line">        default:</span><br><span class="line">                // Just kill the service for all other components</span><br><span class="line">                return func() &#123;</span><br><span class="line">                        execCommand(types.CmdTimeout, &quot;systemctl&quot;, &quot;kill&quot;, &quot;--kill-who=main&quot;, hco.Service)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据服务的组件类型返回一个演示修复功能的方法。</p>
<p>参数：</p>
<ul>
<li>hco *options.HealthCheckerOptions - 健康检查的选项。</li>
<li>返回值：返回一个函数，该函数执行相应修复操作。</li>
</ul>
<p>实现细节</p>
<ul>
<li>对于 Docker 组件，通过 pkill 发送 SIGUSR1 信号以更优雅地停止 Docker 守护进程。</li>
<li>对于其他组件，调用 systemctl kill 命令终止主要进程。</li>
<li>这种设计使得修复功能能够根据不同的组件采取合适的处理方式。</li>
</ul>
<h2 id="6-10-checkForPattern"><a href="#6-10-checkForPattern" class="headerlink" title="6.10 checkForPattern"></a>6.10 checkForPattern</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker_linux.go:82</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// checkForPattern returns (true, nil) if logPattern occurs less than logCountThreshold number of times since last</span><br><span class="line">// service restart. (false, nil) otherwise.</span><br><span class="line">func checkForPattern(service, logStartTime, logPattern string, logCountThreshold int) (bool, error) &#123;</span><br><span class="line">        out, err := execCommand(types.CmdTimeout, &quot;/bin/sh&quot;, &quot;-c&quot;,</span><br><span class="line">                // Query service logs since the logStartTime</span><br><span class="line">                `journalctl --unit &quot;`+service+`&quot; --since &quot;`+logStartTime+</span><br><span class="line">                        // Grep the pattern</span><br><span class="line">                        `&quot; | grep -i &quot;`+logPattern+</span><br><span class="line">                        // Get the count of occurrences</span><br><span class="line">                        `&quot; | wc -l`)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return true, err</span><br><span class="line">        &#125;</span><br><span class="line">        occurrences, err := strconv.Atoi(out)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return true, err</span><br><span class="line">        &#125;</span><br><span class="line">        if occurrences &gt;= logCountThreshold &#123;</span><br><span class="line">                klog.Infof(&quot;%s failed log pattern check, %s occurrences: %v&quot;, service, logPattern, occurrences)</span><br><span class="line">                return false, nil</span><br><span class="line">        &#125;</span><br><span class="line">        return true, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查指定服务的日志中是否包含特定模式，并返回其出现次数是否达到阈值。</p>
<p>参数：</p>
<ul>
<li>service：被监控服务的名称。</li>
<li>logStartTime：起始时间，用于过滤日志。</li>
<li>logPattern：需要检查的日志模式。</li>
<li>logCountThreshold：模式出现的最大次数阈值。</li>
<li>返回值：返回一个布尔值，指示是否健康，以及可能的错误。</li>
</ul>
<p>实现细节</p>
<ul>
<li>使用 journalctl 命令获取从指定时间开始的服务日志，并通过 grep 过滤符合条件的日志模式。</li>
<li>使用 wc -l 计算匹配的行数。</li>
<li>如果日志模式出现的次数大于阈值，记录相关信息并返回健康检查失败的结果。</li>
</ul>
<h1 id="7-logcounter"><a href="#7-logcounter" class="headerlink" title="7 logcounter"></a>7 logcounter</h1><h2 id="7-1-logCounter定义"><a href="#7-1-logCounter定义" class="headerlink" title="7.1 logCounter定义"></a>7.1 logCounter定义</h2><p>pkg&#x2F;logcounter&#x2F;log_counter.go:42</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type logCounter struct &#123;</span><br><span class="line">        logCh         &lt;-chan *systemtypes.Log</span><br><span class="line">        buffer        systemlogmonitor.LogBuffer</span><br><span class="line">        pattern       string</span><br><span class="line">        revertPattern string</span><br><span class="line">        clock         clock.Clock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字段解释：</p>
<ul>
<li>logCh：只读通道，用于接收系统日志。</li>
<li>buffer：存储日志的缓冲区，以便分析和计数。</li>
<li>pattern：处理日志时使用的匹配模式。</li>
<li>revertPattern：可用来反向计数的模式。</li>
<li>clock：用于获取当前时间的时钟，支持模拟时钟功能。</li>
</ul>
<h2 id="7-2-NewJournaldLogCounter"><a href="#7-2-NewJournaldLogCounter" class="headerlink" title="7.2 NewJournaldLogCounter"></a>7.2 NewJournaldLogCounter</h2><p>pkg&#x2F;logcounter&#x2F;log_counter.go:50</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func NewJournaldLogCounter(options *options.LogCounterOptions) (types.LogCounter, error) &#123;</span><br><span class="line">        watcher := journald.NewJournaldWatcher(watchertypes.WatcherConfig&#123;</span><br><span class="line">                Plugin:       &quot;journald&quot;,</span><br><span class="line">                PluginConfig: map[string]string&#123;journaldSourceKey: options.JournaldSource&#125;,</span><br><span class="line">                LogPath:      options.LogPath,</span><br><span class="line">                Lookback:     options.Lookback,</span><br><span class="line">                Delay:        options.Delay,</span><br><span class="line">        &#125;)</span><br><span class="line">        logCh, err := watcher.Watch()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return nil, fmt.Errorf(&quot;error watching journald: %v&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">        return &amp;logCounter&#123;</span><br><span class="line">                logCh:         logCh,</span><br><span class="line">                buffer:        systemlogmonitor.NewLogBuffer(bufferSize),</span><br><span class="line">                pattern:       options.Pattern,</span><br><span class="line">                revertPattern: options.RevertPattern,</span><br><span class="line">                clock:         clock.RealClock&#123;&#125;,</span><br><span class="line">        &#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化并返回一个新的 logCounter 实例。</p>
<p>参数：</p>
<ul>
<li>options *options.LogCounterOptions - 包含配置信息（例如日志源、路径、模式等）。</li>
<li>返回值：返回一个实现了 types.LogCounter 接口的 logCounter 实例。</li>
</ul>
<p>实现细节</p>
<ul>
<li>创建一个 journald 日志观察者实例来监控指定的日志路径。</li>
<li>如果监视操作成功，建立日志通道并创建 logCounter 的实例，设置缓冲区、匹配模式等。</li>
</ul>
<h2 id="7-3-Count"><a href="#7-3-Count" class="headerlink" title="7.3 Count"></a>7.3 Count</h2><p>pkg&#x2F;logcounter&#x2F;log_counter.go:71</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func (e *logCounter) Count() (count int, err error) &#123;</span><br><span class="line">        start := e.clock.Now()</span><br><span class="line">        for &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case log, ok := &lt;-e.logCh:</span><br><span class="line">                        if !ok &#123;</span><br><span class="line">                                err = fmt.Errorf(&quot;log channel closed unexpectedly&quot;)</span><br><span class="line">                                return</span><br><span class="line">                        &#125;</span><br><span class="line">                        if start.Before(log.Timestamp) &#123;</span><br><span class="line">                                return</span><br><span class="line">                        &#125;</span><br><span class="line">                        e.buffer.Push(log)</span><br><span class="line">                        if len(e.buffer.Match(e.pattern)) != 0 &#123;</span><br><span class="line">                                count++</span><br><span class="line">                        &#125;</span><br><span class="line">                        if e.revertPattern != &quot;&quot; &amp;&amp; len(e.buffer.Match(e.revertPattern)) != 0 &#123;</span><br><span class="line">                                count--</span><br><span class="line">                        &#125;</span><br><span class="line">                case &lt;-e.clock.After(timeout):</span><br><span class="line">                        return</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计在运行期间匹配的日志条目数量。</p>
<p>返回值：返回符合条件的日志计数及任何潜在的错误。</p>
<p>实现细节</p>
<ul>
<li>使用当前时间 (start) 记录开始时刻。</li>
<li>在无限循环中，使用 select 语句监听日志通道和超时事件。</li>
<li>如果从 logCh 读取到日志：<ul>
<li>检查通道是否已经关闭。</li>
<li>如果读取到的日志时间戳晚于开始时间，则停止计数。</li>
<li>将日志条目压入缓冲区。</li>
<li>检查当前日志是否与模式匹配，如果匹配则计数加一；如果匹配反向模式，则计数减一。</li>
<li>如果在超时时间内没有收到新日志，结束循环并返回计数。</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>仓库fork后同步</title>
    <url>/2025/07/devops/environment/%E4%BB%93%E5%BA%93fork%E5%90%8E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="fork仓库"><a href="#fork仓库" class="headerlink" title="fork仓库"></a>fork仓库</h1><p><img src="/img_4.png" alt="img_4.png"><br><img src="/img_5.png" alt="img_5.png"></p>
<p>此时会将该仓库在复制一份，并存放在你的路径下：<br><img src="/img_6.png" alt="img_6.png"></p>
<h1 id="设置上游代码库"><a href="#设置上游代码库" class="headerlink" title="设置上游代码库"></a>设置上游代码库</h1><p>进入本地代码库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从自己仓库进行<span class="built_in">clone</span>(fork)</span></span><br><span class="line">git clone https://github.com/qiqiuyang/bk-ci.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入目录</span></span><br><span class="line">cd bk-ci/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录结构</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">CHANGELOG              CONTRIBUTING.md  README_EN.md  support-files</span><br><span class="line">CODE_OF_CONDUCT.en.md  docker-images    README.md     THIRD-PARTY-NOTICES.txt</span><br><span class="line">CODE_OF_CONDUCT.md     docs             scripts</span><br><span class="line">CODEOWNERS             helm-charts      SECURITY.md</span><br><span class="line">CONTRIBUTING.en.md     LICENSE.txt      src</span><br></pre></td></tr></table></figure>

<p>查看远程仓库的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin        https://github.com/qiqiuyang/bk-ci.git (fetch)</span><br><span class="line">origin        https://github.com/qiqiuyang/bk-ci.git (push)</span><br></pre></td></tr></table></figure>

<p>这里可以发现从自己仓库clone下来后，fetch和push的路径都是自己的。</p>
<p>设置上游代码库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add upstream git@github.com:TencentBlueKing/bk-ci.git</span></span><br></pre></td></tr></table></figure>

<p>再次查看远程仓库地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin        https://github.com/qiqiuyang/bk-ci.git (fetch)</span><br><span class="line">origin        https://github.com/qiqiuyang/bk-ci.git (push)</span><br><span class="line">upstream        git@github.com:TencentBlueKing/bk-ci.git (fetch)</span><br><span class="line">upstream        git@github.com:TencentBlueKing/bk-ci.git (push)</span><br></pre></td></tr></table></figure>

<h1 id="同步源仓库的更新"><a href="#同步源仓库的更新" class="headerlink" title="同步源仓库的更新"></a>同步源仓库的更新</h1><p>使用下面的命令拉取源仓库的更新：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch upstream</span></span><br><span class="line">remote: Enumerating objects: 17643, done.</span><br><span class="line">remote: Counting objects: 100% (13492/13492), done.</span><br><span class="line">remote: Compressing objects: 100% (3960/3960), done.</span><br><span class="line">remote: Total 10070 (delta 4278), reused 8600 (delta 3184), pack-reused 0 (from 0)</span><br><span class="line">接收对象中: 100% (10070/10070), 2.44 MiB | 2.05 MiB/s, 完成.</span><br><span class="line">处理 delta 中: 100% (4278/4278), 完成 657 个本地对象.</span><br><span class="line">来自 github.com:TencentBlueKing/bk-ci</span><br><span class="line"> * [新分支]                master          -&gt; upstream/master</span><br><span class="line"> * [新分支]                release-1.11    -&gt; upstream/release-1.11</span><br><span class="line"> * [新分支]                release-1.14    -&gt; upstream/release-1.14</span><br><span class="line"> * [新分支]                release-1.2     -&gt; upstream/release-1.2</span><br><span class="line"> * [新分支]                release-1.3     -&gt; upstream/release-1.3</span><br><span class="line">。。。</span><br><span class="line">。。。</span><br><span class="line"> * [新标签]                v1.8.4          -&gt; v1.8.4</span><br><span class="line"> * [新标签]                v1.8.5          -&gt; v1.8.5</span><br></pre></td></tr></table></figure>

<p>到这里就比较清晰了，在更新时就是把源仓库的更新的分支放在upstream下，例如：upstream&#x2F;master</p>
<p>所以同步远端分支时，就是git fetch upstream，然后将自己的分支merge目标分支内容，例如：git merge upstream&#x2F;master</p>
<p>如此便可以实现自己的fork仓库同步源仓库的新变更了。</p>
<h1 id="向原仓库发起PR"><a href="#向原仓库发起PR" class="headerlink" title="向原仓库发起PR"></a>向原仓库发起PR</h1><p>首先在自己的仓库点击Pull Request-&gt;New Pull Request，进入以下截图页面<br><img src="/img_7.png" alt="img_7.png"></p>
<p>base repository为原仓库的某个分支，head repository为fork仓库发某个分支, head的某个分支代码合到base的某个分支<br><img src="/img_8.png" alt="img_8.png"></p>
<p>进入原仓库的Pull requests可看到刚才发起的PR， 这里就不演示了</p>
]]></content>
  </entry>
  <entry>
    <title>BK-CI插件开发指引</title>
    <url>/2025/07/devops/blueking/BK-CI%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8C%87%E5%BC%95/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>开发插件前，先进入插件工作台初始化一个插件，确定插件在平台中的唯一标识</p>
</blockquote>
<h1 id="工作台"><a href="#工作台" class="headerlink" title="工作台"></a>工作台</h1><p>可以在这里进行新增&#x2F;发布&#x2F;下架等管理插件的操作</p>
<h2 id="功能区介绍"><a href="#功能区介绍" class="headerlink" title="功能区介绍"></a>功能区介绍</h2><p><img src="/img.png" alt="img.png"></p>
<ol>
<li>切换资源类型</li>
<li>新增插件</li>
<li>单个插件的管理入口</li>
<li>升级、下架、删除插件快捷入口</li>
<li>指引文档和插件 UI 调试工具入口</li>
</ol>
<h2 id="新增插件"><a href="#新增插件" class="headerlink" title="新增插件"></a>新增插件</h2><p><img src="/img_1.png" alt="img_1.png"></p>
<ol>
<li>标识</li>
</ol>
<ul>
<li>插件在平台中的唯一标识，建议取和插件功能相关的可读性好的英文标识</li>
</ul>
<ol start="2">
<li>调试项目</li>
</ol>
<ul>
<li>插件发布过程中，可以在调试项目下将插件添加到流水线执行，对插件进行测试，保证插件功能满足预期。</li>
<li>建议新增专用的插件调试项目，避免测试过程中影响到业务。</li>
</ul>
<ol start="3">
<li>开发语言</li>
</ol>
<ul>
<li>支持四种语言开发插件：<ul>
<li>Java（推荐）</li>
<li>Python</li>
<li>Golang</li>
<li>Nodejs</li>
</ul>
</li>
</ul>
<h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h2><blockquote>
<p>初始化好插件之后，可以开始开发插件</p>
</blockquote>
<ul>
<li>根据开发语言参考对应的开发指引<ul>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/java.md">Java 插件开发指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/python.md">Python 插件开发指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/golang.md">Golang 插件开发指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/nodejs.md">Nodejs 插件开发指引</a></li>
</ul>
</li>
</ul>
<h2 id="插件私有配置"><a href="#插件私有配置" class="headerlink" title="插件私有配置"></a>插件私有配置</h2><blockquote>
<p>插件级别的敏感信息，如 token、用户名密码、IP、域名等，不建议直接提交到代码库，通过工作台私有配置界面管理</p>
</blockquote>
<p><img src="/img_2.png" alt="img_2.png"></p>
<h1 id="Golang-插件开发"><a href="#Golang-插件开发" class="headerlink" title="Golang 插件开发"></a>Golang 插件开发</h1><h2 id="插件开发框架说明"><a href="#插件开发框架说明" class="headerlink" title="插件开发框架说明"></a>插件开发框架说明</h2><blockquote>
<p>插件最终打包成一个命令行可执行的命令即可，对开发框架无硬性要求 下边以 demo 插件为例示范</p>
</blockquote>
<h2 id="示例插件代码工程的整体结构如下"><a href="#示例插件代码工程的整体结构如下" class="headerlink" title="示例插件代码工程的整体结构如下"></a>示例插件代码工程的整体结构如下</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|- &lt;你的插件标识&gt;</span><br><span class="line">    |- cmd</span><br><span class="line">        |- application</span><br><span class="line">            |- main.go</span><br><span class="line"></span><br><span class="line">    |- hello</span><br><span class="line">        |- hello.go</span><br></pre></td></tr></table></figure>

<h2 id="如何开发插件："><a href="#如何开发插件：" class="headerlink" title="如何开发插件："></a>如何开发插件：</h2><blockquote>
<p>参考 <a href="https://github.com/ci-plugins/plugin-demo-golang">plugin-demo-golang</a></p>
</blockquote>
<ul>
<li>建插件代码工程<ul>
<li>插件代码建议企业下统一管理。 通用的开源插件可以联系蓝鲸官方放到 <a href="https://github.com/TencentBlueKing">TencentBlueKing</a> 下，供更多用户使用</li>
</ul>
</li>
<li>实现插件功能</li>
<li>规范：<ul>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-specification.md">插件开发规范</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-config.md">插件配置规范</a></li>
</ul>
</li>
<li>插件前端不仅可以通过 task.json 进行标准化配置，也可以自定义开发：<ul>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-custom-ui.md">自定义插件 UI 交互指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-output.md">插件输出规范</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-error-code.md">插件错误码规范</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/release.md">插件发布包规范</a></li>
</ul>
</li>
</ul>
<h2 id="Demo示例研读"><a href="#Demo示例研读" class="headerlink" title="Demo示例研读"></a>Demo示例研读</h2><p>将 <a href="https://github.com/ci-plugins/plugin-demo-golang">plugin-demo-golang</a> clone到本地。<br>来看下项目结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── i18n</span><br><span class="line">│   ├── message_en_US.properties</span><br><span class="line">│   └── message_zh_CN.properties</span><br><span class="line">├── main.go</span><br><span class="line">├── task.json</span><br><span class="line">└── translation</span><br><span class="line">    └── translation.go</span><br><span class="line"></span><br><span class="line">3 directories, 11 files</span><br></pre></td></tr></table></figure>

<p>咦！和上面说的插件代码工程的整体架构不一样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|- &lt;你的插件标识&gt;</span><br><span class="line">    |- cmd</span><br><span class="line">        |- application</span><br><span class="line">            |- main.go</span><br><span class="line"></span><br><span class="line">    |- hello</span><br><span class="line">        |- hello.go</span><br></pre></td></tr></table></figure>

<p>不过，这不重要，只要插件最终能够打包成一个命令行可执行的命令即可。<br>这里i18n是实现中英文国际化使用的，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── i18n</span><br><span class="line">│   ├── message_en_US.properties</span><br><span class="line">│   └── message_zh_CN.properties</span><br></pre></td></tr></table></figure>

<p>看下内容对比：<br>message_en_US.properties：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input.desc.label=desc</span><br><span class="line">100001=input param [&#123;0&#125;] invitated</span><br></pre></td></tr></table></figure>

<p>message_zh_CN.properties</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input.desc.label=描述</span><br><span class="line">100001=输入参数[&#123;0&#125;]非法</span><br></pre></td></tr></table></figure>

<p>那我们就可以猜测，这里是实现输入参数[{0}]非法这句话的中英文，其中[{0}]会使用具体的参数填充。<br>然后i18ngenerator则是根据properties文件的配置，生成translation代码，如translation.go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code generated by &quot;i18ngenerator&quot;; DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> translation</span><br><span class="line"></span><br><span class="line"><span class="comment">// Translations</span></span><br><span class="line"><span class="keyword">var</span> Translations <span class="keyword">map</span>[<span class="type">string</span>][][]<span class="type">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][][]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Translations[<span class="string">&quot;en-US&quot;</span>] = [][]<span class="type">string</span>&#123;</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;100001&quot;</span>,</span><br><span class="line">          <span class="string">&quot;input param [&#123;0&#125;] invitated&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;input.desc.label&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    Translations[<span class="string">&quot;zh-CN&quot;</span>] = [][]<span class="type">string</span>&#123;</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;100001&quot;</span>,</span><br><span class="line">          <span class="string">&quot;输入参数[&#123;0&#125;]非法&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;input.desc.label&quot;</span>,</span><br><span class="line">          <span class="string">&quot;描述&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该文件是由i18ngenerator自动生成的，不要自己改。<br>main函数内，实现了一个小的输出功能，简单看下源码，然后去进行测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/ci-plugins/golang-plugin-sdk/api&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ci-plugins/golang-plugin-sdk/log&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ci-plugins/plugin-demo-golang/translation&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate i18ngenerator i18n ./translation/translation.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> greetingParam <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserName <span class="type">string</span> <span class="string">`json:&quot;userName&quot;`</span></span><br><span class="line">    Greeting <span class="type">string</span> <span class="string">`json:&quot;greeting&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *greetingParam)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;userName: %v, greeting: %v&quot;</span>, a.UserName, a.Greeting)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">4</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;atom-demo-glang starts&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Error(<span class="string">&quot;panic: &quot;</span>, err)</span><br><span class="line">          api.FinishBuild(api.StatusError, <span class="string">&quot;panic occurs&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    api.InitI18n(translation.Translations, api.GetRuntimeLanguage())</span><br><span class="line">    msg, err := api.Localize(<span class="string">&quot;input.desc.label&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.Error(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Info(msg)</span><br><span class="line"></span><br><span class="line">    helloBuild()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloBuild</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取单个输入参数</span></span><br><span class="line">    userName := api.GetInputParam(<span class="string">&quot;userName&quot;</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;userName: &quot;</span>, userName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打屏</span></span><br><span class="line">    log.Info(<span class="string">&quot;\nBuildInfo:&quot;</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;Project Name:     &quot;</span>, api.GetProjectDisplayName())</span><br><span class="line">    log.Info(<span class="string">&quot;Pipeline Id:      &quot;</span>, api.GetPipelineId())</span><br><span class="line">    log.Info(<span class="string">&quot;Pipeline Name:    &quot;</span>, api.GetPipelineName())</span><br><span class="line">    log.Info(<span class="string">&quot;Pipeline Version: &quot;</span>, api.GetPipelineVersion())</span><br><span class="line">    log.Info(<span class="string">&quot;Build Id:         &quot;</span>, api.GetPipelineBuildId())</span><br><span class="line">    log.Info(<span class="string">&quot;Build Num:        &quot;</span>, api.GetPipelineBuildNumber())</span><br><span class="line">    log.Info(<span class="string">&quot;Start Type:       &quot;</span>, api.GetPipelineStartType())</span><br><span class="line">    log.Info(<span class="string">&quot;Start UserId:     &quot;</span>, api.GetPipelineStartUserId())</span><br><span class="line">    log.Info(<span class="string">&quot;Start UserName:   &quot;</span>, api.GetPipelineStartUserName())</span><br><span class="line">    log.Info(<span class="string">&quot;Start Time:       &quot;</span>, api.GetPipelineStartTimeMills())</span><br><span class="line">    log.Info(<span class="string">&quot;Workspace:        &quot;</span>, api.GetWorkspace())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入参数解析到对象</span></span><br><span class="line">    paramData := <span class="built_in">new</span>(greetingParam)</span><br><span class="line">    api.LoadInputParam(paramData)</span><br><span class="line">    log.Info(fmt.Sprintf(<span class="string">&quot;\n%v，%v\n&quot;</span>, paramData.Greeting, paramData.UserName))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    log.Info(<span class="string">&quot;start build&quot;</span>)</span><br><span class="line">    build()</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 字符串输出</span></span><br><span class="line">    strData := api.NewStringData(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    api.AddOutputData(<span class="string">&quot;strData_01&quot;</span>, strData)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件归档输出</span></span><br><span class="line">    artifactData := api.NewArtifactData()</span><br><span class="line">    artifactData.AddArtifact(<span class="string">&quot;result.dat&quot;</span>)</span><br><span class="line">    api.AddOutputData(<span class="string">&quot;artifactData_02&quot;</span>, artifactData)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报告输出</span></span><br><span class="line">    reportData := api.NewReportData(<span class="string">&quot;label_01&quot;</span>, api.GetWorkspace()+<span class="string">&quot;/report&quot;</span>, <span class="string">&quot;report.htm&quot;</span>)</span><br><span class="line">    api.AddOutputData(<span class="string">&quot;report_01&quot;</span>, reportData)</span><br><span class="line"></span><br><span class="line">    api.WriteOutput()</span><br><span class="line">    log.Info(<span class="string">&quot;build done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Info(<span class="string">&quot;write result.dat&quot;</span>)</span><br><span class="line">    ioutil.WriteFile(api.GetWorkspace()+<span class="string">&quot;/result.dat&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;content&quot;</span>), <span class="number">0644</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;write report.htm&quot;</span>)</span><br><span class="line">    os.Mkdir(api.GetWorkspace()+<span class="string">&quot;/report&quot;</span>, os.ModePerm)</span><br><span class="line">    ioutil.WriteFile(api.GetWorkspace()+<span class="string">&quot;/report/report.htm&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Report&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;This is a Report&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>), <span class="number">0644</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在根目录下已经给我们预设了一个task.json文件，后面可以简单修改下这个文件来实现测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;atomCode&quot;</span>: <span class="string">&quot;goDemo&quot;</span>,</span><br><span class="line">  <span class="string">&quot;execution&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;language&quot;</span>: <span class="string">&quot;golang&quot;</span>,</span><br><span class="line">    <span class="string">&quot;packagePath&quot;</span>: <span class="string">&quot;goDemo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;demands&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;chmod +x goDemo&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;./goDemo&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;input&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;greeting&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;label&quot;</span>: <span class="string">&quot;欢迎词&quot;</span>,</span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;Glad to see you&quot;</span>,</span><br><span class="line">      <span class="string">&quot;placeholder&quot;</span>: <span class="string">&quot;欢迎词&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;vuex-input&quot;</span>,</span><br><span class="line">      <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;欢迎词&quot;</span>,</span><br><span class="line">      <span class="string">&quot;required&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;disabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;isSensitive&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;userName&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;label&quot;</span>: <span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;Mr. Huang&quot;</span>,</span><br><span class="line">      <span class="string">&quot;placeholder&quot;</span>: <span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;vuex-input&quot;</span>,</span><br><span class="line">      <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">      <span class="string">&quot;required&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;disabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;isSensitive&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;output&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;strData_01&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;测试&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="string">&quot;isSensitive&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何打包发布"><a href="#如何打包发布" class="headerlink" title="如何打包发布"></a>如何打包发布</h2><ol>
<li>进入插件代码工程目录下</li>
<li>打包</li>
</ol>
<ul>
<li>如果按照正常的demo的目录结构是需要进入cmd&#x2F;application内执行build命令，因为main在此</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd cmd/application</span><br><span class="line">GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/$&#123;executable&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这次用的demo则直接在根目录下执行build命令，因为main在根目录下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/$&#123;executable&#125;</span><br></pre></td></tr></table></figure>

<p>这里go build -o bin&#x2F;${executable}会在bin目录下，生成可执行文件，文件名是${executable}，即项目名。<br>也可以自定义一个名字，如<code>GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/kingtest</code></p>
<ol>
<li>在任意位置新建文件夹，命名示例：release_pkg &#x3D; &lt;你的插件标识&gt;_release</li>
<li>将步骤 2 生产的执行包拷贝到 下</li>
<li>添加 task.json 文件到 下 task.json 见示例，按照插件功能配置。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir kingtest_release</span><br><span class="line">cp bin/kingtest kingtest_release/kingtest</span><br><span class="line">touch kingtest_release/task.json</span><br></pre></td></tr></table></figure>

<ul>
<li>插件配置规范</li>
<li>task.json 示例：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;atomCode&quot;: &quot;king-test&quot;,                  # atomCode 要与工作台录入的一致</span><br><span class="line">  &quot;execution&quot;: &#123;</span><br><span class="line">    &quot;language&quot;: &quot;golang&quot;,</span><br><span class="line">    &quot;packagePath&quot;: &quot;kingtest&quot;,              # 发布包中插件安装包的相对路径</span><br><span class="line">    &quot;demands&quot;: [</span><br><span class="line">      &quot;echo start run chmod +x kingtest&quot;,   # 插件启动前需要执行的安装命令，顺序执行</span><br><span class="line">      &quot;chmod +x kingtest&quot;,                  # 插件启动前需要执行的安装命令，顺序执行</span><br><span class="line">      &quot;echo stop run chmod +x kingtest&quot;,    # 插件启动前需要执行的安装命令，顺序执行</span><br><span class="line">    ],</span><br><span class="line">    &quot;target&quot;: &quot;./kingtest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;input&quot;: &#123;</span><br><span class="line">    &quot;greeting&quot;: &#123;</span><br><span class="line">      &quot;label&quot;: &quot;欢迎词&quot;,</span><br><span class="line">      &quot;default&quot;: &quot;Glad to see you&quot;,</span><br><span class="line">      &quot;placeholder&quot;: &quot;欢迎词&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;vuex-input&quot;,</span><br><span class="line">      &quot;desc&quot;: &quot;欢迎词&quot;,</span><br><span class="line">      &quot;required&quot;: true,</span><br><span class="line">      &quot;disabled&quot;: false,</span><br><span class="line">      &quot;hidden&quot;: false,</span><br><span class="line">      &quot;isSensitive&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;userName&quot;: &#123;</span><br><span class="line">      &quot;label&quot;: &quot;姓名&quot;,</span><br><span class="line">      &quot;default&quot;: &quot;Mr. Huang&quot;,</span><br><span class="line">      &quot;placeholder&quot;: &quot;姓名&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;vuex-input&quot;,</span><br><span class="line">      &quot;desc&quot;: &quot;姓名&quot;,</span><br><span class="line">      &quot;required&quot;: true,</span><br><span class="line">      &quot;disabled&quot;: false,</span><br><span class="line">      &quot;hidden&quot;: false,</span><br><span class="line">      &quot;isSensitive&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;output&quot;: &#123;</span><br><span class="line">    &quot;strData_01&quot;: &#123;</span><br><span class="line">      &quot;description&quot;: &quot;测试&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">      &quot;isSensitive&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 目录下，把所有文件打成 zip 包即可</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd kingtest_release &amp;&amp; zip kingtest_release.zip kingtest task.json</span><br></pre></td></tr></table></figure>

<p>zip包结构示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|- kingtest_release.zip         # 发布包</span><br><span class="line">   |- kingtest                  # 插件执行包</span><br><span class="line">   |- task.json                 # 插件配置文件</span><br></pre></td></tr></table></figure>

<p>打包完成后，在插件工作台提单发布，即可测试或发布插件</p>
<h1 id="上传一个流水线插件"><a href="#上传一个流水线插件" class="headerlink" title="上传一个流水线插件"></a>上传一个流水线插件</h1><blockquote>
<p>开发好插件之后，通过研发商店工作台，将插件发布到研发商店，提供给用户添加到流水线中使用。</p>
</blockquote>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>在工作台列表，点击如下入口发起发布流程：<br><img src="/img_3.png" alt="img_3.png"></p>
<p>首次发布时，入口名为上架<br>后续更新版本时，入口名为升级<br>或者在插件发布管理-&gt;版本管理界面发起发布流程：<br><img src="/img_4.png" alt="img_4.png"></p>
<h2 id="填写插件相关信息-上传插件发布包"><a href="#填写插件相关信息-上传插件发布包" class="headerlink" title="填写插件相关信息&#x2F;上传插件发布包"></a>填写插件相关信息&#x2F;上传插件发布包</h2><p>上架&#x2F;升级插件时，可以修改插件的基本信息，如下所示：<br><img src="/img_5.png" alt="img_5.png"></p>
<ol>
<li>适用 Job 类型：</li>
</ol>
<ul>
<li>和流水线 Job 类型对应，请按照插件实际适用情况选择</li>
<li>若选错，需新增版本修改</li>
</ul>
<ol start="2">
<li>发布包：</li>
</ol>
<ul>
<li>task.json 中的 atomCode 需和 新增插件时填写的标识一致，否则上传会失败</li>
</ul>
<h2 id="测试-发布插件"><a href="#测试-发布插件" class="headerlink" title="测试&#x2F;发布插件"></a>测试&#x2F;发布插件</h2><blockquote>
<p>填写好信息，提交后，进入发布流程，可以测试-&gt;重新传包-&gt;测试，直至插件满足预期后，手动继续流程将插件发布到研发商店</p>
</blockquote>
<p><img src="/img_6.png" alt="img_6.png"></p>
<ol>
<li>测试：点击后跳转到插件调试项目的流水线服务下，可以将当前插件添加到流水线，验证 UI、功能是否满足预期</li>
<li>重新传包：当测试发现问题，修复后，重新上传发布包，再次进行测试</li>
<li>继续：测试 OK，满足预期后，确认提交发布</li>
<li>取消发布：发布过程中，随时可以终止发布</li>
</ol>
<h2 id="遇见的几个错误"><a href="#遇见的几个错误" class="headerlink" title="遇见的几个错误"></a>遇见的几个错误</h2><h3 id="无权限执行"><a href="#无权限执行" class="headerlink" title="无权限执行"></a>无权限执行</h3><p>在测试中遇见一个问题：无权限执行<br><img src="/img_7.png" alt="img_7.png"></p>
<p>在<code>execution-&gt;demands</code>增加一个命令<code>chmod +x kingtest</code>即可解决</p>
<h3 id="发布进度里重新传包持续报错task-json格式错误"><a href="#发布进度里重新传包持续报错task-json格式错误" class="headerlink" title="发布进度里重新传包持续报错task.json格式错误"></a>发布进度里重新传包持续报错task.json格式错误</h3><p>还有个问题，在发布进度里重新传包时，一直报错task.json格式错误，但实际格式是对的！<br>触发的原因暂不知道，但是确实是一个隐藏的bug。<br><img src="/img_8.png" alt="img_8.png"></p>
<p>直接点击继续，然后走升级插件的方式可以正常使用。</p>
<h3 id="cannot-execute-binary-file-Exec-format-error"><a href="#cannot-execute-binary-file-Exec-format-error" class="headerlink" title="cannot execute binary file: Exec format error"></a>cannot execute binary file: Exec format error</h3><p>这里的问题是我造成的，最初我在mac环境下编译的可执行文件，命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mac下执行</span></span><br><span class="line">go build -o bin/kingtest</span><br></pre></td></tr></table></figure>

<p>但是插件里选择的编译环境是linux。<br><img src="/img_9.png" alt="img_9.png"></p>
<p>解决方式：让插件选择的编译环境和可执行文件的平台统一。<br>我这里选择重新编译下可执行文件，采用在mac平台交叉编译linux平台可执行文件的方式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/kingtest</span><br></pre></td></tr></table></figure>

<p>也可以新建一个插件，编译环境选择mac。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>流水线结果：<br><img src="/img_10.png" alt="img_10.png"></p>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Plugin info]</span><br><span class="line">=====================================================================</span><br><span class="line">Task           : king-test</span><br><span class="line">Description    : bk插件测试</span><br><span class="line">Version        : 1.0.3</span><br><span class="line">Author         : huari</span><br><span class="line">Help           : More Information</span><br><span class="line">=====================================================================</span><br><span class="line">-----</span><br><span class="line">[Input]</span><br><span class="line">input(normal): (欢迎词)greeting=Glad to see you</span><br><span class="line">input(normal): (姓名)userName=Mr. Huang</span><br><span class="line">-----</span><br><span class="line">[Install plugin]</span><br><span class="line">-----</span><br><span class="line">start run chmod +x kingtest</span><br><span class="line">stop run chmod +x kingtest</span><br><span class="line">atom-demo-glang starts</span><br><span class="line">描述</span><br><span class="line">userName:  Mr. Huang</span><br><span class="line"></span><br><span class="line">BuildInfo:</span><br><span class="line">Project Name:      GOPS</span><br><span class="line">Pipeline Id:       p-8967ed52b08847c8a5b0140937db0975</span><br><span class="line">Pipeline Name:     king-test</span><br><span class="line">Pipeline Version:  11</span><br><span class="line">Build Id:          b-78947b5c39f34b32bbafb803042d1e22</span><br><span class="line">Build Num:         15</span><br><span class="line">Start Type:        MANUAL</span><br><span class="line">Start UserId:      huari</span><br><span class="line">Start UserName:    huari</span><br><span class="line">Start Time:        1733298107286</span><br><span class="line">Workspace:         /data/devops/workspace</span><br><span class="line"></span><br><span class="line">Glad to see you，Mr. Huang</span><br><span class="line">start build</span><br><span class="line">write result.dat</span><br><span class="line">write report.htm</span><br><span class="line">build done</span><br><span class="line">[Output]</span><br><span class="line">1 file match: </span><br><span class="line">  /data/devops/workspace/result.dat</span><br><span class="line">prepare to upload 7 B</span><br><span class="line">1/1 file(s) finished</span><br><span class="line">output(except): artifactData_02=result.dat</span><br><span class="line">入口文件检测完成</span><br><span class="line">上传自定义产出物成功，共产生了1个文件</span><br><span class="line">output(except): report_01=report.htm</span><br><span class="line">output(normal): strData_01=test</span><br><span class="line">-----</span><br><span class="line"></span><br></pre></td></tr></table></figure>






]]></content>
  </entry>
  <entry>
    <title>Kind搭建测试集群</title>
    <url>/2025/07/kubernetes/Kind%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
