<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2025/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Kind搭建测试集群</title>
    <url>/2025/07/kubernetes/Kind%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="Kind工具介绍"><a href="#Kind工具介绍" class="headerlink" title="Kind工具介绍"></a>Kind工具介绍</h1>]]></content>
  </entry>
  <entry>
    <title>kubectl常用命令</title>
    <url>/2025/07/kubernetes/kubectl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="登录命令"><a href="#登录命令" class="headerlink" title="登录命令"></a>登录命令</h1><p>根据机器ip使用kubectl登录机器(field-selector):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export targetIp=&quot;6.0.90.240&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">alias</span> kubectl=<span class="string">&#x27;kubectl&#x27;</span></span></span><br><span class="line">alias kubectl=&#x27;kubectl --kubeconfig=/Users/king/.kube/sa128.config&#x27;</span><br><span class="line"></span><br><span class="line">podinfo=`kubectl get pod --all-namespaces --field-selector=status.podIP=&quot;$targetIp&quot; -o wide | grep -v NAME | head -n 1 `</span><br><span class="line">ns=`echo $&#123;podinfo&#125; | awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">pod=`echo $&#123;podinfo&#125; | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">echo &quot;$kubectl exec -it -n $&#123;ns&#125; $&#123;pod&#125; -- su - root&quot;</span><br><span class="line">kubectl exec -it -n $&#123;ns&#125; $&#123;pod&#125; -- su - root</span><br></pre></td></tr></table></figure>

<p>根据机器ip使用kubectl登录机器(label):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export targetIp=&quot;6.3.144.241&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">alias</span> kubectl=<span class="string">&#x27;kubectl&#x27;</span></span></span><br><span class="line">alias kubectl=&#x27;kubectl --kubeconfig=/Users/king/.kube/sa128.config&#x27;</span><br><span class="line"></span><br><span class="line">podinfo=`kubectl get pod --all-namespaces -l sigma.ali/ip=&quot;$targetIp&quot; -o wide | grep -v NAMESPACE`</span><br><span class="line">ns=`echo $&#123;podinfo&#125; | awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">pod=`echo $&#123;podinfo&#125; | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">echo &quot;$kubectl exec -it -n $&#123;ns&#125; $&#123;pod&#125; -- su - root&quot;</span><br><span class="line">kubectl exec -it -n $&#123;ns&#125; $&#123;pod&#125; -- su - root</span><br></pre></td></tr></table></figure>

<p>更智能版本的kubectl登录命令：</p>
<ul>
<li>查看KUBECONFIG_DIR目录下有哪些kubeconfig可以用</li>
<li>校验目标登录的ip格式</li>
<li>查询并解析pod信息</li>
<li>查询该pod有哪些容器并展示</li>
<li>查询选定的容器有哪些用户(与user_array做交集)，支持自定义输入用户</li>
<li>根据以上信息登录目标ip对应pod的选定容器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加特定用户</span></span><br><span class="line">user_array=(&quot;root&quot; &quot;admin&quot; &quot;log&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从指定目录获取所有 kubeconfig 文件</span></span><br><span class="line">KUBECONFIG_DIR=&quot;/Users/king/.kube&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化 kubectl 命令前缀</span></span><br><span class="line">KUBECTL_CMD=&quot;kubectl&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保将信息打印到终端里，即使在函数之间$(...)调用的场景</span></span><br><span class="line">function print_to_console() &#123;</span><br><span class="line">    printf &quot;%s\n&quot; &quot;$1&quot; &gt;&amp;2</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查IP地址是否符合正确的格式</span></span><br><span class="line">function is_valid_ip() &#123;</span><br><span class="line">    local ip=$1</span><br><span class="line">    local valid_regex=&#x27;^([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;$&#x27;</span><br><span class="line"></span><br><span class="line">    if [[ $ip =~ $valid_regex ]]; then</span><br><span class="line">        # 确保每个数字部分小于等于255</span><br><span class="line">        IFS=&#x27;.&#x27; read -r -a octets &lt;&lt;&lt; &quot;$ip&quot;</span><br><span class="line">        for octet in &quot;$&#123;octets[@]&#125;&quot;; do</span><br><span class="line">            if ((octet &gt; 255)); then</span><br><span class="line">                return 1</span><br><span class="line">            fi</span><br><span class="line">        done</span><br><span class="line">        return 0</span><br><span class="line">    fi</span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KUBECONFIGS=($(find $KUBECONFIG_DIR -maxdepth 1 -name &quot;*.config&quot; -print))</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否找到 kubeconfig 文件</span></span><br><span class="line">if [ $&#123;#KUBECONFIGS[@]&#125; -eq 0 ]; then</span><br><span class="line">    print_to_console &quot;没有找到任何 kubeconfig 文件在目录: $KUBECONFIG_DIR&quot;</span><br><span class="line">else</span><br><span class="line">    # 提供给用户选择的菜单，动态生成选项范围提示</span><br><span class="line">    cat &lt;&lt; EOF</span><br><span class="line">    ----------------------------------------------</span><br><span class="line">    |*******Please Enter Your Choice:[1-$&#123;#KUBECONFIGS[@]&#125;]*******|</span><br><span class="line">    ----------------------------------------------</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    # 输出可供选择的配置文件选项</span><br><span class="line">    for i in &quot;$&#123;!KUBECONFIGS[@]&#125;&quot;; do</span><br><span class="line">        print_to_console &quot;*     $(($i + 1)) $&#123;KUBECONFIGS[$i]&#125;&quot;</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    # 捕获用户输入并确保在合法范围内</span><br><span class="line">    while true; do</span><br><span class="line">        read -p &quot;please input your choice [1-$&#123;#KUBECONFIGS[@]&#125;] (or press Enter to skip): &quot; num</span><br><span class="line">        if [[ -z &quot;$num&quot; ]]; then</span><br><span class="line">            break</span><br><span class="line">        elif [[ &quot;$num&quot; =~ ^[0-9]+$ ]] &amp;&amp; [ &quot;$num&quot; -ge 1 ] &amp;&amp; [ &quot;$num&quot; -le $&#123;#KUBECONFIGS[@]&#125; ]; then</span><br><span class="line">            selected_config=&quot;$&#123;KUBECONFIGS[$((num - 1))]&#125;&quot;</span><br><span class="line">            KUBECTL_CMD=&quot;kubectl --kubeconfig=$selected_config&quot;</span><br><span class="line">            print_to_console &quot;Using configuration file: $selected_config&quot;</span><br><span class="line">            break</span><br><span class="line">        else</span><br><span class="line">            print_to_console &quot;Invalid choice. Please try again.&quot;</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出用户选择的配置文件</span></span><br><span class="line">selected_config=&quot;$&#123;KUBECONFIGS[$((num - 1))]&#125;&quot;</span><br><span class="line">print_to_console &quot;You selected: $selected_config&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">捕获用户输入的targetIP</span></span><br><span class="line">while true; do</span><br><span class="line">    read -p &quot;please input your target ip: &quot; targetIP</span><br><span class="line"></span><br><span class="line">    # 检查输入是否为空和格式有效性</span><br><span class="line">    if [[ -z &quot;$targetIP&quot; ]]; then</span><br><span class="line">        print_to_console &quot;IP 地址不能为空，请重新输入。&quot;</span><br><span class="line">    elif ! is_valid_ip &quot;$targetIP&quot;; then</span><br><span class="line">        print_to_console &quot;无效的IP格式，请输入有效的IP地址。&quot;</span><br><span class="line">    else</span><br><span class="line">        print_to_console &quot;您输入的IP地址是: $targetIP&quot;</span><br><span class="line">        break</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 Pod 信息</span></span><br><span class="line">podinfo=$($KUBECTL_CMD get pod --all-namespaces --field-selector=status.podIP=&quot;$targetIP&quot; -o wide | grep -v NAME | head -n 1)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 podinfo 是否为空</span></span><br><span class="line">if [[ -z &quot;$podinfo&quot; ]]; then</span><br><span class="line">    print_to_console &quot;未能获取到对应 IP 的 Pod 信息，退出脚本。&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提取命名空间和 Pod 名称</span></span><br><span class="line">ns=$(echo &quot;$&#123;podinfo&#125;&quot; | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">pod=$(echo &quot;$&#123;podinfo&#125;&quot; | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 ns 和 pod 是否为空</span></span><br><span class="line">if [[ -z &quot;$ns&quot; || -z &quot;$pod&quot; ]]; then</span><br><span class="line">    print_to_console &quot;未能提取到命名空间或 Pod 名称，退出脚本。&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">print_to_console &quot;Namespace: $ns, Pod: $pod&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取容器列表</span></span><br><span class="line">containers=($($KUBECTL_CMD get pod $pod -n $ns -o jsonpath=&#x27;&#123;.spec.containers[*].name&#125;&#x27;))</span><br><span class="line">selected_container=&quot;&quot;</span><br><span class="line">if [ $&#123;#containers[@]&#125; -gt 0 ]; then</span><br><span class="line">    print_to_console &quot;请选择一个容器 (或直接按 Enter 跳过使用默认容器):&quot;</span><br><span class="line">    for i in &quot;$&#123;!containers[@]&#125;&quot;; do</span><br><span class="line">        print_to_console &quot;*      $(($i + 1)) $&#123;containers[$i]&#125;&quot;</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    while true; do</span><br><span class="line">        read -p &quot;please input your choice [1-$&#123;#containers[@]&#125;] (or press Enter to skip): &quot; container_num</span><br><span class="line">        if [[ -z &quot;$container_num&quot; ]]; then</span><br><span class="line">            break</span><br><span class="line">        elif [[ &quot;$container_num&quot; =~ ^[0-9]+$ ]] &amp;&amp; [ &quot;$container_num&quot; -ge 1 ] &amp;&amp; [ &quot;$container_num&quot; -le $&#123;#containers[@]&#125; ]; then</span><br><span class="line">            selected_container=&quot;$&#123;containers[$((container_num - 1))]&#125;&quot;</span><br><span class="line">            print_to_console &quot;Selected container: $selected_container&quot;</span><br><span class="line">            break</span><br><span class="line">        else</span><br><span class="line">            print_to_console &quot;Invalid choice. Please try again.&quot;</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解析容器中的用户并添加到用户数组中</span></span><br><span class="line">while IFS=: read -r username _ uid _; do</span><br><span class="line">    if [[ $uid -ge 1000 &amp;&amp; $username != &quot;nobody&quot; ]]; then</span><br><span class="line">        user_array+=(&quot;$username&quot;)</span><br><span class="line">    fi</span><br><span class="line">done &lt;&lt;&lt; &quot;$user_list&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示可供选择的用户列表</span></span><br><span class="line">print_to_console &quot;请选择一个用户 (或自定义输入):&quot;</span><br><span class="line">for i in &quot;$&#123;!user_array[@]&#125;&quot;; do</span><br><span class="line">    print_to_console &quot;*      $(($i + 1)) $&#123;user_array[$i]&#125;&quot;</span><br><span class="line">done</span><br><span class="line">print_to_console &quot;*      $(( $&#123;#user_array[@]&#125; + 1 )) 自定义输入 &quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">捕获用户选择的用户</span></span><br><span class="line">while true; do</span><br><span class="line">    read -p &quot;please input your choice [1-$(( $&#123;#user_array[@]&#125; + 1 ))]: &quot; user_num</span><br><span class="line">    if [[ &quot;$user_num&quot; =~ ^[0-9]+$ ]] &amp;&amp; [ &quot;$user_num&quot; -ge 1 ] &amp;&amp; [ &quot;$user_num&quot; -le $(( $&#123;#user_array[@]&#125; + 1 )) ]; then</span><br><span class="line">        if [ &quot;$user_num&quot; -eq $(( $&#123;#user_array[@]&#125; + 1 )) ]; then</span><br><span class="line">            read -p &quot;请输入自定义用户名: &quot; targetUser</span><br><span class="line">        else</span><br><span class="line">            targetUser=&quot;$&#123;user_array[$((user_num - 1))]&#125;&quot;</span><br><span class="line">        fi</span><br><span class="line">        print_to_console &quot;Selected user: $targetUser&quot;</span><br><span class="line">        break</span><br><span class="line">    else</span><br><span class="line">        print_to_console &quot;Invalid choice. Please try again.&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令</span></span><br><span class="line">if [[ -n &quot;$selected_container&quot; ]]; then</span><br><span class="line">    print_to_console &quot;$KUBECTL_CMD exec -it -n $&#123;ns&#125; $&#123;pod&#125; -c $&#123;selected_container&#125; -- su - $targetUser&quot;</span><br><span class="line">    $KUBECTL_CMD exec -it -n $&#123;ns&#125; $&#123;pod&#125; -c $&#123;selected_container&#125; -- su - $targetUser</span><br><span class="line">else</span><br><span class="line">    print_to_console &quot;$KUBECTL_CMD exec -it -n $&#123;ns&#125; $&#123;pod&#125; -- su - $targetUser&quot;</span><br><span class="line">    $KUBECTL_CMD exec -it -n $&#123;ns&#125; $&#123;pod&#125; -- su - $targetUser</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="查询命令"><a href="#查询命令" class="headerlink" title="查询命令"></a>查询命令</h1><p>根据机器ip(field-selector)查询pod:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export fieldKEY=&quot;status.podIP&quot;</span><br><span class="line">export fieldVALUE=&quot;6.0.90.240&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">alias</span> kubectl=<span class="string">&#x27;kubectl&#x27;</span></span></span><br><span class="line">alias kubectl=&#x27;kubectl --kubeconfig=/Users/king/.kube/sa128.config&#x27;</span><br><span class="line"></span><br><span class="line">kubectl get pod --all-namespaces --field-selector=$fieldKEY=$fieldVALUE -o wide</span><br></pre></td></tr></table></figure>

<p>根据label查询pod:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export labelKEY=&quot;sigma.ali/ip&quot;</span><br><span class="line">export labelVALUE=&quot;6.0.90.240&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">alias</span> kubectl=<span class="string">&#x27;kubectl&#x27;</span></span></span><br><span class="line">alias kubectl=&#x27;kubectl --kubeconfig=/Users/king/.kube/sa128.config&#x27;</span><br><span class="line"></span><br><span class="line">kubectl get pod --all-namespaces -l $labelKEY=$labelVALUE -o wide</span><br></pre></td></tr></table></figure>

<h1 id="导出yaml"><a href="#导出yaml" class="headerlink" title="导出yaml"></a>导出yaml</h1><p>根据机器ip使用kubectl导出机器yaml:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">local podName=&quot;&quot;</span><br><span class="line">local namespace=&quot;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">alias</span> kubectl=<span class="string">&#x27;kubectl&#x27;</span></span></span><br><span class="line">alias kubectl=&#x27;kubectl --kubeconfig=/Users/king/.kube/sa128.config&#x27;</span><br><span class="line"></span><br><span class="line">kubectl get pod/$podName -n $&#123;namespace&#125; -oyaml</span><br></pre></td></tr></table></figure>

<h1 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h1><p>根据namespace和podName进行describe</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local namespace=&quot;longtermbase&quot;</span><br><span class="line">local podName=&quot;inplaceset-antcodebuild-tn1oimjfl-gz00b-0&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">alias</span> kubectl=<span class="string">&#x27;kubectl&#x27;</span></span></span><br><span class="line">alias kubectl=&#x27;kubectl --kubeconfig=/Users/king/.kube/sa128.config&#x27;</span><br><span class="line"></span><br><span class="line">kubectl describe pod $podName -n $namespace</span><br></pre></td></tr></table></figure>

<h1 id="清理terminating的pod"><a href="#清理terminating的pod" class="headerlink" title="清理terminating的pod"></a>清理terminating的pod</h1><p>通过清理finalizers实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local namespace=&quot;&quot;</span><br><span class="line">local podName=&quot;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">alias</span> kubectl=<span class="string">&#x27;kubectl&#x27;</span></span></span><br><span class="line">alias kubectl=&#x27;kubectl --kubeconfig=/Users/king/.kube/sa128.config&#x27;</span><br><span class="line"></span><br><span class="line">kubectl patch pod/$podName -n $namespace -p &#x27;&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:null&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>强制删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local namespace=&quot;&quot;</span><br><span class="line">local podName=&quot;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">alias</span> kubectl=<span class="string">&#x27;kubectl&#x27;</span></span></span><br><span class="line">alias kubectl=&#x27;kubectl --kubeconfig=/Users/king/.kube/sa128.config&#x27;</span><br><span class="line"></span><br><span class="line">k delete pod/$podName -n $namespace --force --grace-period=0</span><br></pre></td></tr></table></figure>

<h1 id="复制文件到pod容器"><a href="#复制文件到pod容器" class="headerlink" title="复制文件到pod容器"></a>复制文件到pod容器</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local namespace=&quot;&quot;</span><br><span class="line">local podName=&quot;&quot;</span><br><span class="line">local sourceDir=&quot;&quot;</span><br><span class="line">local sourceFile=&quot;&quot;</span><br><span class="line">local targetDir=&quot;&quot;</span><br><span class="line">local targetFile=&quot;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">alias</span> kubectl=<span class="string">&#x27;kubectl&#x27;</span></span></span><br><span class="line">alias kubectl=&#x27;kubectl --kubeconfig=/Users/king/.kube/sa128.config&#x27;</span><br><span class="line"></span><br><span class="line">kubectl cp -n linkw $sourceDir/$sourceFile $podName:/targetDir/targetFile</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>加速代理</title>
    <url>/2025/07/kubernetes/%E5%8A%A0%E9%80%9F%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-友情链接"><a href="#1-友情链接" class="headerlink" title="1 友情链接"></a>1 友情链接</h1><ul>
<li>镜像加速：<a href="https://github.com/DaoCloud/public-image-mirror">https://github.com/DaoCloud/public-image-mirror</a></li>
<li>二进制文件加速：<a href="https://github.com/DaoCloud/public-binary-files-mirror">https://github.com/DaoCloud/public-binary-files-mirror</a></li>
<li>Helm 加速：<a href="https://github.com/DaoCloud/public-helm-charts-mirror">https://github.com/DaoCloud/public-helm-charts-mirror</a></li>
</ul>
<h1 id="2-二进制文件加速"><a href="#2-二进制文件加速" class="headerlink" title="2 二进制文件加速"></a>2 二进制文件加速</h1><h2 id="2-1-使用方法"><a href="#2-1-使用方法" class="headerlink" title="2.1 使用方法"></a>2.1 使用方法</h2><p>在原始 URL 上面加入 files.m.daocloud.io 的 前缀 就可以使用。比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Helm 下载原始URL</span></span><br><span class="line">wget https://get.helm.sh/helm-v3.9.1-linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加速后的 URL</span></span><br><span class="line">wget https://files.m.daocloud.io/get.helm.sh/helm-v3.9.1-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="2-2-安装-Helm"><a href="#2-2-安装-Helm" class="headerlink" title="2.2 安装 Helm"></a>2.2 安装 Helm</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">export HELM_VERSION=&quot;v3.9.3&quot;</span><br><span class="line"></span><br><span class="line">wget &quot;https://files.m.daocloud.io/get.helm.sh/helm-$&#123;HELM_VERSION&#125;-linux-amd64.tar.gz&quot;</span><br><span class="line">tar -zxvf helm-$&#123;HELM_VERSION&#125;-linux-amd64.tar.gz</span><br><span class="line">mv linux-amd64/helm /usr/local/bin/helm</span><br><span class="line">helm version</span><br></pre></td></tr></table></figure>

<h2 id="2-3-安装-KIND"><a href="#2-3-安装-KIND" class="headerlink" title="2.3 安装 KIND"></a>2.3 安装 KIND</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">export KIND_VERSION=&quot;v0.22.0&quot;</span><br><span class="line"></span><br><span class="line">curl -Lo ./kind https://files.m.daocloud.io/github.com/kubernetes-sigs/kind/releases/download/$&#123;KIND_VERSION&#125;/kind-linux-amd64</span><br><span class="line">chmod +x ./kind</span><br><span class="line">mv ./kind /usr/bin/kind</span><br><span class="line">kind version</span><br></pre></td></tr></table></figure>

<h2 id="2-4-安装-istio"><a href="#2-4-安装-istio" class="headerlink" title="2.4 安装 istio"></a>2.4 安装 istio</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">export ISTIO_VERSION=&quot;1.14.3&quot;</span><br><span class="line"></span><br><span class="line">wget &quot;https://files.m.daocloud.io/github.com/istio/istio/releases/download/$&#123;ISTIO_VERSION&#125;/istio-$&#123;ISTIO_VERSION&#125;-linux-amd64.tar.gz&quot;</span><br><span class="line">tar -zxvf istio-$&#123;ISTIO_VERSION&#125;-linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Do follow the istio docs to install istio</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-安装-nerdctl-（代替-docker-工具）"><a href="#2-5-安装-nerdctl-（代替-docker-工具）" class="headerlink" title="2.5 安装 nerdctl （代替 docker 工具）"></a>2.5 安装 nerdctl （代替 docker 工具）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export NERDCTL_VERSION=&quot;1.7.6&quot;</span><br><span class="line">mkdir -p nerdctl ;cd nerdctl</span><br><span class="line">wget https://files.m.daocloud.io/github.com/containerd/nerdctl/releases/download/v$&#123;NERDCTL_VERSION&#125;/nerdctl-full-$&#123;NERDCTL_VERSION&#125;-linux-amd64.tar.gz</span><br><span class="line">tar -zvxf nerdctl-full-$&#123;NERDCTL_VERSION&#125;-linux-amd64.tar.gz</span><br><span class="line">mkdir -p /opt/cni/bin ;cp -f libexec/cni/* /opt/cni/bin/ ;cp bin/* /usr/local/bin/ ;cp lib/systemd/system/*.service /usr/lib/systemd/system/</span><br><span class="line">systemctl enable containerd ;systemctl start containerd --now</span><br><span class="line">systemctl enable buildkit;systemctl start buildkit --now</span><br></pre></td></tr></table></figure>

<h1 id="3-docker镜像加速"><a href="#3-docker镜像加速" class="headerlink" title="3 docker镜像加速"></a>3 docker镜像加速</h1><h2 id="3-1-使用方法"><a href="#3-1-使用方法" class="headerlink" title="3.1 使用方法"></a>3.1 使用方法</h2><p>增加前缀 (推荐方式)。比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">              docker.io/library/busybox</span><br><span class="line">                 |</span><br><span class="line">                 V</span><br><span class="line">m.daocloud.io/docker.io/library/busybox</span><br></pre></td></tr></table></figure>

<p>或者 支持的镜像仓库 的 前缀替换 就可以使用。比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">           docker.io/library/busybox</span><br><span class="line">             |</span><br><span class="line">             V</span><br><span class="line">docker.m.daocloud.io/library/busybox</span><br></pre></td></tr></table></figure>

<h2 id="3-2-通过-加速-安装-kubeadm"><a href="#3-2-通过-加速-安装-kubeadm" class="headerlink" title="3.2 通过 加速 安装 kubeadm"></a>3.2 通过 加速 安装 kubeadm</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm config images pull --image-repository k8s-gcr.m.daocloud.io</span><br></pre></td></tr></table></figure>

<h2 id="3-3-通过-加速-安装-kind"><a href="#3-3-通过-加速-安装-kind" class="headerlink" title="3.3 通过 加速 安装 kind"></a>3.3 通过 加速 安装 kind</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kind create cluster --name kind --image m.daocloud.io/docker.io/kindest/node:v1.22.1</span><br></pre></td></tr></table></figure>

<h2 id="3-4-通过-加速-部署-应用-这里以-Ingress-为例"><a href="#3-4-通过-加速-部署-应用-这里以-Ingress-为例" class="headerlink" title="3.4 通过 加速 部署 应用(这里以 Ingress 为例)"></a>3.4 通过 加速 部署 应用(这里以 Ingress 为例)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O image-filter.sh https://github.com/DaoCloud/public-image-mirror/raw/main/hack/image-filter.sh &amp;&amp; chmod +x image-filter.sh</span><br><span class="line"></span><br><span class="line">wget -O deploy.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.0/deploy/static/provider/baremetal/deploy.yaml</span><br><span class="line"></span><br><span class="line">cat ./deploy.yaml | ./image-filter.sh | kubectl apply -f -</span><br></pre></td></tr></table></figure>

<h2 id="3-5-Docker-加速"><a href="#3-5-Docker-加速" class="headerlink" title="3.5 Docker 加速"></a>3.5 Docker 加速</h2><p>添加到 &#x2F;etc&#x2F;docker&#x2F;daemon.json</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://docker.m.daocloud.io&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-helm-加速"><a href="#4-helm-加速" class="headerlink" title="4 helm 加速"></a>4 helm 加速</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm repo add community https://release.daocloud.io/chartrepo/community </span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>BKCI 简介</title>
    <url>/2025/07/devops/blueking/BKCI%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>BK-CI官方文档：<a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/README.md">https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/README.md</a><br>github仓库地址：<a href="https://github.com/TencentBlueKing/bk-ci">https://github.com/TencentBlueKing/bk-ci</a></p>
<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><table>
<thead>
<tr>
<th>🐤 了解基本概念</th>
<th>👉 使用 BKCI</th>
<th>🚀 部署 BKCI</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/bkci.md">BKCI 是什么？</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Create-your-first-pipeline.md">创建你的第一条流水线</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Setup/system-requirements/hardware.md">BKCI 硬件规格指南</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/terminology/components.md">BKCI 组件</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Link-your-first-repo.md">关联你的第一个代码库</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Setup/system-requirements/system.md">BKCI 系统要求</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/terminology/Learn-pipeline-in-5min.md">快速熟悉流水线</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Enable-ci.md">为你的Git工程开启CI</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/intro/terminology/Learn-pipeline-in-5min.md">术语解释</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Quickstarts/Case/Examples/vars-usage.md">示例</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/rest-api/read-before-use.md">API接口</a></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>📔 产品功能</th>
<th>🏪 研发商店</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Pipeline/pipeline-list.md">流水线</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/home.md">浏览研发商店</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Console/Console.md">控制台</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/start-new-task.md">开发一个流水线插件</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Ticket/ticket.md">凭证管理</a></td>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/upload-new-task.md">在 BKCI 里使用商店插件</a></td>
</tr>
<tr>
<td><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Pools/host-to-bkci.md">构建资源</a></td>
<td></td>
</tr>
</tbody></table>
<h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><p>蓝鲸学习社区：<a href="https://bk.tencent.com/s-mart/communities">https://bk.tencent.com/s-mart/communities</a><br>蓝鲸官方文档：<a href="https://bk.tencent.com/docs/">https://bk.tencent.com/docs/</a></p>
<p><strong>蓝鲸体系</strong><br>蓝鲸简介：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/intro.md</a><br>核心优势：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/advantages.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/advantages.md</a><br>体系架构：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/solution.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/solution.md</a><br>CI领域：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/ci_intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/ci_intro.md</a><br>CD领域：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/cd_intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/cd_intro.md</a><br>CO领域：<a href="https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/co_intro.md">https://bk.tencent.com/docs/markdown/ZH/BlueKingFamily/7.2/UserGuide/Solution/co_intro.md</a></p>
]]></content>
  </entry>
  <entry>
    <title>生产部署文档(v7-1)</title>
    <url>/2025/08/devops/blueking/%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3(v7-1)/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>需要先准备一台中控机，在中控机安装 kubectl、helm、helmfile 等工具，以及蓝鲸安装脚本。然后部署基础套餐，最后再部署持续集成套餐（蓝盾）。</p>
<p>简单来说就是三个步骤：</p>
<ul>
<li><code>1.准备环境</code> </li>
<li><code>2.部署基础服务</code> </li>
<li><code>3.部署蓝盾</code></li>
</ul>
<h1 id="2-准备中控机"><a href="#2-准备中控机" class="headerlink" title="2. 准备中控机"></a>2. 准备中控机</h1><p>按照<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/prepare-bkctrl.md">官方文档</a>安装和配置即可。</p>
<h1 id="3-部署基础服务"><a href="#3-部署基础服务" class="headerlink" title="3. 部署基础服务"></a>3. 部署基础服务</h1><p>需要按照<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/custom-values.md">官方文档</a>一步步部署。</p>
<h2 id="3-1-下载安装文件"><a href="#3-1-下载安装文件" class="headerlink" title="3.1 下载安装文件"></a>3.1 下载安装文件</h2><p>请在 中控机 使用下载脚本下载蓝鲸 helmfile 包及公共证书。（ helmfile相关value文件在git上维护）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bkdl-7.1-stable.sh -ur latest base demo</span><br></pre></td></tr></table></figure>

<p>这些文件默认放在了 ~&#x2F;bkce7.1-install&#x2F; 目录。</p>
<h2 id="3-2-配置-Helm-Chart-仓库"><a href="#3-2-配置-Helm-Chart-仓库" class="headerlink" title="3.2 配置 Helm Chart 仓库"></a>3.2 配置 Helm Chart 仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm repo add blueking https://hub.bktencent.com/chartrepo/blueking</span><br><span class="line">helm repo update</span><br><span class="line">helm repo list</span><br></pre></td></tr></table></figure>

<h2 id="3-3-配置全局-custom-values"><a href="#3-3-配置全局-custom-values" class="headerlink" title="3.3 配置全局 custom-values"></a>3.3 配置全局 custom-values</h2><p>相关文件已经修改，在git上维护，配置访问域名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BK_DOMAIN=bk.blazehu.com  # 请修改为你分配给蓝鲸平台的主域名 cd ~/bkce7.1-install/blueking/  # 进入工作目录# 可使用如下命令添加域名。如果文件已存在，请手动编辑。custom=environments/default/custom.yaml</span><br><span class="line">cat &gt;&gt; &quot;$custom&quot; &lt;&lt;EOF</span><br><span class="line">imageRegistry: $&#123;REGISTRY:-hub.bktencent.com&#125;</span><br><span class="line">domain:</span><br><span class="line">  bkDomain: $BK_DOMAIN</span><br><span class="line">  bkMainSiteDomain: $BK_DOMAIN</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="3-4-生成-values-文件"><a href="#3-4-生成-values-文件" class="headerlink" title="3.4 生成 values 文件"></a>3.4 生成 values 文件</h2><p>还有一些 values 文件随着部署环境的不同而变化，所以我们提供了脚本快速生成。</p>
<p><code>生成蓝鲸 app code 对应的 secret</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./scripts/generate_app_secret.sh ./environments/default/app_secret.yaml</span><br></pre></td></tr></table></figure>

<p><code>生成 apigw 所需的 keypair</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./scripts/generate_rsa_keypair.sh ./environments/default/bkapigateway_builtin_keypair.yaml</span><br></pre></td></tr></table></figure>

<p><code>生成 paas 所需的 clusterAdmin</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./scripts/create_k8s_cluster_admin_for_paas3.sh</span><br></pre></td></tr></table></figure>

<h2 id="3-5-安装入口网关"><a href="#3-5-安装入口网关" class="headerlink" title="3.5 安装入口网关"></a>3.5 安装入口网关</h2><h3 id="3-5-1-安装-ingress-controller"><a href="#3-5-1-安装-ingress-controller" class="headerlink" title="3.5.1 安装 ingress controller"></a>3.5.1 安装 ingress controller</h3><p>先检查你的环境是否已经部署了 ingress controller:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods -A -l app.kubernetes.io/name=ingress-nginx</span><br></pre></td></tr></table></figure>

<p>如果没有，则使用如下命令创建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helmfile -f 00-ingress-nginx.yaml.gotmpl sync</span><br><span class="line">kubectl get pods -A -l app.kubernetes.io/name=ingress-nginx  查看创建的pod</span><br></pre></td></tr></table></figure>

<p>pops集群相关标签如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods -A -l app=ingress-nginx  # 查看创建的pod</span><br><span class="line">IP1=$(kubectl get svc -A -l app=nginx-ingress-lb -o jsonpath=&#x27;&#123;.items[0].status.loadBalancer.ingress[0].ip&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">IP1=$(kubectl get svc -A -l app.kubernetes.io/name=ingress-nginx -o jsonpath=<span class="string">&#x27;&#123;.items[0].status.loadBalancer.ingress[0].ip&#125;&#x27;</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-配置-coredns"><a href="#3-5-2-配置-coredns" class="headerlink" title="3.5.2 配置 coredns"></a>3.5.2 配置 coredns</h3><p>在部署过程中，会在容器内访问这些域名，所以需要提前配置 coredns，将蓝鲸域名解析到 service IP。</p>
<blockquote>
<p>注意: 当 service 被删除，重建后 clusterIP 会变动，此时需刷新 hosts 文件。</p>
</blockquote>
<p>因此需要注入 hosts 配置项到 <code>kube-system</code> namespace 下的 <code>coredns</code> 系列 pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/bkce7.1-install/blueking/  # 进入工作目录</span><br><span class="line">BK_DOMAIN=$(yq e &#x27;.domain.bkDomain&#x27; environments/default/custom.yaml)  # 从自定义配置中提取, 也可自行赋值</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">IP1=$(kubectl get svc -A -l app.kubernetes.io/instance=ingress-nginx -o jsonpath=<span class="string">&#x27;&#123;.items[0].spec.clusterIP&#125;&#x27;</span>)</span></span><br><span class="line">IP1=$(kubectl get svc -A -l app=nginx-ingress-lb -o jsonpath=&#x27;&#123;.items[0].status.loadBalancer.ingress[0].ip&#125;&#x27;)</span><br><span class="line">./scripts/control_coredns.sh update &quot;$IP1&quot; $BK_DOMAIN bkrepo.$BK_DOMAIN docker.$BK_DOMAIN bkapi.$BK_DOMAIN bkpaas.$BK_DOMAIN bkiam-api.$BK_DOMAIN bkiam.$BK_DOMAIN apps.$BK_DOMAIN bknodeman.$BK_DOMAIN job.$BK_DOMAIN jobapi.$BK_DOMAIN</span><br><span class="line">./scripts/control_coredns.sh update &quot;$IP1&quot; devops.$BK_DOMAIN</span><br><span class="line">./scripts/control_coredns.sh list  # 检查添加的记录。</span><br></pre></td></tr></table></figure>

<p>确认注入结果，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/bkce7.1-install/blueking/  进入工作目录</span><br><span class="line">./scripts/control_coredns.sh list</span><br></pre></td></tr></table></figure>

<p>参考输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">172.27.124.109 bkce.diezhi.net</span><br><span class="line">172.27.124.109 bkrepo.bkce.diezhi.net</span><br><span class="line">172.27.124.109 docker.bkce.diezhi.net</span><br><span class="line">172.27.124.109 bkapi.bkce.diezhi.net</span><br><span class="line">172.27.124.109 bkpaas.bkce.diezhi.net</span><br><span class="line">172.27.124.109 bkiam-api.bkce.diezhi.net</span><br><span class="line">172.27.124.109 bkiam.bkce.diezhi.net</span><br><span class="line">172.27.124.109 apps.bkce.diezhi.net</span><br><span class="line">172.27.124.109 bknodeman.bkce.diezhi.net</span><br><span class="line">172.27.124.109 job.bkce.diezhi.net</span><br><span class="line">172.27.124.109 jobapi.bkce.diezhi.net</span><br><span class="line">172.27.124.109 devops.bkce.diezhi.net</span><br></pre></td></tr></table></figure>

<h2 id="3-6-部署或对接存储服务"><a href="#3-6-部署或对接存储服务" class="headerlink" title="3.6 部署或对接存储服务"></a>3.6 部署或对接存储服务</h2><h3 id="3-6-1-部署蓝鲸预置的存储服务"><a href="#3-6-1-部署蓝鲸预置的存储服务" class="headerlink" title="3.6.1 部署蓝鲸预置的存储服务"></a>3.6.1 部署蓝鲸预置的存储服务</h3><p>参考<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/storage-services.md">官方文档</a>安装，相关helm配置已经放在<a href="https://opsgit.papegames.com/infra/devops">gitlab仓库</a>上维护，可以直接简单执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helmfile -f base-storage.yaml.gotmpl sync</span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-对接已有的存储服务"><a href="#3-6-2-对接已有的存储服务" class="headerlink" title="3.6.2 对接已有的存储服务"></a>3.6.2 对接已有的存储服务</h3><p>禁用蓝鲸内置服务，配置使用已有服务。helmfile 定义及 values 文件已经放在gitlab仓库上维护。</p>
<p>此处可直接跳过。</p>
<h2 id="3-7-部署基础套餐"><a href="#3-7-部署基础套餐" class="headerlink" title="3.7 部署基础套餐"></a>3.7 部署基础套餐</h2><p>通过helmfile安装 base-blueking.yaml.gotmpl ，按照顺序依次安装。具体每层安装的内容可以查看文件内容。<br>参考<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/storage-services.md">官方文档</a>安装，相关helm配置已经放在gitlab仓库上维护，可以直接简单执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=first sync</span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=second sync</span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=third sync</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">helmfile -f base-blueking.yaml.gotmpl -l <span class="built_in">seq</span>=fourth <span class="built_in">sync</span></span></span><br></pre></td></tr></table></figure>

<h2 id="3-8-访问蓝鲸桌面"><a href="#3-8-访问蓝鲸桌面" class="headerlink" title="3.8 访问蓝鲸桌面"></a>3.8 访问蓝鲸桌面</h2><p>在负载均衡器配置后端为 ingress-nginx pod 所在机器的内网 IP，端口为 80。详细信息参考<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/manual-install-bkce.md">文档</a>。</p>
<h3 id="3-8-1-查找ingress-nginx-svc"><a href="#3-8-1-查找ingress-nginx-svc" class="headerlink" title="3.8.1 查找ingress nginx svc"></a>3.8.1 查找ingress nginx svc</h3><p>找到ingress nginx的svc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pops</span></span><br><span class="line">kubectl get svc -n kube-system|grep ingress</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pops-dev</span></span><br><span class="line">kubectl get svc -n ingress-nginx|grep ingress</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pops</span></span><br><span class="line">ingress-nginx-controller-admission        ClusterIP      172.26.10.30    &lt;none&gt;          443/TCP                        3y69d</span><br><span class="line">nginx-ingress-lb                          LoadBalancer   172.26.1.155    10.212.14.158   80:30725/TCP,443:31357/TCP     3y69d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pops-dev</span></span><br><span class="line">ingress-nginx-controller             NodePort    172.27.124.109   &lt;none&gt;        80:32080/TCP,443:32443/TCP   279d</span><br><span class="line">ingress-nginx-controller-admission   ClusterIP   172.27.123.38    &lt;none&gt;        443/TCP                      279d</span><br><span class="line">ingress-nginx-controller-metrics     ClusterIP   172.27.116.175   &lt;none&gt;        10254/TCP                    279d</span><br></pre></td></tr></table></figure>

<p>这里<code>nginx-ingress-lb</code>是目前<code>pops集群</code>的<code>ingress nginx svc</code>，而<code>ingress-nginx-controller</code>是目前<code>pops-dev集群</code>的<code>ingress nginx svc</code>。</p>
<h3 id="3-8-2-设置svc-type为LoadBalancer"><a href="#3-8-2-设置svc-type为LoadBalancer" class="headerlink" title="3.8.2 设置svc type为LoadBalancer"></a>3.8.2 设置svc type为LoadBalancer</h3><p>查看svc type：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pops集群ingress nginx svc命令</span></span><br><span class="line">kubectl get svc/nginx-ingress-lb -n kube-system -oyaml|grep type</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pops-dev集群ingress nginx svc命令</span></span><br><span class="line">kubectl get svc/ingress-nginx-controller -n ingress-nginx -oyaml|grep type</span><br></pre></td></tr></table></figure>

<p>若无<code>type: LoadBalancer</code>结果，则手动进行修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改pops集群ingress nginx svc命令</span></span><br><span class="line">kubectl edit svc/nginx-ingress-lb -n kube-system</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改pops-dev集群ingress nginx svc命令</span></span><br><span class="line">kubectl edit svc/ingress-nginx-controller -n ingress-nginx</span><br></pre></td></tr></table></figure>

<h3 id="3-8-3-负载均衡clb实例"><a href="#3-8-3-负载均衡clb实例" class="headerlink" title="3.8.3 负载均衡clb实例"></a>3.8.3 负载均衡clb实例</h3><p>查看svc yaml是否包含两个重要annotation：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pops集群ingress nginx svc命令</span></span><br><span class="line">kubectl get svc/nginx-ingress-lb -n kube-system -oyaml|grep service.beta.kubernetes.io/alibaba-cloud-loadbalancer-force-override-listeners</span><br><span class="line">kubectl get svc/nginx-ingress-lb -n kube-system -oyaml|grep service.beta.kubernetes.io/alibaba-cloud-loadbalancer-id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pops-dev集群ingress nginx svc命令</span></span><br><span class="line">kubectl get svc/ingress-nginx-controller -n ingress-nginx -oyaml|grep service.beta.kubernetes.io/alibaba-cloud-loadbalancer-force-override-listeners</span><br><span class="line">kubectl get svc/ingress-nginx-controller -n ingress-nginx -oyaml|grep service.beta.kubernetes.io/alibaba-cloud-loadbalancer-id</span><br></pre></td></tr></table></figure>

<p>若这两个重要annotation缺失，则需进行设置。</p>
<p>负载均衡控制台地址：<a href="https://slb.console.aliyun.com/overview">https://slb.console.aliyun.com/overview</a></p>
<p>找到<code>pops-dev</code>集群的clb：<code>pops-k8s-dev-ingress</code><br><img src="/img_12.png" alt="img_12.png"></p>
<p>找到<code>pops</code>集群的clb：<code>k8s-pops-ingress-slb</code><br><img src="/img_14.png" alt="img_14.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改pops集群ingress nginx svc命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pops集群clb名称：k8s-pops-ingress-slb</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pops集群clb <span class="built_in">id</span>：lb-bp1tt6vxctuzi38mqfkw0</span></span><br><span class="line">kubectl edit svc/nginx-ingress-lb -n kube-system</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改pops-dev集群ingress nginx svc命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pops-dev集群clb名称：pops-k8s-dev-ingress</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pops-dev集群clb <span class="built_in">id</span>：lb-bp1r1dsywnqktp1hxih38</span></span><br><span class="line">kubectl edit svc/ingress-nginx-controller -n ingress-nginx</span><br></pre></td></tr></table></figure>

<h3 id="3-8-4-访问地址"><a href="#3-8-4-访问地址" class="headerlink" title="3.8.4 访问地址"></a>3.8.4 访问地址</h3><p>查看浏览器访问地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/bkce7.1-install/blueking/  # 进入工作目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从自定义配置中提取</span></span><br><span class="line">BK_DOMAIN=$(yq e &#x27;.domain.bkDomain&#x27; environments/default/custom.yaml)  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">普通登录地址(接入统一登录，且登录成功后会跳转蓝盾)</span></span><br><span class="line">echo &quot;http://$BK_DOMAIN&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">admin登录地址(接入统一登录后，可通过此方法适用admin登录)</span></span><br><span class="line">echo &quot;http://$&#123;BK_DOMAIN&#125;/login/origin/&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试环境一般结果为：http://bkce.diezhi.net/login/origin/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生产环境一般结果为：https://bk.diezhi.net/login/origin/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看用户密码(预设原始密码)：</span></span><br><span class="line">kubectl get cm -n blueking bk-user-api-general-envs -o go-template=&#x27;user=&#123;&#123;.data.INITIAL_ADMIN_USERNAME&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;password=&#123;&#123; .data.INITIAL_ADMIN_PASSWORD &#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-对接Ldap服务"><a href="#3-9-对接Ldap服务" class="headerlink" title="3.9 对接Ldap服务"></a>3.9 对接Ldap服务</h2><p>在用户中心里配置Ldap相关配置，然后更新 bk-user-api-web 服务的镜像。<br><img src="/img_22.png" alt="img_22.png"><br><img src="/img_23.png" alt="img_23.png"></p>
<h1 id="4-部署蓝盾"><a href="#4-部署蓝盾" class="headerlink" title="4. 部署蓝盾"></a>4. 部署蓝盾</h1><p>参考<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/install-ci-suite.md">官方文档</a>部署，配置 custom values 的内容提前修改完成，执行类似部署基础服务的以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/bkce7.1-install/blueking/  # 进入工作目录</span><br><span class="line">helmfile -f 03-bkci.yaml.gotmpl sync  # 部署</span><br><span class="line">helmfile -f 03-bkci.yaml.gotmpl apply # 更新</span><br></pre></td></tr></table></figure>
<p>剩下的步骤参考官方文档执行即可，主要步骤有以下三个，其他的步骤可以不做。</p>
<h2 id="4-1-可选-注册默认构建镜像"><a href="#4-1-可选-注册默认构建镜像" class="headerlink" title="4.1 [可选]注册默认构建镜像"></a>4.1 [可选]注册默认构建镜像</h2><p>我们提供了 bkci&#x2F;ci 镜像用于提供构建环境。为了加速镜像下载过程，可以修改镜像地址为 hub.bktencent.com&#x2F;bkci&#x2F;ci，或者为你自己托管的内网 registry。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl exec -it -n blueking bk-ci-mysql-0 -- /bin/bash -c &#x27;MYSQL_PWD=&quot;$MYSQL_ROOT_PASSWORD&quot; mysql -u root -e &quot;USE devops_ci_store; SELECT IMAGE_NAME,IMAGE_CODE,IMAGE_REPO_NAME FROM T_IMAGE WHERE IMAGE_CODE = \&quot;bkci\&quot; ;&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p>请根据结果进行操作：</p>
<ul>
<li><p>如果有显示镜像数据，可以修改镜像地址为蓝鲸国内仓库，也可改为你已经缓存在内网的镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl exec -it -n blueking bk-ci-mysql-0 -- /bin/bash -c &#x27;MYSQL_PWD=&quot;$MYSQL_ROOT_PASSWORD&quot; mysql -u root -e &quot;USE devops_ci_store; UPDATE  T_IMAGE SET IMAGE_REPO_NAME=\&quot;hub.bktencent.com/bkci/ci\&quot; WHERE IMAGE_CODE = \&quot;bkci\&quot; ;&quot;&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后重新查询数据库，可以看到 IMAGE_REPO_NAME 列已经更新。</p>
</li>
<li><p>如果没有镜像，可以新增：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl exec -n blueking deploy/bk-ci-bk-ci-store -- \curl -vs http://bk-ci-bk-ci-store.blueking.svc.cluster.local/api/op/market/image/init -X POST \-H &#x27;X-DEVOPS-UID: admin&#x27; -H &#x27;Content-type: application/json&#x27; -d &#x27;&#123;&quot;imageCode&quot;:&quot;bkci&quot;,&quot;imageName&quot;:&quot;bkci&quot;,&quot;imageRepo&quot;:&quot;hub.bktencent.com/bkci/ci&quot;,&quot;projectCode&quot;:&quot;demo&quot;,&quot;userId&quot;:&quot;admin&quot;&#125;&#x27; | jq .</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ul>
<li>提示</li>
<li>当你单独卸载蓝盾重装后，可能出现查询镜像为空，但是新增镜像时报错 { status: 400, message: “权限中心创建项目失败” } 的情况。这是因为权限中心存在蓝盾 demo 项目的数据所致，我们后续会优化蓝盾单独卸载的文档。请先手动新建项目，并修改上述代码中 projectCode 字段的值。</li>
</ul>
</blockquote>
<h3 id="4-1-1-解决权限中心创建项目失败"><a href="#4-1-1-解决权限中心创建项目失败" class="headerlink" title="4.1.1 解决权限中心创建项目失败"></a>4.1.1 解决权限中心创建项目失败</h3><p>在 中控机 执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/bkce7.1-install/blueking/  # 进入工作目录</span><br><span class="line">./scripts/control_coredns.sh list  # 检查添加的记录。</span><br></pre></td></tr></table></figure>

<p>会得到类似的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">172.27.124.109 devops.bkce.diezhi.net</span><br><span class="line">172.27.124.109 bkce.diezhi.net</span><br><span class="line">172.27.124.109 bkrepo.bkce.diezhi.net</span><br><span class="line">172.27.124.109 docker.bkce.diezhi.net</span><br><span class="line">172.27.124.109 bkapi.bkce.diezhi.net</span><br><span class="line">172.27.124.109 bkpaas.bkce.diezhi.net</span><br><span class="line">172.27.124.109 bkiam-api.bkce.diezhi.net</span><br><span class="line">172.27.124.109 bkiam.bkce.diezhi.net</span><br><span class="line">172.27.124.109 apps.bkce.diezhi.net</span><br><span class="line">172.27.124.109 bknodeman.bkce.diezhi.net</span><br><span class="line">172.27.124.109 job.bkce.diezhi.net</span><br><span class="line">172.27.124.109 jobapi.bkce.diezhi.net</span><br></pre></td></tr></table></figure>

<p>使用admin账号通过浏览器访问devops.bkce.diezhi.net，并创建项目：<br><img src="/img_15.png" alt="img_15.png"></p>
<p><img src="/img_16.png" alt="img_16.png"></p>
<p><img src="/img_17.png" alt="img_17.png"></p>
<p>此时重新新增：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl exec -n blueking deploy/bk-ci-bk-ci-store -- \curl -vs http://bk-ci-bk-ci-store.blueking.svc.cluster.local/api/op/market/image/init -X POST \-H &#x27;X-DEVOPS-UID: admin&#x27; -H &#x27;Content-type: application/json&#x27; -d &#x27;&#123;&quot;imageCode&quot;:&quot;bkci&quot;,&quot;imageName&quot;:&quot;bkci&quot;,&quot;imageRepo&quot;:&quot;hub.bktencent.com/bkci/ci&quot;,&quot;projectCode&quot;:&quot;huari-demo&quot;,&quot;userId&quot;:&quot;admin&quot;&#125;&#x27; | jq .</span><br></pre></td></tr></table></figure>

<p>如新建项目遇见可授权人员范围加载不出来(白屏转圈圈)</p>
<p>需要确定跳转从蓝鲸跳转蓝盾是否是走了https，本文档是使用http部署，所以使用https会出现问题<br><img src="/img_18.png" alt="img_18.png"></p>
<h2 id="4-2-可跳过-对接制品库"><a href="#4-2-可跳过-对接制品库" class="headerlink" title="4.2 [可跳过]对接制品库"></a>4.2 [可跳过]对接制品库</h2><p>蓝盾依靠蓝鲸制品库来提供流水线仓库和自定义仓库，需要调整制品库的认证模式。</p>
<p>当 <code>bk-ci</code> release 成功启动后，我们开始配置蓝鲸制品库，并注册到蓝盾中。</p>
<h3 id="4-2-1-修改-bk-repo-custom-values"><a href="#4-2-1-修改-bk-repo-custom-values" class="headerlink" title="4.2.1 修改 bk-repo custom values"></a>4.2.1 修改 bk-repo custom values</h3><p>相关配置已经放在gitlab仓库上维护，可以直接跳过本步骤。</p>
<p>[可跳过]请在 中控机 执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/bkce7.1-install/blueking/  # 进入工作目录</span><br><span class="line">case $(yq e &#x27;.auth.config.realm&#x27; environments/default/bkrepo-custom-values.yaml.gotmpl 2&gt;/dev/null) in</span><br><span class="line">  null|&quot;&quot;)</span><br><span class="line">    tee -a environments/default/bkrepo-custom-values.yaml.gotmpl &lt;&lt;&lt; $&#x27;auth:\n  config:\n    realm: devops&#x27;</span><br><span class="line">  ;;</span><br><span class="line">  devops)</span><br><span class="line">    echo &quot;environments/default/bkrepo-custom-values.yaml.gotmpl 中配置了 .auth.config.realm=devops, 无需修改.&quot;</span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">    echo &quot;environments/default/bkrepo-custom-values.yaml.gotmpl 中配置了 .auth.config.realm 为其他值, 请手动修改值为 devops.&quot;</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>[可跳过]修改成功后，继续在工作目录执行如下命令使修改生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helmfile -f base-blueking.yaml.gotmpl -l name=bk-repo apply</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-检查配置是否生效"><a href="#4-2-2-检查配置是否生效" class="headerlink" title="4.2.2 检查配置是否生效"></a>4.2.2 检查配置是否生效</h3><p>检查 release 生效的 values 和 configmap 是否重新渲染。</p>
<p>[可跳过]请在 中控机 执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm get values -n blueking bk-repo | yq e &#x27;.auth.config.realm&#x27;</span><br><span class="line">kubectl get cm -n blueking bk-repo-bkrepo-auth -o json | jq -r &#x27;.data.&quot;application.yml&quot;&#x27; | yq e &#x27;.auth.realm&#x27; -</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-重启-bk-repo-auth-微服务"><a href="#4-2-3-重启-bk-repo-auth-微服务" class="headerlink" title="4.2.3 重启 bk-repo auth 微服务"></a>4.2.3 重启 bk-repo auth 微服务</h3><p>因为对接制品库的相关信息已经在gitlab仓库上维护了，所以此处不用进行重启。</p>
<p>[可跳过]因为 deployment 没有变动，所以不会自动重启，此处需要单独重启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl rollout restart deployment -n blueking bk-repo-bkrepo-auth</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-在蓝盾中注册制品库"><a href="#4-2-4-在蓝盾中注册制品库" class="headerlink" title="4.2.4 在蓝盾中注册制品库"></a>4.2.4 在蓝盾中注册制品库</h3><p>[可跳过]请在 中控机 执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/bkce7.1-install/blueking/  # 进入工作目录</span><br><span class="line">BK_DOMAIN=$(yq e &#x27;.domain.bkDomain&#x27; environments/default/custom.yaml)  # 从自定义配置中提取, 也可自行赋值# 向project微服务注册制品库</span><br><span class="line">kubectl exec -i -n blueking deploy/bk-ci-bk-ci-project -- curl -sS -X PUT -H &#x27;Content-Type: application/json&#x27; -H &#x27;Accept: application/json&#x27; -H &#x27;X-DEVOPS-UID: admin&#x27; -d &quot;&#123;\&quot;showProjectList\&quot;:true,\&quot;showNav\&quot;:true,\&quot;status\&quot;:\&quot;ok\&quot;,\&quot;deleted\&quot;:false,\&quot;iframeUrl\&quot;:\&quot;//bkrepo.$BK_DOMAIN/ui/\&quot;&#125;&quot; &quot;http://bk-ci-bk-ci-project.blueking.svc.cluster.local/api/op/services/update/Repo&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-可选-下载和上传插件"><a href="#4-3-可选-下载和上传插件" class="headerlink" title="4.3 [可选]下载和上传插件"></a>4.3 [可选]下载和上传插件</h2><h3 id="4-3-1-下载插件"><a href="#4-3-1-下载插件" class="headerlink" title="4.3.1 下载插件"></a>4.3.1 下载插件</h3><p>请在 中控机 执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bkdl-7.1-stable.sh -ur latest ci-plugins</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-上传插件"><a href="#4-3-2-上传插件" class="headerlink" title="4.3.2 上传插件"></a>4.3.2 上传插件</h3><p>此操作只能新建插件，每个插件只能上传一次。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/bkce7.1-install/blueking/  # 进入工作目录</span><br><span class="line">for f in ../ci-plugins/*.zip; do</span><br><span class="line">    atom=&quot;$&#123;f##*/&#125;&quot;</span><br><span class="line">    atom=$&#123;atom%.zip&#125;</span><br><span class="line">    echo &gt;&amp;2 &quot;upload $atom from $f&quot;</span><br><span class="line">    kubectl exec -i -n blueking deploy/bk-ci-bk-ci-store -- \</span><br><span class="line">      curl -s \</span><br><span class="line">      http://bk-ci-bk-ci-store.blueking.svc.cluster.local/api/op/pipeline/atom/deploy/&quot;?publisher=admin&quot; \</span><br><span class="line">      -H &#x27;X-DEVOPS-UID: admin&#x27; -F atomCode=$atom -F file=@- &lt; &quot;$f&quot; | jq .</span><br><span class="line">      # 设置为默认插件，全部项目可见。</span><br><span class="line">    kubectl exec -n blueking deploy/bk-ci-bk-ci-store -- \</span><br><span class="line">    curl -s http://bk-ci-bk-ci-store.blueking.svc.cluster.local/api/op/pipeline/atom/default/atomCodes/$atom \-H &#x27;X-DEVOPS-UID: admin&#x27; -X POST | jq .</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-问题及解决方案"><a href="#4-3-3-问题及解决方案" class="headerlink" title="4.3.3 问题及解决方案"></a>4.3.3 问题及解决方案</h3><p><code>这个问题已经在蓝盾的helm charts里面进行了优化</code></p>
<p>上传插件时会碰到这个问题：<br><img src="/img_19.png" alt="img_19.png"></p>
<p>蓝盾官方文档说法是：<br><img src="/img_20.png" alt="img_20.png"></p>
<p>实际原因是：HTTP请求报了 413 Request Entity Too Large</p>
<p>具体解决方式详见：<a href="https://developer.aliyun.com/article/1001630">Ingress 域名方式导致413 Request Entity Too Large-阿里云开发者社区</a></p>
<p>造成这个问题的主要原因是nginx-ingress的默认配置中proxy-body-size的数值太小<br><img src="/img_21.png" alt="img_21.png"></p>
<h1 id="5-支持https"><a href="#5-支持https" class="headerlink" title="5. 支持https"></a>5. 支持https</h1><p>如果开始就准备好了相关证书，那么可以将该步骤提前，在部署基础服务和蓝盾之前就先修改好相关的yaml，将需要创建的Secret和要更新的Ingress配置都提前修改好，然后直接部署即可。</p>
<h2 id="5-1-购买相关证书"><a href="#5-1-购买相关证书" class="headerlink" title="5.1 购买相关证书"></a>5.1 购买相关证书</h2><p>涉及的域名：bk.blazehu.com、*.bk.blazehu.com（如devops.bk.blazehu.com）。需购买泛域名证书。</p>
<h2 id="5-2-创建相关Secret（用于存储TLS证书和私钥）"><a href="#5-2-创建相关Secret（用于存储TLS证书和私钥）" class="headerlink" title="5.2 创建相关Secret（用于存储TLS证书和私钥）"></a>5.2 创建相关Secret（用于存储TLS证书和私钥）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Secret</span></span><br><span class="line">BK_DOMAIN=$(yq e &#x27;.domain.bkDomain&#x27; environments/default/custom.yaml)</span><br><span class="line">cd $HOME/$BK_DOMAIN</span><br><span class="line">kubectl create secret tls $BK_DOMAIN -n blueking --cert=$HOME/$BK_DOMAIN/$BK_DOMAIN.pem --key=$HOME/$BK_DOMAIN/$BK_DOMAIN.key</span><br><span class="line">————————————————</span><br><span class="line">本文链接：https://blazehu.com/2024/05/24/devops/landun_install/</span><br><span class="line">版权声明： 本博客所有文章除特别声明外，均采用 CC BY 4.0 CN协议 许可协议。转载请注明出处！</span><br></pre></td></tr></table></figure>

<h2 id="5-3-更新-Ingress-TLS"><a href="#5-3-更新-Ingress-TLS" class="headerlink" title="5.3 更新 Ingress TLS"></a>5.3 更新 Ingress TLS</h2><p>在证书及证书secret准备好之后，需要变更蓝鲸系列ingress开启tls的支持，执行对应的脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置变量</span></span><br><span class="line">NAMESPACE=&quot;blueking&quot;</span><br><span class="line">DOMAIN_FILE=&quot;environments/default/custom.yaml&quot;</span><br><span class="line">BK_DOMAIN=$(yq e &#x27;.domain.bkDomain&#x27; &quot;$DOMAIN_FILE&quot;)  # 从配置文件中读取域名</span><br><span class="line">TLS_HOST=&quot;*.$BK_DOMAIN&quot;  # 泛域名</span><br><span class="line">TLS_SECRET=&quot;$BK_DOMAIN&quot;  # Secret 名称与域名一致</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查域名和 Secret 是否正确</span></span><br><span class="line">if [[ -z &quot;$BK_DOMAIN&quot; ]]; then</span><br><span class="line">  echo &quot;Error: BK_DOMAIN is not set in $DOMAIN_FILE.&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取命名空间中的所有 Ingress 资源</span></span><br><span class="line">ingresses=$(kubectl get ingress -n &quot;$NAMESPACE&quot; -o jsonpath=&#x27;&#123;.items[*].metadata.name&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">遍历所有 Ingress 资源并更新 TLS 配置</span></span><br><span class="line">for ingress in $ingresses; do</span><br><span class="line">  echo &quot;Updating Ingress: $ingress in namespace: $NAMESPACE&quot;</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">检查 Ingress 是否已存在 TLS 配置</span></span><br><span class="line">  if kubectl get ingress &quot;$ingress&quot; -n &quot;$NAMESPACE&quot; -o jsonpath=&#x27;&#123;.spec.tls&#125;&#x27; | grep -q &quot;$TLS_HOST&quot;; then</span><br><span class="line">    echo &quot;TLS configuration for $TLS_HOST already exists in Ingress $ingress. Skipping.&quot;</span><br><span class="line">    continue</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">更新 Ingress 的 TLS 配置</span></span><br><span class="line">  kubectl patch ingress &quot;$ingress&quot; -n &quot;$NAMESPACE&quot; --type=json -p=&#x27;[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;op&quot;: &quot;add&quot;,</span><br><span class="line">      &quot;path&quot;: &quot;/spec/tls&quot;,</span><br><span class="line">      &quot;value&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;hosts&quot;: [&quot;&#x27;&quot;$TLS_HOST&quot;&#x27;&quot;],</span><br><span class="line">          &quot;secretName&quot;: &quot;&#x27;&quot;$TLS_SECRET&quot;&#x27;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]&#x27; || &#123; echo &quot;Failed to update Ingress $ingress&quot;; exit 1; &#125;</span><br><span class="line"></span><br><span class="line">  echo &quot;Updated Ingress $ingress with TLS configuration for $TLS_HOST.&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;All Ingress resources in namespace $NAMESPACE have been updated with TLS configuration for $TLS_HOST.&quot;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-配置蓝鲸启用HTTPS"><a href="#5-4-配置蓝鲸启用HTTPS" class="headerlink" title="5.4 配置蓝鲸启用HTTPS"></a>5.4 配置蓝鲸启用HTTPS</h2><p>在git仓库维护，主要有两个变更：</p>
<p>environments&#x2F;default&#x2F;custom.yaml: .bkDomainScheme 值设置为 https<br>environments&#x2F;default&#x2F;bkci&#x2F;bkci-custom-values.yaml.gotmpl: .config.bkHttpSchema 值设置为 https</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yq -i &#x27;.bkDomainScheme = &quot;https&quot;&#x27; environments/default/custom.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将bkHttpSchema: https替换为bkHttpSchema: http</span></span><br><span class="line">sed -i &#x27;s|bkHttpSchema: http|bkHttpSchema: https|&#x27; environments/default/bkci/bkci-custom-values.yaml.gotmpl</span><br></pre></td></tr></table></figure>

<h2 id="5-5-构建机Agent配置变更及重启"><a href="#5-5-构建机Agent配置变更及重启" class="headerlink" title="5.5 构建机Agent配置变更及重启"></a>5.5 构建机Agent配置变更及重启</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止agent服务</span></span><br><span class="line">./stop.sh</span><br><span class="line"></span><br><span class="line">BK_DOMAIN=&quot;deveops.bk.blazehu.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改.agent.properties文件，开启https</span></span><br><span class="line">sed -i &#x27;&#x27; &#x27;s|http://$BK_DOMAIN|https://$BK_DOMAIN|g&#x27; .agent.properties</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改telegraf.conf文件，开启https</span></span><br><span class="line">sed -i &#x27;&#x27; &#x27;s|http://$BK_DOMAIN|https://$BK_DOMAIN|g&#x27; telegraf.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动agent</span></span><br><span class="line">./start.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里需要注意，仔细查看.agent.properties里devops.agent.user， 这里是哪个用户就用哪个用户启动agent</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>集群接入dashboard</title>
    <url>/2025/07/kubernetes/%E9%9B%86%E7%BE%A4%E6%8E%A5%E5%85%A5dashboard/</url>
    <content><![CDATA[<h1 id="1-Kubernets-Dashboard安装"><a href="#1-Kubernets-Dashboard安装" class="headerlink" title="1 Kubernets Dashboard安装"></a>1 Kubernets Dashboard安装</h1><p>下载kubernetes-dashboard的yaml:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml -O dashboard.yaml</span><br></pre></td></tr></table></figure>

<p>在官方yaml里，我们需要将镜像修改一下，不然会遇见ImagePullBackOff的错误：</p>
<ul>
<li>kubernetesui&#x2F;dashboard:v2.7.0</li>
<li>kubernetesui&#x2F;metrics-scraper:v1.0.8</li>
<li>备注：版本可能不同，认准镜像名</li>
</ul>
<p>将以上镜像修改为可用的：</p>
<ul>
<li>m.daocloud.io&#x2F;docker.io&#x2F;kubernetesui&#x2F;dashboard:v2.7.0</li>
<li>m.daocloud.io&#x2F;docker.io&#x2F;kubernetesui&#x2F;metrics-scraper:v1.0.8</li>
</ul>
<p>安装dashboard：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ./dashboard.yaml</span><br></pre></td></tr></table></figure>

<p>验证操作界面已经部署并且正在运行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kubectl get pod -n kubernetes-dashboard</span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">dashboard-metrics-scraper-864c58f57b-fjlfs   1/1     Running   0          98s</span><br><span class="line">kubernetes-dashboard-58db7bd7d4-pdh76        1/1     Running   0          98s</span><br></pre></td></tr></table></figure>

<p>创建 ServiceAccount 和 ClusterRoleBinding 以提供对新创建的集群的管理权限访问:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount -n kubernetes-dashboard admin-user</span><br><span class="line">kubectl create clusterrolebinding -n kubernetes-dashboard admin-user --clusterrole cluster-admin --serviceaccount=kubernetes-dashboard:admin-user</span><br></pre></td></tr></table></figure>

<p>需要用 Bearer Token 来登录到操作界面。使用以下命令将 token 保存到变量:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kubectl -n kubernetes-dashboard create token admin-user</span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6InF3b1ZJN0ZVSWUyRkF4blgxVG42d2hVMm0wTGtoSTg3VkVoai1yRTdMN3MifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNzI3OTc0NzYyLCJpYXQiOjE3Mjc5NzExNjIsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwianRpIjoiZTI2YjE1NjctYjk5YS00ZGRlLTlmMWUtYTIwYmUzZDAwZGJiIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhZG1pbi11c2VyIiwidWlkIjoiNWMxYjMyMmUtNDFmNS00ODcxLTkxNjQtZTYzOTk2NzkxZDM4In19LCJuYmYiOjE3Mjc5NzExNjIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlcm5ldGVzLWRhc2hib2FyZDphZG1pbi11c2VyIn0.d-b12OQrq_9BnmWz5g-_2nvRS-ktEhg813N8zb-kWBh5GScUHhuiAej2v1p1kt54Xom1H6DaeyvlmL3G8ub7aKgZwJjOyJBFDnt0B04Ysz-KSj788jR_Yg2d1FhTbgk8-pBdV9qSweBVT6GRyQ53NIsTIc5ArDsvfOg66nEiW9rp5-3XLitKpoSLtp_Dpib1VpOR_1XAV8wRNVc9psxOp3vtALs1_jI0Izo_4qOX17OZ9FnxgkeeKglRFynlgGiQ0g2KG74oYQn0b_sUROvb52cdDJ2RDhk4yao2vjMyg19f_x1gK-xM8O7kgfYkA8gXEzguRMl0OEbWP_UgH0RQqA</span><br></pre></td></tr></table></figure>

<p>使用 kubectl 命令行工具运行以下命令以访问操作界面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure>

<p>进入dashboard：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</span><br></pre></td></tr></table></figure>

<p><img src="/img.png" alt="img.png"><br><img src="/img_1.png" alt="img_1.png"></p>
<p>这里是用kubectl proxy起了一个代理，实现在集群外访问集群内的dashboard</p>
]]></content>
  </entry>
  <entry>
    <title>BK-CI插件开发指引</title>
    <url>/2025/07/devops/blueking/BK-CI%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8C%87%E5%BC%95/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>开发插件前，先进入插件工作台初始化一个插件，确定插件在平台中的唯一标识</p>
</blockquote>
<h1 id="工作台"><a href="#工作台" class="headerlink" title="工作台"></a>工作台</h1><p>可以在这里进行新增&#x2F;发布&#x2F;下架等管理插件的操作</p>
<h2 id="功能区介绍"><a href="#功能区介绍" class="headerlink" title="功能区介绍"></a>功能区介绍</h2><p><img src="/img.png" alt="img.png"></p>
<ol>
<li>切换资源类型</li>
<li>新增插件</li>
<li>单个插件的管理入口</li>
<li>升级、下架、删除插件快捷入口</li>
<li>指引文档和插件 UI 调试工具入口</li>
</ol>
<h2 id="新增插件"><a href="#新增插件" class="headerlink" title="新增插件"></a>新增插件</h2><p><img src="/img_1.png" alt="img_1.png"></p>
<ol>
<li>标识</li>
</ol>
<ul>
<li>插件在平台中的唯一标识，建议取和插件功能相关的可读性好的英文标识</li>
</ul>
<ol start="2">
<li>调试项目</li>
</ol>
<ul>
<li>插件发布过程中，可以在调试项目下将插件添加到流水线执行，对插件进行测试，保证插件功能满足预期。</li>
<li>建议新增专用的插件调试项目，避免测试过程中影响到业务。</li>
</ul>
<ol start="3">
<li>开发语言</li>
</ol>
<ul>
<li>支持四种语言开发插件：<ul>
<li>Java（推荐）</li>
<li>Python</li>
<li>Golang</li>
<li>Nodejs</li>
</ul>
</li>
</ul>
<h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h2><blockquote>
<p>初始化好插件之后，可以开始开发插件</p>
</blockquote>
<ul>
<li>根据开发语言参考对应的开发指引<ul>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/java.md">Java 插件开发指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/python.md">Python 插件开发指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/golang.md">Golang 插件开发指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-guide/nodejs.md">Nodejs 插件开发指引</a></li>
</ul>
</li>
</ul>
<h2 id="插件私有配置"><a href="#插件私有配置" class="headerlink" title="插件私有配置"></a>插件私有配置</h2><blockquote>
<p>插件级别的敏感信息，如 token、用户名密码、IP、域名等，不建议直接提交到代码库，通过工作台私有配置界面管理</p>
</blockquote>
<p><img src="/img_2.png" alt="img_2.png"></p>
<h1 id="Golang-插件开发"><a href="#Golang-插件开发" class="headerlink" title="Golang 插件开发"></a>Golang 插件开发</h1><h2 id="插件开发框架说明"><a href="#插件开发框架说明" class="headerlink" title="插件开发框架说明"></a>插件开发框架说明</h2><blockquote>
<p>插件最终打包成一个命令行可执行的命令即可，对开发框架无硬性要求 下边以 demo 插件为例示范</p>
</blockquote>
<h2 id="示例插件代码工程的整体结构如下"><a href="#示例插件代码工程的整体结构如下" class="headerlink" title="示例插件代码工程的整体结构如下"></a>示例插件代码工程的整体结构如下</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|- &lt;你的插件标识&gt;</span><br><span class="line">    |- cmd</span><br><span class="line">        |- application</span><br><span class="line">            |- main.go</span><br><span class="line"></span><br><span class="line">    |- hello</span><br><span class="line">        |- hello.go</span><br></pre></td></tr></table></figure>

<h2 id="如何开发插件："><a href="#如何开发插件：" class="headerlink" title="如何开发插件："></a>如何开发插件：</h2><blockquote>
<p>参考 <a href="https://github.com/ci-plugins/plugin-demo-golang">plugin-demo-golang</a></p>
</blockquote>
<ul>
<li>建插件代码工程<ul>
<li>插件代码建议企业下统一管理。 通用的开源插件可以联系蓝鲸官方放到 <a href="https://github.com/TencentBlueKing">TencentBlueKing</a> 下，供更多用户使用</li>
</ul>
</li>
<li>实现插件功能</li>
<li>规范：<ul>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-specification.md">插件开发规范</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-config.md">插件配置规范</a></li>
</ul>
</li>
<li>插件前端不仅可以通过 task.json 进行标准化配置，也可以自定义开发：<ul>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-custom-ui.md">自定义插件 UI 交互指引</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-output.md">插件输出规范</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/plugin-error-code.md">插件错误码规范</a></li>
<li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Developer/plugins/plugin-dev-standard/release.md">插件发布包规范</a></li>
</ul>
</li>
</ul>
<h2 id="Demo示例研读"><a href="#Demo示例研读" class="headerlink" title="Demo示例研读"></a>Demo示例研读</h2><p>将 <a href="https://github.com/ci-plugins/plugin-demo-golang">plugin-demo-golang</a> clone到本地。<br>来看下项目结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── i18n</span><br><span class="line">│   ├── message_en_US.properties</span><br><span class="line">│   └── message_zh_CN.properties</span><br><span class="line">├── main.go</span><br><span class="line">├── task.json</span><br><span class="line">└── translation</span><br><span class="line">    └── translation.go</span><br><span class="line"></span><br><span class="line">3 directories, 11 files</span><br></pre></td></tr></table></figure>

<p>咦！和上面说的插件代码工程的整体架构不一样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|- &lt;你的插件标识&gt;</span><br><span class="line">    |- cmd</span><br><span class="line">        |- application</span><br><span class="line">            |- main.go</span><br><span class="line"></span><br><span class="line">    |- hello</span><br><span class="line">        |- hello.go</span><br></pre></td></tr></table></figure>

<p>不过，这不重要，只要插件最终能够打包成一个命令行可执行的命令即可。<br>这里i18n是实现中英文国际化使用的，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── i18n</span><br><span class="line">│   ├── message_en_US.properties</span><br><span class="line">│   └── message_zh_CN.properties</span><br></pre></td></tr></table></figure>

<p>看下内容对比：<br>message_en_US.properties：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input.desc.label=desc</span><br><span class="line">100001=input param [&#123;0&#125;] invitated</span><br></pre></td></tr></table></figure>

<p>message_zh_CN.properties</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input.desc.label=描述</span><br><span class="line">100001=输入参数[&#123;0&#125;]非法</span><br></pre></td></tr></table></figure>

<p>那我们就可以猜测，这里是实现输入参数[{0}]非法这句话的中英文，其中[{0}]会使用具体的参数填充。<br>然后i18ngenerator则是根据properties文件的配置，生成translation代码，如translation.go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code generated by &quot;i18ngenerator&quot;; DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> translation</span><br><span class="line"></span><br><span class="line"><span class="comment">// Translations</span></span><br><span class="line"><span class="keyword">var</span> Translations <span class="keyword">map</span>[<span class="type">string</span>][][]<span class="type">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][][]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Translations[<span class="string">&quot;en-US&quot;</span>] = [][]<span class="type">string</span>&#123;</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;100001&quot;</span>,</span><br><span class="line">          <span class="string">&quot;input param [&#123;0&#125;] invitated&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;input.desc.label&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    Translations[<span class="string">&quot;zh-CN&quot;</span>] = [][]<span class="type">string</span>&#123;</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;100001&quot;</span>,</span><br><span class="line">          <span class="string">&quot;输入参数[&#123;0&#125;]非法&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="string">&quot;input.desc.label&quot;</span>,</span><br><span class="line">          <span class="string">&quot;描述&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该文件是由i18ngenerator自动生成的，不要自己改。<br>main函数内，实现了一个小的输出功能，简单看下源码，然后去进行测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/ci-plugins/golang-plugin-sdk/api&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ci-plugins/golang-plugin-sdk/log&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ci-plugins/plugin-demo-golang/translation&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate i18ngenerator i18n ./translation/translation.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> greetingParam <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserName <span class="type">string</span> <span class="string">`json:&quot;userName&quot;`</span></span><br><span class="line">    Greeting <span class="type">string</span> <span class="string">`json:&quot;greeting&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *greetingParam)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;userName: %v, greeting: %v&quot;</span>, a.UserName, a.Greeting)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">4</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;atom-demo-glang starts&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Error(<span class="string">&quot;panic: &quot;</span>, err)</span><br><span class="line">          api.FinishBuild(api.StatusError, <span class="string">&quot;panic occurs&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    api.InitI18n(translation.Translations, api.GetRuntimeLanguage())</span><br><span class="line">    msg, err := api.Localize(<span class="string">&quot;input.desc.label&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.Error(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Info(msg)</span><br><span class="line"></span><br><span class="line">    helloBuild()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloBuild</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取单个输入参数</span></span><br><span class="line">    userName := api.GetInputParam(<span class="string">&quot;userName&quot;</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;userName: &quot;</span>, userName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打屏</span></span><br><span class="line">    log.Info(<span class="string">&quot;\nBuildInfo:&quot;</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;Project Name:     &quot;</span>, api.GetProjectDisplayName())</span><br><span class="line">    log.Info(<span class="string">&quot;Pipeline Id:      &quot;</span>, api.GetPipelineId())</span><br><span class="line">    log.Info(<span class="string">&quot;Pipeline Name:    &quot;</span>, api.GetPipelineName())</span><br><span class="line">    log.Info(<span class="string">&quot;Pipeline Version: &quot;</span>, api.GetPipelineVersion())</span><br><span class="line">    log.Info(<span class="string">&quot;Build Id:         &quot;</span>, api.GetPipelineBuildId())</span><br><span class="line">    log.Info(<span class="string">&quot;Build Num:        &quot;</span>, api.GetPipelineBuildNumber())</span><br><span class="line">    log.Info(<span class="string">&quot;Start Type:       &quot;</span>, api.GetPipelineStartType())</span><br><span class="line">    log.Info(<span class="string">&quot;Start UserId:     &quot;</span>, api.GetPipelineStartUserId())</span><br><span class="line">    log.Info(<span class="string">&quot;Start UserName:   &quot;</span>, api.GetPipelineStartUserName())</span><br><span class="line">    log.Info(<span class="string">&quot;Start Time:       &quot;</span>, api.GetPipelineStartTimeMills())</span><br><span class="line">    log.Info(<span class="string">&quot;Workspace:        &quot;</span>, api.GetWorkspace())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入参数解析到对象</span></span><br><span class="line">    paramData := <span class="built_in">new</span>(greetingParam)</span><br><span class="line">    api.LoadInputParam(paramData)</span><br><span class="line">    log.Info(fmt.Sprintf(<span class="string">&quot;\n%v，%v\n&quot;</span>, paramData.Greeting, paramData.UserName))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    log.Info(<span class="string">&quot;start build&quot;</span>)</span><br><span class="line">    build()</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 字符串输出</span></span><br><span class="line">    strData := api.NewStringData(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    api.AddOutputData(<span class="string">&quot;strData_01&quot;</span>, strData)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件归档输出</span></span><br><span class="line">    artifactData := api.NewArtifactData()</span><br><span class="line">    artifactData.AddArtifact(<span class="string">&quot;result.dat&quot;</span>)</span><br><span class="line">    api.AddOutputData(<span class="string">&quot;artifactData_02&quot;</span>, artifactData)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报告输出</span></span><br><span class="line">    reportData := api.NewReportData(<span class="string">&quot;label_01&quot;</span>, api.GetWorkspace()+<span class="string">&quot;/report&quot;</span>, <span class="string">&quot;report.htm&quot;</span>)</span><br><span class="line">    api.AddOutputData(<span class="string">&quot;report_01&quot;</span>, reportData)</span><br><span class="line"></span><br><span class="line">    api.WriteOutput()</span><br><span class="line">    log.Info(<span class="string">&quot;build done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Info(<span class="string">&quot;write result.dat&quot;</span>)</span><br><span class="line">    ioutil.WriteFile(api.GetWorkspace()+<span class="string">&quot;/result.dat&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;content&quot;</span>), <span class="number">0644</span>)</span><br><span class="line">    log.Info(<span class="string">&quot;write report.htm&quot;</span>)</span><br><span class="line">    os.Mkdir(api.GetWorkspace()+<span class="string">&quot;/report&quot;</span>, os.ModePerm)</span><br><span class="line">    ioutil.WriteFile(api.GetWorkspace()+<span class="string">&quot;/report/report.htm&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Report&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;This is a Report&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>), <span class="number">0644</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在根目录下已经给我们预设了一个task.json文件，后面可以简单修改下这个文件来实现测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;atomCode&quot;</span>: <span class="string">&quot;goDemo&quot;</span>,</span><br><span class="line">  <span class="string">&quot;execution&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;language&quot;</span>: <span class="string">&quot;golang&quot;</span>,</span><br><span class="line">    <span class="string">&quot;packagePath&quot;</span>: <span class="string">&quot;goDemo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;demands&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;chmod +x goDemo&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;./goDemo&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;input&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;greeting&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;label&quot;</span>: <span class="string">&quot;欢迎词&quot;</span>,</span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;Glad to see you&quot;</span>,</span><br><span class="line">      <span class="string">&quot;placeholder&quot;</span>: <span class="string">&quot;欢迎词&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;vuex-input&quot;</span>,</span><br><span class="line">      <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;欢迎词&quot;</span>,</span><br><span class="line">      <span class="string">&quot;required&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;disabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;isSensitive&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;userName&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;label&quot;</span>: <span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;Mr. Huang&quot;</span>,</span><br><span class="line">      <span class="string">&quot;placeholder&quot;</span>: <span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;vuex-input&quot;</span>,</span><br><span class="line">      <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">      <span class="string">&quot;required&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;disabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;isSensitive&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;output&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;strData_01&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;测试&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="string">&quot;isSensitive&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何打包发布"><a href="#如何打包发布" class="headerlink" title="如何打包发布"></a>如何打包发布</h2><ol>
<li>进入插件代码工程目录下</li>
<li>打包</li>
</ol>
<ul>
<li>如果按照正常的demo的目录结构是需要进入cmd&#x2F;application内执行build命令，因为main在此</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd cmd/application</span><br><span class="line">GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/$&#123;executable&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这次用的demo则直接在根目录下执行build命令，因为main在根目录下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/$&#123;executable&#125;</span><br></pre></td></tr></table></figure>

<p>这里go build -o bin&#x2F;${executable}会在bin目录下，生成可执行文件，文件名是${executable}，即项目名。<br>也可以自定义一个名字，如<code>GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/kingtest</code></p>
<ol>
<li>在任意位置新建文件夹，命名示例：release_pkg &#x3D; &lt;你的插件标识&gt;_release</li>
<li>将步骤 2 生产的执行包拷贝到 下</li>
<li>添加 task.json 文件到 下 task.json 见示例，按照插件功能配置。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir kingtest_release</span><br><span class="line">cp bin/kingtest kingtest_release/kingtest</span><br><span class="line">touch kingtest_release/task.json</span><br></pre></td></tr></table></figure>

<ul>
<li>插件配置规范</li>
<li>task.json 示例：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;atomCode&quot;: &quot;king-test&quot;,                  # atomCode 要与工作台录入的一致</span><br><span class="line">  &quot;execution&quot;: &#123;</span><br><span class="line">    &quot;language&quot;: &quot;golang&quot;,</span><br><span class="line">    &quot;packagePath&quot;: &quot;kingtest&quot;,              # 发布包中插件安装包的相对路径</span><br><span class="line">    &quot;demands&quot;: [</span><br><span class="line">      &quot;echo start run chmod +x kingtest&quot;,   # 插件启动前需要执行的安装命令，顺序执行</span><br><span class="line">      &quot;chmod +x kingtest&quot;,                  # 插件启动前需要执行的安装命令，顺序执行</span><br><span class="line">      &quot;echo stop run chmod +x kingtest&quot;,    # 插件启动前需要执行的安装命令，顺序执行</span><br><span class="line">    ],</span><br><span class="line">    &quot;target&quot;: &quot;./kingtest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;input&quot;: &#123;</span><br><span class="line">    &quot;greeting&quot;: &#123;</span><br><span class="line">      &quot;label&quot;: &quot;欢迎词&quot;,</span><br><span class="line">      &quot;default&quot;: &quot;Glad to see you&quot;,</span><br><span class="line">      &quot;placeholder&quot;: &quot;欢迎词&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;vuex-input&quot;,</span><br><span class="line">      &quot;desc&quot;: &quot;欢迎词&quot;,</span><br><span class="line">      &quot;required&quot;: true,</span><br><span class="line">      &quot;disabled&quot;: false,</span><br><span class="line">      &quot;hidden&quot;: false,</span><br><span class="line">      &quot;isSensitive&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;userName&quot;: &#123;</span><br><span class="line">      &quot;label&quot;: &quot;姓名&quot;,</span><br><span class="line">      &quot;default&quot;: &quot;Mr. Huang&quot;,</span><br><span class="line">      &quot;placeholder&quot;: &quot;姓名&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;vuex-input&quot;,</span><br><span class="line">      &quot;desc&quot;: &quot;姓名&quot;,</span><br><span class="line">      &quot;required&quot;: true,</span><br><span class="line">      &quot;disabled&quot;: false,</span><br><span class="line">      &quot;hidden&quot;: false,</span><br><span class="line">      &quot;isSensitive&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;output&quot;: &#123;</span><br><span class="line">    &quot;strData_01&quot;: &#123;</span><br><span class="line">      &quot;description&quot;: &quot;测试&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">      &quot;isSensitive&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 目录下，把所有文件打成 zip 包即可</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd kingtest_release &amp;&amp; zip kingtest_release.zip kingtest task.json</span><br></pre></td></tr></table></figure>

<p>zip包结构示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|- kingtest_release.zip         # 发布包</span><br><span class="line">   |- kingtest                  # 插件执行包</span><br><span class="line">   |- task.json                 # 插件配置文件</span><br></pre></td></tr></table></figure>

<p>打包完成后，在插件工作台提单发布，即可测试或发布插件</p>
<h1 id="上传一个流水线插件"><a href="#上传一个流水线插件" class="headerlink" title="上传一个流水线插件"></a>上传一个流水线插件</h1><blockquote>
<p>开发好插件之后，通过研发商店工作台，将插件发布到研发商店，提供给用户添加到流水线中使用。</p>
</blockquote>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>在工作台列表，点击如下入口发起发布流程：<br><img src="/img_3.png" alt="img_3.png"></p>
<p>首次发布时，入口名为上架<br>后续更新版本时，入口名为升级<br>或者在插件发布管理-&gt;版本管理界面发起发布流程：<br><img src="/img_4.png" alt="img_4.png"></p>
<h2 id="填写插件相关信息-上传插件发布包"><a href="#填写插件相关信息-上传插件发布包" class="headerlink" title="填写插件相关信息&#x2F;上传插件发布包"></a>填写插件相关信息&#x2F;上传插件发布包</h2><p>上架&#x2F;升级插件时，可以修改插件的基本信息，如下所示：<br><img src="/img_5.png" alt="img_5.png"></p>
<ol>
<li>适用 Job 类型：</li>
</ol>
<ul>
<li>和流水线 Job 类型对应，请按照插件实际适用情况选择</li>
<li>若选错，需新增版本修改</li>
</ul>
<ol start="2">
<li>发布包：</li>
</ol>
<ul>
<li>task.json 中的 atomCode 需和 新增插件时填写的标识一致，否则上传会失败</li>
</ul>
<h2 id="测试-发布插件"><a href="#测试-发布插件" class="headerlink" title="测试&#x2F;发布插件"></a>测试&#x2F;发布插件</h2><blockquote>
<p>填写好信息，提交后，进入发布流程，可以测试-&gt;重新传包-&gt;测试，直至插件满足预期后，手动继续流程将插件发布到研发商店</p>
</blockquote>
<p><img src="/img_6.png" alt="img_6.png"></p>
<ol>
<li>测试：点击后跳转到插件调试项目的流水线服务下，可以将当前插件添加到流水线，验证 UI、功能是否满足预期</li>
<li>重新传包：当测试发现问题，修复后，重新上传发布包，再次进行测试</li>
<li>继续：测试 OK，满足预期后，确认提交发布</li>
<li>取消发布：发布过程中，随时可以终止发布</li>
</ol>
<h2 id="遇见的几个错误"><a href="#遇见的几个错误" class="headerlink" title="遇见的几个错误"></a>遇见的几个错误</h2><h3 id="无权限执行"><a href="#无权限执行" class="headerlink" title="无权限执行"></a>无权限执行</h3><p>在测试中遇见一个问题：无权限执行<br><img src="/img_7.png" alt="img_7.png"></p>
<p>在<code>execution-&gt;demands</code>增加一个命令<code>chmod +x kingtest</code>即可解决</p>
<h3 id="发布进度里重新传包持续报错task-json格式错误"><a href="#发布进度里重新传包持续报错task-json格式错误" class="headerlink" title="发布进度里重新传包持续报错task.json格式错误"></a>发布进度里重新传包持续报错task.json格式错误</h3><p>还有个问题，在发布进度里重新传包时，一直报错task.json格式错误，但实际格式是对的！<br>触发的原因暂不知道，但是确实是一个隐藏的bug。<br><img src="/img_8.png" alt="img_8.png"></p>
<p>直接点击继续，然后走升级插件的方式可以正常使用。</p>
<h3 id="cannot-execute-binary-file-Exec-format-error"><a href="#cannot-execute-binary-file-Exec-format-error" class="headerlink" title="cannot execute binary file: Exec format error"></a>cannot execute binary file: Exec format error</h3><p>这里的问题是我造成的，最初我在mac环境下编译的可执行文件，命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mac下执行</span></span><br><span class="line">go build -o bin/kingtest</span><br></pre></td></tr></table></figure>

<p>但是插件里选择的编译环境是linux。<br><img src="/img_9.png" alt="img_9.png"></p>
<p>解决方式：让插件选择的编译环境和可执行文件的平台统一。<br>我这里选择重新编译下可执行文件，采用在mac平台交叉编译linux平台可执行文件的方式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GO111MODULE=on GOOS=linux GOARCH=amd64 go build -o bin/kingtest</span><br></pre></td></tr></table></figure>

<p>也可以新建一个插件，编译环境选择mac。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>流水线结果：<br><img src="/img_10.png" alt="img_10.png"></p>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Plugin info]</span><br><span class="line">=====================================================================</span><br><span class="line">Task           : king-test</span><br><span class="line">Description    : bk插件测试</span><br><span class="line">Version        : 1.0.3</span><br><span class="line">Author         : huari</span><br><span class="line">Help           : More Information</span><br><span class="line">=====================================================================</span><br><span class="line">-----</span><br><span class="line">[Input]</span><br><span class="line">input(normal): (欢迎词)greeting=Glad to see you</span><br><span class="line">input(normal): (姓名)userName=Mr. Huang</span><br><span class="line">-----</span><br><span class="line">[Install plugin]</span><br><span class="line">-----</span><br><span class="line">start run chmod +x kingtest</span><br><span class="line">stop run chmod +x kingtest</span><br><span class="line">atom-demo-glang starts</span><br><span class="line">描述</span><br><span class="line">userName:  Mr. Huang</span><br><span class="line"></span><br><span class="line">BuildInfo:</span><br><span class="line">Project Name:      GOPS</span><br><span class="line">Pipeline Id:       p-8967ed52b08847c8a5b0140937db0975</span><br><span class="line">Pipeline Name:     king-test</span><br><span class="line">Pipeline Version:  11</span><br><span class="line">Build Id:          b-78947b5c39f34b32bbafb803042d1e22</span><br><span class="line">Build Num:         15</span><br><span class="line">Start Type:        MANUAL</span><br><span class="line">Start UserId:      huari</span><br><span class="line">Start UserName:    huari</span><br><span class="line">Start Time:        1733298107286</span><br><span class="line">Workspace:         /data/devops/workspace</span><br><span class="line"></span><br><span class="line">Glad to see you，Mr. Huang</span><br><span class="line">start build</span><br><span class="line">write result.dat</span><br><span class="line">write report.htm</span><br><span class="line">build done</span><br><span class="line">[Output]</span><br><span class="line">1 file match: </span><br><span class="line">  /data/devops/workspace/result.dat</span><br><span class="line">prepare to upload 7 B</span><br><span class="line">1/1 file(s) finished</span><br><span class="line">output(except): artifactData_02=result.dat</span><br><span class="line">入口文件检测完成</span><br><span class="line">上传自定义产出物成功，共产生了1个文件</span><br><span class="line">output(except): report_01=report.htm</span><br><span class="line">output(normal): strData_01=test</span><br><span class="line">-----</span><br><span class="line"></span><br></pre></td></tr></table></figure>






]]></content>
  </entry>
  <entry>
    <title>NPD介绍</title>
    <url>/2025/07/devops/npd/NPD%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>官方文档库地址：<a href="https://github.com/kubernetes/node-problem-detector">https://github.com/kubernetes/node-problem-detector</a></p>
<p>node-problem-detector 旨在使集群管理堆栈中的上游层能够看到各种节点问题。</p>
<p>它是一个在每个节点上运行的守护进程，检测节点问题并将其报告给apiserver。</p>
<p>node-problem-detector 可以作为 DaemonSet 运行，也可以独立运行。</p>
<p>现在它作为 GKE集群中默认启用的Kubernetes Addon运行。它也作为AKS Linux Extension的一部分在 AKS 中默认启用。</p>
<h2 id="1-2-背景"><a href="#1-2-背景" class="headerlink" title="1.2 背景"></a>1.2 背景</h2><p>大量节点问题可能会影响节点上运行的 pod，例如：</p>
<ul>
<li>基础设施守护进程问题：ntp 服务关闭；</li>
<li>硬件问题：CPU、内存或磁盘损坏；</li>
<li>内核问题：内核死锁、文件系统损坏；</li>
<li>容器运行时问题：运行时守护进程无响应；</li>
<li>…</li>
</ul>
<p>目前，这些问题对于集群管理堆栈中的上游层是不可见的，因此 Kubernetes 将继续将 pod 调度到坏节点。<br>为了解决这个问题，我们引入了这个新的守护进程node-problem-detector来从各种守护进程收集节点问题，并将它们提供给上游层。一旦上游层能够看到这些问题，我们就可以讨论 <a href="https://github.com/kubernetes/node-problem-detector?tab=readme-ov-file#remedy-systems">remedy systems</a>了。</p>
<h2 id="1-3-Problem-API"><a href="#1-3-Problem-API" class="headerlink" title="1.3 Problem API"></a>1.3 Problem API</h2><p>node-problem-detector 使用Event并向NodeConditionapiserver 报告问题。</p>
<ul>
<li>NodeCondition：导致节点无法用于 pod 的永久性问题应报告为NodeCondition。</li>
<li>Event：对 pod 影响有限但具有参考意义的临时问题应报告为Event。</li>
</ul>
<h2 id="1-4-Problem-Daemon"><a href="#1-4-Problem-Daemon" class="headerlink" title="1.4 Problem Daemon"></a>1.4 Problem Daemon</h2><p>问题守护进程是 node-problem-detector 的一个子守护进程。它监视特定类型的节点问题并将其报告给 node-problem-detector。<br>守护进程可能是：</p>
<ul>
<li>专为 Kubernetes 专用用例设计的微型守护进程。</li>
<li>与节点问题检测器集成的现有节点健康监控守护进程。</li>
</ul>
<p>目前，问题守护进程在 node-problem-detector 二进制文件中以 goroutine 的形式运行。</p>
<p>未来，我们会将 node-problem-detector和问题守护进程分离到不同的容器中，并使用 pod 规范将它们组合在一起。</p>
<p>每种类型的问题守护进程都可以通过设置相应的构建标签在编译时禁用。</p>
<p>如果在编译时禁用它们，则它们的所有构建依赖项、全局变量和后台goroutine 都将从编译的可执行文件中剔除。</p>
<p>支持的守护进程列表：</p>
<table>
<thead>
<tr>
<th>问题守护进程类型</th>
<th>节点状态</th>
<th>解释</th>
<th>配置</th>
<th>禁用构建标签</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/systemlogmonitor">SystemLogMonitor</a></td>
<td>KernelDeadlock ReadonlyFilesystem FrequentKubeletRestart FrequentDockerRestart FrequentContainerdRestart</td>
<td>系统日志监视器监视系统日志并根据预定义的规则报告问题和指标。</td>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor-filelog.json">filelog</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor.json">kmsg</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor-counter.json">kernel</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/systemd-monitor-counter.json">abrt</a>, <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/systemd-monitor-counter.json">systemd</a></td>
<td>disable_system_log_monitor</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/systemstatsmonitor">SystemStatsMonitor</a></td>
<td>None(Could be added in the future)</td>
<td>节点问题检测器的系统统计监视器，用于收集各种与健康相关的系统统计信息作为指标。请参阅<a href="https://docs.google.com/document/d/1SeaUz6kBavI283Dq8GBpoEUDrHA2a795xtw0OvjM568/edit">此处</a>的提案。</td>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/system-stats-monitor.json">system-stats-monitor</a></td>
<td>disable_system_stats_monitor</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/custompluginmonitor">CustomPluginMonitor</a></td>
<td>On-demand(According to users configuration), existing example: NTPProblem</td>
<td>一个自定义的 node-problem-detector 插件监控器，用于调用和检查各种节点问题，并使用用户定义的检查脚本。请参阅<a href="https://docs.google.com/document/d/1jK_5YloSYtboj-DtfjmYKxfNnUxCAvohLnsH5aGCAYQ/edit#">此处</a>的提案。</td>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/4ad49bbd84b8ced45ac825eac01ec93d9235935e/config/custom-plugin-monitor.json">example</a></td>
<td>disable_custom_plugin_monitor</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/healthchecker">HealthChecker</a></td>
<td>KubeletUnhealthy ContainerRuntimeUnhealthy</td>
<td>节点问题检测器的健康检查器用于检查 kubelet 和容器运行时的健康状况。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-5-Exporter"><a href="#1-5-Exporter" class="headerlink" title="1.5 Exporter"></a>1.5 Exporter</h2><p>exporter 是 node-problem-detector 的一个组件。</p>
<p>它向某些后端报告节点问题 和&#x2F;或 指标。</p>
<p>其中一些可以在编译时使用构建标记禁用。支持的导出器列表：</p>
<table>
<thead>
<tr>
<th>Exporter</th>
<th>解释</th>
<th>禁用构建标签</th>
</tr>
</thead>
<tbody><tr>
<td>Kubernetes exporter</td>
<td>Kubernetes 导出器向 Kubernetes API 服务器报告节点问题：临时问题报告为事件，永久问题报告为节点状况。</td>
<td></td>
</tr>
<tr>
<td>Prometheus exporter</td>
<td>Prometheus 导出器将节点问题和指标本地报告为 Prometheus 指标</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/exporter/stackdriver-exporter.json">Stackdriver exporter</a></td>
<td>Stackdriver 导出器向 Stackdriver Monitoring API 报告节点问题和指标。</td>
<td>disable_stackdriver_exporter</td>
</tr>
</tbody></table>
<h2 id="1-6-用法"><a href="#1-6-用法" class="headerlink" title="1.6 用法"></a>1.6 用法</h2><h3 id="1-6-1-标志"><a href="#1-6-1-标志" class="headerlink" title="1.6.1 标志"></a>1.6.1 标志</h3><ul>
<li>–version：打印节点问题检测器的当前版本。</li>
<li>–hostname-override：node-problem-detector 用于更新状态和发出事件的自定义节点名称。node-problem-detector 首先从hostname-override获取节点名称，然后从NODE_NAME环境变量 获取，最后返回到os.Hostname。</li>
</ul>
<h3 id="1-6-2-对于系统日志监控"><a href="#1-6-2-对于系统日志监控" class="headerlink" title="1.6.2 对于系统日志监控"></a>1.6.2 对于系统日志监控</h3><ul>
<li>–config.system-log-monitor：系统日志监视器配置文件路径列表，以逗号分隔，例如 config&#x2F;kernel-monitor.json。节点问题检测器将为每个配置启动单独的日志监视器。您可以使用不同的日志监视器来监视不同的系统日志。</li>
</ul>
<h3 id="1-6-3-对于系统统计监控"><a href="#1-6-3-对于系统统计监控" class="headerlink" title="1.6.3 对于系统统计监控"></a>1.6.3 对于系统统计监控</h3><ul>
<li>–config.system-stats-monitor：系统统计监控配置文件的路径列表，以逗号分隔，例如 <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/system-stats-monitor.json">config&#x2F;system-stats-monitor.json</a>。节点问题检测器将为每个配置启动一个单独的系统统计监控器。您可以使用不同的系统统计监控器来监控与问题相关的不同系统统计信息。</li>
</ul>
<h3 id="1-6-4-对于自定义插件监视器"><a href="#1-6-4-对于自定义插件监视器" class="headerlink" title="1.6.4 对于自定义插件监视器"></a>1.6.4 对于自定义插件监视器</h3><ul>
<li>–config.custom-plugin-monitor：自定义插件监控配置文件路径列表，以逗号分隔，例如 <a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/custom-plugin-monitor.json">config&#x2F;custom-plugin-monitor.json</a>。节点问题检测器将为每个配置启动一个单独的自定义插件监控。您可以使用不同的自定义插件监控来监控不同的节点问题。</li>
</ul>
<h3 id="1-6-5-对于健康检查者"><a href="#1-6-5-对于健康检查者" class="headerlink" title="1.6.5 对于健康检查者"></a>1.6.5 对于健康检查者</h3><ul>
<li>–enable-k8s-exporter：启用向 Kubernetes API 服务器报告，默认为true。</li>
<li>–apiserver-override：用于自定义 node-problem-detector 如何连接 apiserver 的 URI 参数。如果–enable-k8s-exporter是，则忽略此参数。格式与<a href="https://github.com/kubernetes/heapster">Heapster</a> 的标志false相同。例如，要无需身份验证即可运行，请使用以下配置： <a href="https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md#kubernetes">source</a></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://APISERVER_IP:APISERVER_PORT?inClusterConfig=false</span><br></pre></td></tr></table></figure>

<p>请参阅<a href="https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md#kubernetes">heapster 文档</a><br>以获取可用选项的完整列表。</p>
<ul>
<li>–address：绑定节点问题检测服务器的地址。</li>
<li>–port：绑定节点问题检测服务器的端口。使用 0 表示禁用。</li>
</ul>
<h3 id="1-6-6-对于-Prometheus-exporter"><a href="#1-6-6-对于-Prometheus-exporter" class="headerlink" title="1.6.6 对于 Prometheus exporter"></a>1.6.6 对于 Prometheus exporter</h3><ul>
<li>–prometheus-address：绑定Prometheus抓取端点的地址，默认为127.0.0.1。</li>
<li>–prometheus-port：绑定 Prometheus 抓取端点的端口，默认为 20257。使用 0 表示禁用。</li>
</ul>
<h3 id="1-6-7-对于-Stackdriver-exporter"><a href="#1-6-7-对于-Stackdriver-exporter" class="headerlink" title="1.6.7 对于 Stackdriver exporter"></a>1.6.7 对于 Stackdriver exporter</h3><ul>
<li>–exporter.stackdriver：Stackdriver 导出器配置文件的路径，例如config&#x2F;exporter&#x2F;stackdriver-exporter.json，默认为空字符串。设置为空字符串即可禁用。</li>
</ul>
<h3 id="1-6-8-已弃用的标志"><a href="#1-6-8-已弃用的标志" class="headerlink" title="1.6.8 已弃用的标志"></a>1.6.8 已弃用的标志</h3><ul>
<li>–system-log-monitors：系统日志监控配置文件的路径列表，以逗号分隔。此选项已弃用，由–config.system-log-monitor替代，并将被删除。如果同时设置–system-log-monitors和 –config.system-log-monitor ， NPD 将崩溃。</li>
<li>–custom-plugin-monitors：自定义插件监控配置文件的路径列表，以逗号分隔。此选项已弃用，由–config.custom-plugin-monitor替代，并将被删除。如果同时设置–custom-plugin-monitors和 –config.custom-plugin-monitor，NPD 将崩溃。</li>
</ul>
<h2 id="1-7-构建镜像"><a href="#1-7-构建镜像" class="headerlink" title="1.7 构建镜像"></a>1.7 构建镜像</h2><ul>
<li>安装libsystemdARM GCC 工具链的开发依赖项<ul>
<li>Debian &#x2F; Ubuntu：apt install libsystemd-dev gcc-aarch64-linux-gnu</li>
</ul>
</li>
<li>git clone <a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109;">&#103;&#x69;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109;</a>:kubernetes&#x2F;node-problem-detector.git</li>
<li>在顶层目录中运行make。它将：<ul>
<li>构建二进制文件。</li>
<li>构建docker镜像。二进制文件和config&#x2F;被复制到docker镜像中。</li>
</ul>
</li>
</ul>
<p>如果您不需要某些类别的问题守护进程，您可以选择在编译时禁用它们。这是保持 node-problem-detector运行时紧凑且没有不必要代码（例如全局变量、goroutines 等）的最佳方法。</p>
<p>您可以通过BUILD_TAGS在运行之前设置环境变量来实现这一点make。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BUILD_TAGS=&quot;disable_custom_plugin_monitor disable_system_stats_monitor&quot; make</span><br></pre></td></tr></table></figure>

<p>上述命令将在不使用<a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/custompluginmonitor">自定义插件监视器</a>和<a href="https://github.com/kubernetes/node-problem-detector/tree/master/pkg/systemstatsmonitor">系统统计监视器</a>的情况下编译node-problem-detector 。查看<a href="https://github.com/kubernetes/node-problem-detector#problem-daemon">问题守护进程</a>部分，了解如何在编译时禁用每个问题守护进程。</p>
<h2 id="1-8-推送镜像"><a href="#1-8-推送镜像" class="headerlink" title="1.8 推送镜像"></a>1.8 推送镜像</h2><p><code>make push</code>将 docker 镜像上传到注册表。默认情况下，镜像将上传到 <code>staging-k8s.gcr.io</code>。可以轻松修改<code>Makefile</code>以将镜像推送到另一个注册表。</p>
<h2 id="1-9-安装"><a href="#1-9-安装" class="headerlink" title="1.9 安装"></a>1.9 安装</h2><p>将 node-problem-detector<br>安装到集群中的最简单方法是使用<a href="https://github.com/deliveryhero/helm-charts/tree/master/stable/node-problem-detector">Helm 图表</a>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm repo add deliveryhero https://charts.deliveryhero.io/</span><br><span class="line">helm install --generate-name deliveryhero/node-problem-detector</span><br></pre></td></tr></table></figure>

<p>或者，手动安装 node-problem-detector：</p>
<p>编辑<a href="https://github.com/kubernetes/node-problem-detector/blob/master/deployment/node-problem-detector.yaml">node-problem-detector.yaml</a>以适应您的环境。将<code>log</code>卷设置为您的系统日志目录（由 SystemLogMonitor 使用）。您可以使用 ConfigMap 覆盖<code>config</code> pod 内的目录。</p>
<p>编辑<a href="https://github.com/kubernetes/node-problem-detector/blob/master/deployment/node-problem-detector-config.yaml">node-problem-detector-config.yaml</a>来配置 node-problem-detector。</p>
<ul>
<li>编辑<a href="https://github.com/kubernetes/node-problem-detector/blob/master/deployment/rbac.yaml">rbac.yaml</a>以适合您的环境。</li>
<li>使用 创建 ServiceAccount 和 ClusterRoleBinding <code>kubectl create -f rbac.yaml</code>。</li>
<li>使用 创建 ConfigMap <code>kubectl create -f node-problem-detector-config.yaml</code>。</li>
<li>使用 创建 DaemonSet <code>kubectl create -f node-problem-detector.yaml</code>。</li>
</ul>
<h2 id="1-10-开始独立运行"><a href="#1-10-开始独立运行" class="headerlink" title="1.10 开始独立运行"></a>1.10 开始独立运行</h2><p>要独立运行 node-problem-detector，您应该设置inClusterConfig为false，并且教 node-problem-detector 如何 访问 apiserver，也就是apiserver-override。</p>
<p>要使用不安全的 apiserver 连接独立运行 node-problem-detector：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node-problem-detector --apiserver-override=http://APISERVER_IP:APISERVER_INSECURE_PORT?inClusterConfig=false</span><br></pre></td></tr></table></figure>

<p>更多场景请见<a href="https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md#kubernetes">此处</a></p>
<h2 id="1-11-试用"><a href="#1-11-试用" class="headerlink" title="1.11 试用"></a>1.11 试用</h2><p>您可以在正在运行的集群中尝试使用 node-problem-detector，方法是将消息注入到 node-problem-detector 正在监视的日志中。</p>
<p>例如，假设 node-problem-detector 正在使用KernelMonitor。</p>
<p>在您的机器上运行<code>kubectl get events -w</code>。在节点上运行<code>sudo sh -c &quot;echo &#39;kernel: BUG: unable to handle kernel NULL pointer dereference at TESTING&#39; &gt;&gt; /dev/kmsg&quot;</code>。然后您应该会看到该KernelOopss事件。</p>
<p>添加新规则或开发节点问题检测器时，在独立模式下在本地工作站上进行测试可能更容易。</p>
<p>对于 API 服务器，一种简单的方法是使用kubectl proxy正在运行的集群的 API 服务器在本地可用。</p>
<p>您会收到一些错误，因为 API 服务器无法识别您的本地工作站。但无论如何，您仍然应该能够测试您的新规则。</p>
<p>例如，测试KernelMonitor规则：</p>
<ul>
<li><code>make</code>（本地构建node-problem-detector）</li>
<li><code>kubectl proxy --port=8080</code>（使正在运行的集群的 API 服务器在本地可用）</li>
<li>将KernelMonitor更新到您的本地内核日志目录<code>logPath</code>。例如，在某些 Linux 系统上，它是<code>/run/log/journal</code>, 而不是<code>/var/log/journal</code>。</li>
<li><code>./bin/node-problem-detector --logtostderr --apiserver-override=http://127.0.0.1:8080?inClusterConfig=false --config.system-log-monitor=config/kernel-monitor.json --config.system-stats-monitor=config/system-stats-monitor.json --port=20256 --prometheus-port=2025</code>（或指向任何 API 服务器地址：端口和 Prometheus 端口）</li>
<li><code>sudo sh -c &quot;echo &#39;kernel: BUG: unable to handle kernel NULL pointer dereference at TESTING&#39; &gt;&gt; /dev/kmsg&quot;</code></li>
<li>您可以<code>KernelOops</code>在节点问题检测器日志中看到事件。</li>
<li><code>sudo sh -c &quot;echo &#39;kernel: INFO: task docker:20744 blocked for more than 120 seconds.&#39; &gt;&gt; /dev/kmsg&quot;</code></li>
<li>您可以在node-problem-detector log看DockerHung event和状态</li>
<li>您可以在<a href="http://127.0.0.1:20256/conditions%E6%9F%A5%E7%9C%8B%60DockerHung%60%E7%8A%B6%E6%80%81">http://127.0.0.1:20256/conditions查看DockerHung状态</a></li>
<li>您可以在<a href="http://127.0.0.1:20257/metrics%E4%B8%8A%E6%9F%A5%E7%9C%8B">http://127.0.0.1:20257/metrics</a>上查看 Prometheus 格式的磁盘相关系统指标。</li>
</ul>
<p>注： 您可以在<a href="https://github.com/kubernetes/node-problem-detector/tree/master/test/kernel_log_generator/problems">test&#x2F;kernel_log_generator&#x2F;problems</a>下查看更多规则示例。</p>
<ul>
<li>对于<a href="https://github.com/kubernetes/node-problem-detector/blob/master/config/kernel-monitor.json">KernelMonitor</a><br>消息注入，所有消息都应该有kernel: 前缀（另请注意，后面有一个空格:）；或者使用<a href="https://github.com/kubernetes/node-problem-detector/blob/master/test/kernel_log_generator/generator.sh">generator.sh</a>。</li>
<li>要将其他日志（如 systemd 日志）注入 journald，请使用<code>echo &#39;Some systemd message&#39; | systemd-cat -t systemd</code>。</li>
</ul>
<h2 id="1-12-Remedy-Systems"><a href="#1-12-Remedy-Systems" class="headerlink" title="1.12 Remedy Systems"></a>1.12 Remedy Systems</h2><p>Remedy Systems是一个或多个旨在尝试解决node-problem-detector检测到的问题的过程。</p>
<p>Remedy Systems会观察node-problem-detector发出的事件 和&#x2F;或 节点状况，并采取措施使 Kubernetes 集群恢复健康状态。</p>
<p>补救系统有以下几种：</p>
<ul>
<li><a href="https://github.com/planetlabs/draino">Draino</a> 根据标签和节点条件自动排空 Kubernetes节点。与所有提供的标签和任何提供的节点条件匹配的节点将被阻止立即接受新 pod（也称为“封锁”），并在可配置的时间后<a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/">排空</a>。Draino可以与 <a href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler">Cluster Autoscaler</a>结合使用，以自动终止排空的节点。请参阅 <a href="https://github.com/kubernetes/node-problem-detector/issues/199">此问题</a> ，了解 Draino的示例生产用例。</li>
<li><a href="https://github.com/kubernetes-sigs/descheduler">Descheduler</a> 取消调度策略RemovePodsViolatingNodeTaints会驱逐节点上违反NoSchedule污染的Pod。必须启用k8s调度程序的TaintNodesByCondition功能。</li>
<li><a href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler">Cluster Autoscaler</a> 可用于自动终止耗尽的节点。</li>
<li><a href="https://github.com/medik8s">mediK8S</a> 是一个基于<a href="https://github.com/medik8s/node-healthcheck-operator">Node Health Check Operator (NHC)</a>构建的自动修复系统的总体项目，该系统监控节点状况并使用修复 API将修复委托给外部修复程序。</li>
<li><a href="https://github.com/medik8s/poison-pill">Poison-Pill</a>是一个修复程序，它将重新启动节点并确保所有有状态的工作负载都得到重新安排。如果集群具有足够的健康容量，NHC支持有条件地进行修复，或者手动暂停任何操作以最大限度地减少集群中断。</li>
<li><a href="https://cluster-api.sigs.k8s.io/">Cluster API</a> 的<a href="https://cluster-api.sigs.k8s.io/developer/architecture/controllers/machine-health-check">MachineHealthCheck</a>负责修复不健康的机器。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Ldap通过helm部署</title>
    <url>/2025/07/devops/ldap/Ldap%E9%80%9A%E8%BF%87helm%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>⚡️: OpenLDAP是轻量级目录访问协议（LDAP）的开源实现，它提供了一种存储和访问关于用户、组、计算机和其他资源的信息的中心化目录服务。</p>
</blockquote>
<h1 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h1><ul>
<li>cn（common name）：通用名称，表示一个对象的名称。在用户条目中，通常与用户的姓名相对应；在组条目中，则与组名相对应。</li>
<li>ou（organizational unit）：组织单位，表示一个组织或部门。在LDAP目录服务中，可以使用ou来创建多级组织结构，并将用户和其他对象分配到相应的组织单元中，以便更好地管理它们。</li>
<li>dc（domain component）：域组件，表示域名的一部分。在LDAP中，域名通常是按照层次结构组织的，例如：example.com可以被拆分为dc&#x3D;example,dc&#x3D;com。这样做有利于有效地组织和管理大规模的目录服务。</li>
<li>sn（surname）：姓氏，表示一个人的姓氏。与cn属性不同，sn只表示姓氏，而且通常不唯一。</li>
</ul>
<h1 id="kubernetes集群部署"><a href="#kubernetes集群部署" class="headerlink" title="kubernetes集群部署"></a>kubernetes集群部署</h1><p>参考<a href="https://hua-ri.cn/2025/07/kubernetes/Kind%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4/">快速搭建kind测试集群</a>快速搭建一本地测使用的kind集群。</p>
<h1 id="Helm部署"><a href="#Helm部署" class="headerlink" title="Helm部署"></a>Helm部署</h1><h2 id="极简部署"><a href="#极简部署" class="headerlink" title="极简部署"></a>极简部署</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm repo add stable https://charts.helm.sh/stable</span><br><span class="line">helm install openldap stable/openldap</span><br></pre></td></tr></table></figure>

<h2 id="常规部署"><a href="#常规部署" class="headerlink" title="常规部署"></a>常规部署</h2><p>部署十分简单，但是我们可能需要调整Helm chart配置，所以建议把包拉取到本地调整之后再进行部署，下面是详细流程</p>
<h2 id="增加helm-repo"><a href="#增加helm-repo" class="headerlink" title="增加helm repo"></a>增加helm repo</h2><p>增加helm repo：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm repo add stable https://charts.helm.sh/stable</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ helm repo add stable https://charts.helm.sh/stable</span><br><span class="line">&quot;stable&quot; has been added to your repositories</span><br></pre></td></tr></table></figure>

<p>检索验证repo：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm search repo openldap</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ helm search repo openldap</span><br><span class="line">NAME                   CHART VERSION        APP VERSION        DESCRIPTION                                   </span><br><span class="line">stable/openldap        1.2.7                2.4.48             DEPRECATED - Community developed LDAP software</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="拉取chart"><a href="#拉取chart" class="headerlink" title="拉取chart"></a>拉取chart</h2><p>为了能够进行配置修改操作，将chart拉到本地：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm pull stable/openldap</span><br></pre></td></tr></table></figure>

<p>解压chart：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf openldap-1.2.7.tgz </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  github tar -zxvf openldap-1.2.7.tgz </span><br><span class="line">x openldap/Chart.yaml</span><br><span class="line">x openldap/values.yaml</span><br><span class="line">x openldap/templates/NOTES.txt</span><br><span class="line">x openldap/templates/_helpers.tpl</span><br><span class="line">x openldap/templates/configmap-customldif.yaml</span><br><span class="line">x openldap/templates/configmap-env.yaml</span><br><span class="line">x openldap/templates/deployment.yaml</span><br><span class="line">x openldap/templates/pvc.yaml</span><br><span class="line">x openldap/templates/secret.yaml</span><br><span class="line">x openldap/templates/service.yaml</span><br><span class="line">x openldap/templates/tests/openldap-test-runner.yaml</span><br><span class="line">x openldap/templates/tests/openldap-tests.yaml</span><br><span class="line">x openldap/.helmignore</span><br><span class="line">x openldap/README.md</span><br></pre></td></tr></table></figure>

<h2 id="配置调整"><a href="#配置调整" class="headerlink" title="配置调整"></a>配置调整</h2><p>拉取的Chart包，整体比较小，来看下大概的结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── README.md</span><br><span class="line">├── templates</span><br><span class="line">│   ├── NOTES.txt</span><br><span class="line">│   ├── _helpers.tpl</span><br><span class="line">│   ├── configmap-customldif.yaml</span><br><span class="line">│   ├── configmap-env.yaml</span><br><span class="line">│   ├── deployment.yaml</span><br><span class="line">│   ├── pvc.yaml</span><br><span class="line">│   ├── secret.yaml</span><br><span class="line">│   ├── service.yaml</span><br><span class="line">│   └── tests</span><br><span class="line">│       ├── openldap-test-runner.yaml</span><br><span class="line">│       └── openldap-tests.yaml</span><br><span class="line">└── values.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们如果有参数方面的变更，可以在values.yaml文件内进行填充配置，或者修改配置。</p>
<p>templates目录下就是整个chart的模板，包含了部署需要的configmap、deployment、pvc、secret、svc等资源yaml模板。</p>
<p>刚刚我们拉取的Chart包 部署openldap，values.yaml文件内需要调整的地方不是很多:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env:</span><br><span class="line">  LDAP_ORGANISATION: &quot;King Inc.&quot;</span><br><span class="line">  LDAP_DOMAIN: &quot;king-ldap.net&quot;</span><br><span class="line">  LDAP_BACKEND: &quot;hdb&quot;</span><br><span class="line">  LDAP_TLS: &quot;false&quot;</span><br><span class="line">  LDAP_TLS_ENFORCE: &quot;false&quot;</span><br><span class="line">  LDAP_REMOVE_CONFIG_AFTER_SETUP: &quot;false&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在chart的根目录执行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm install --kubeconfig=$HOME/.kube/king_test_config ldap ./</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Password:</span><br><span class="line">WARNING: This chart is deprecated</span><br><span class="line">NAME: ldap</span><br><span class="line">LAST DEPLOYED: Wed Jan 15 21:56:54 2025</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">OpenLDAP has been installed. You can access the server from within the k8s cluster using:</span><br><span class="line"></span><br><span class="line">  ldap-openldap.default.svc.cluster.local:389</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">You can access the LDAP adminPassword and configPassword using:</span><br><span class="line"></span><br><span class="line">  kubectl get secret --namespace default ldap-openldap -o jsonpath=&quot;&#123;.data.LDAP_ADMIN_PASSWORD&#125;&quot; | base64 --decode; echo</span><br><span class="line">  kubectl get secret --namespace default ldap-openldap -o jsonpath=&quot;&#123;.data.LDAP_CONFIG_PASSWORD&#125;&quot; | base64 --decode; echo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">You can access the LDAP service, from within the cluster (or with kubectl port-forward) with a command like (replace password and domain):</span><br><span class="line">  ldapsearch -x -H ldap://ldap-openldap.default.svc.cluster.local:389 -b dc=example,dc=org -D &quot;cn=admin,dc=example,dc=org&quot; -w $LDAP_ADMIN_PASSWORD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Test server health using Helm test:</span><br><span class="line">  helm test ldap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">You can also consider installing the helm chart for phpldapadmin to manage this instance of OpenLDAP, or install Apache Directory Studio, and connect using kubectl port-forward.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Helm-测试"><a href="#Helm-测试" class="headerlink" title="Helm 测试"></a>Helm 测试</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm list ldap</span><br></pre></td></tr></table></figure>

<p>查看idap的pod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl --kubeconfig=$HOME/.kube/king_test_config get pod -A|grep ldap</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAMESPACE            NAME                                               READY   STATUS    RESTARTS   AGE</span><br><span class="line">default              ldap-openldap-6d5cc55fc-vzq5v                      1/1     Running   0          17m</span><br></pre></td></tr></table></figure>

<p>登录idap的pod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl --kubeconfig=$HOME/.kube/king_test_config exec -it pod/ldap-openldap-6d5cc55fc-vzq5v -- /bin/bash</span><br></pre></td></tr></table></figure>

<p>可以使用ldapsearch命令进行查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldapsearch -x -b &lt;search_base&gt; -H &lt;ldap_host&gt; -D &lt;bind_dn&gt; -W</span></span><br></pre></td></tr></table></figure>
<ul>
<li>-x：表示简单的身份认证。</li>
<li>-b：指定搜索的 DC。</li>
<li>-H：指定搜索的主机 URL，如果你是在 LDAP 服务器上，则不需要带这个参数。比如我这里为 ldap:&#x2F;&#x2F;192.168.31.76:389</li>
<li>-D：绑定的 DN。</li>
<li>-W：绑定的 DN 的密码。</li>
</ul>
<p>例如一个实际的查询命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -b &quot;dc=king-ldap,dc=net&quot; -D &quot;cn=admin,dc=king-ldap,dc=net&quot;  -W</span><br></pre></td></tr></table></figure>

<p>会要求输入密码，可以如此获取：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env|grep -i PASSWORD</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LDAP_CONFIG_PASSWORD=M2ulnYD2lZPvM1hKsYP5sCy8meDN8h61</span><br><span class="line">LDAP_ADMIN_PASSWORD=a4QL47j3QvQWaTkDolvgLHpbpX8YDTdn</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ldap-openldap-6d5cc55fc-vzq5v:~# ldapsearch -x -b &quot;dc=king-ldap,dc=net&quot; -D &quot;cn=admin,dc=king-ldap,dc=net&quot;  -W</span><br><span class="line">Enter LDAP Password: </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">extended LDIF</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># LDAPv3</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">base &lt;dc=king-ldap,dc=net&gt; with scope subtree</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">filter: (objectclass=*)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">requesting: ALL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">king-ldap.net</span></span><br><span class="line">dn: dc=king-ldap,dc=net</span><br><span class="line">objectClass: top</span><br><span class="line">objectClass: dcObject</span><br><span class="line">objectClass: organization</span><br><span class="line">o: King Inc.</span><br><span class="line">dc: king-ldap</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">admin, king-ldap.net</span></span><br><span class="line">dn: cn=admin,dc=king-ldap,dc=net</span><br><span class="line">objectClass: simpleSecurityObject</span><br><span class="line">objectClass: organizationalRole</span><br><span class="line">cn: admin</span><br><span class="line">description: LDAP administrator</span><br><span class="line">userPassword:: e1NTSEF9eEl0d3JvcFN1cTgxelBLSFozVHYzQzJSdmtLcXNXenY=</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">search result</span></span><br><span class="line">search: 2</span><br><span class="line">result: 0 Success</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">numResponses: 3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">numEntries: 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Helm-数据持久化？"><a href="#Helm-数据持久化？" class="headerlink" title="Helm 数据持久化？"></a>Helm 数据持久化？</h1><p>看下pvc的yaml模板：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- if and .Values.persistence.enabled (not .Values.persistence.existingClaim) &#125;&#125;</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; template &quot;openldap.fullname&quot; . &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    app: &#123;&#123; template &quot;openldap.name&quot; . &#125;&#125;</span><br><span class="line">    chart: &#123;&#123; template &quot;openldap.chart&quot; . &#125;&#125;</span><br><span class="line">    release: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">    heritage: &#123;&#123; .Release.Service &#125;&#125;</span><br><span class="line">&#123;&#123;- if .Values.extraLabels &#125;&#125;</span><br><span class="line">&#123;&#123; toYaml .Values.extraLabels | indent 4 &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - &#123;&#123; .Values.persistence.accessMode | quote &#125;&#125;</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: &#123;&#123; .Values.persistence.size | quote &#125;&#125;</span><br><span class="line">&#123;&#123;- if .Values.persistence.storageClass &#125;&#125;</span><br><span class="line">&#123;&#123;- if (eq &quot;-&quot; .Values.persistence.storageClass) &#125;&#125;</span><br><span class="line">  storageClassName: &quot;&quot;</span><br><span class="line">&#123;&#123;- else &#125;&#125;</span><br><span class="line">  storageClassName: &quot;&#123;&#123; .Values.persistence.storageClass &#125;&#125;&quot;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>根据配置，只要在values.yaml文件的这部分进行pvc配置的填入再进行安装即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Persist data to a persistent volume</span></span></span><br><span class="line">persistence:</span><br><span class="line">  enabled: false</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment"># database data Persistent Volume Storage Class</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment"># If defined, storageClassName: &lt;storageClass&gt;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment"># If set to &quot;-&quot;, storageClassName: &quot;&quot;, which disables dynamic provisioning</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment"># If undefined (the default) or set to null, no storageClassName spec is</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#   set, choosing the default provisioner.  (gp2 on AWS, standard on</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#   GKE, AWS &amp; OpenStack)</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">storageClass: <span class="string">&quot;-&quot;</span></span></span><br><span class="line">  accessMode: ReadWriteOnce</span><br><span class="line">  size: 8Gi</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">existingClaim: <span class="string">&quot;&quot;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>git环境配置</title>
    <url>/2025/07/devops/environment/git%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="设置用户签名"><a href="#设置用户签名" class="headerlink" title="设置用户签名"></a>设置用户签名</h2><p>配置用户名： git config –global user.name 你的用户名<br>配置邮箱： git config –global user.email 注册的邮箱</p>
<p>配置好之后，可以用git config –global –list命令查看配置是否OK</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global --list</span></span><br><span class="line">user.name=xxx</span><br><span class="line">user.email=xxx@163.com</span><br></pre></td></tr></table></figure>

<h2 id="设置sshKey"><a href="#设置sshKey" class="headerlink" title="设置sshKey"></a>设置sshKey</h2><p>生成新的rsa密钥：ssh-keygen -t rsa -C ‘注册GitHub的邮箱’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C xxx@163.com</span><br></pre></td></tr></table></figure>

<p>一直回车就可以，即不设置密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C xxx@163.com</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/king/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /home/king/.ssh/id_rsa</span><br><span class="line">Your public key has been saved in /home/king/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:n+yyy xxx@163.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 3072]----+</span><br><span class="line">|    .*=.+.       |</span><br><span class="line">|    = +=o= o     |</span><br><span class="line">|     * ++ o .    |</span><br><span class="line">|  o . o..  .     |</span><br><span class="line">| o * .  S o      |</span><br><span class="line">|. X o  o = +     |</span><br><span class="line">| + + .. = *      |</span><br><span class="line">|..o .  o E       |</span><br><span class="line">|.o==    .        |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>

<p>此时已经生成了ssh ras的密钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> <span class="variable">$HOME</span>/.ssh</span></span><br><span class="line">authorized_keys  id_rsa  id_rsa.pub  known_hosts</span><br></pre></td></tr></table></figure>

<h2 id="设置github的SSH-key"><a href="#设置github的SSH-key" class="headerlink" title="设置github的SSH key"></a>设置github的SSH key</h2><p><img src="/img.png" alt="img.png"><br><img src="/img_1.png" alt="img_1.png"><br><img src="/img_2.png" alt="img_2.png"></p>
<p>将上面生成的ssh公钥复制进去。<br><img src="/img_3.png" alt="img_3.png"></p>
]]></content>
  </entry>
  <entry>
    <title>仓库fork后同步</title>
    <url>/2025/07/devops/environment/%E4%BB%93%E5%BA%93fork%E5%90%8E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="fork仓库"><a href="#fork仓库" class="headerlink" title="fork仓库"></a>fork仓库</h1><p><img src="/img_4.png" alt="img_4.png"><br><img src="/img_5.png" alt="img_5.png"></p>
<p>此时会将该仓库在复制一份，并存放在你的路径下：<br><img src="/img_6.png" alt="img_6.png"></p>
<h1 id="设置上游代码库"><a href="#设置上游代码库" class="headerlink" title="设置上游代码库"></a>设置上游代码库</h1><p>进入本地代码库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从自己仓库进行<span class="built_in">clone</span>(fork)</span></span><br><span class="line">git clone https://github.com/qiqiuyang/bk-ci.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入目录</span></span><br><span class="line">cd bk-ci/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录结构</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">CHANGELOG              CONTRIBUTING.md  README_EN.md  support-files</span><br><span class="line">CODE_OF_CONDUCT.en.md  docker-images    README.md     THIRD-PARTY-NOTICES.txt</span><br><span class="line">CODE_OF_CONDUCT.md     docs             scripts</span><br><span class="line">CODEOWNERS             helm-charts      SECURITY.md</span><br><span class="line">CONTRIBUTING.en.md     LICENSE.txt      src</span><br></pre></td></tr></table></figure>

<p>查看远程仓库的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin        https://github.com/qiqiuyang/bk-ci.git (fetch)</span><br><span class="line">origin        https://github.com/qiqiuyang/bk-ci.git (push)</span><br></pre></td></tr></table></figure>

<p>这里可以发现从自己仓库clone下来后，fetch和push的路径都是自己的。</p>
<p>设置上游代码库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add upstream git@github.com:TencentBlueKing/bk-ci.git</span></span><br></pre></td></tr></table></figure>

<p>再次查看远程仓库地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin        https://github.com/qiqiuyang/bk-ci.git (fetch)</span><br><span class="line">origin        https://github.com/qiqiuyang/bk-ci.git (push)</span><br><span class="line">upstream        git@github.com:TencentBlueKing/bk-ci.git (fetch)</span><br><span class="line">upstream        git@github.com:TencentBlueKing/bk-ci.git (push)</span><br></pre></td></tr></table></figure>

<h1 id="同步源仓库的更新"><a href="#同步源仓库的更新" class="headerlink" title="同步源仓库的更新"></a>同步源仓库的更新</h1><p>使用下面的命令拉取源仓库的更新：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch upstream</span></span><br><span class="line">remote: Enumerating objects: 17643, done.</span><br><span class="line">remote: Counting objects: 100% (13492/13492), done.</span><br><span class="line">remote: Compressing objects: 100% (3960/3960), done.</span><br><span class="line">remote: Total 10070 (delta 4278), reused 8600 (delta 3184), pack-reused 0 (from 0)</span><br><span class="line">接收对象中: 100% (10070/10070), 2.44 MiB | 2.05 MiB/s, 完成.</span><br><span class="line">处理 delta 中: 100% (4278/4278), 完成 657 个本地对象.</span><br><span class="line">来自 github.com:TencentBlueKing/bk-ci</span><br><span class="line"> * [新分支]                master          -&gt; upstream/master</span><br><span class="line"> * [新分支]                release-1.11    -&gt; upstream/release-1.11</span><br><span class="line"> * [新分支]                release-1.14    -&gt; upstream/release-1.14</span><br><span class="line"> * [新分支]                release-1.2     -&gt; upstream/release-1.2</span><br><span class="line"> * [新分支]                release-1.3     -&gt; upstream/release-1.3</span><br><span class="line">。。。</span><br><span class="line">。。。</span><br><span class="line"> * [新标签]                v1.8.4          -&gt; v1.8.4</span><br><span class="line"> * [新标签]                v1.8.5          -&gt; v1.8.5</span><br></pre></td></tr></table></figure>

<p>到这里就比较清晰了，在更新时就是把源仓库的更新的分支放在upstream下，例如：upstream&#x2F;master</p>
<p>所以同步远端分支时，就是git fetch upstream，然后将自己的分支merge目标分支内容，例如：git merge upstream&#x2F;master</p>
<p>如此便可以实现自己的fork仓库同步源仓库的新变更了。</p>
<h1 id="向原仓库发起PR"><a href="#向原仓库发起PR" class="headerlink" title="向原仓库发起PR"></a>向原仓库发起PR</h1><p>首先在自己的仓库点击Pull Request-&gt;New Pull Request，进入以下截图页面<br><img src="/img_7.png" alt="img_7.png"></p>
<p>base repository为原仓库的某个分支，head repository为fork仓库发某个分支, head的某个分支代码合到base的某个分支<br><img src="/img_8.png" alt="img_8.png"></p>
<p>进入原仓库的Pull requests可看到刚才发起的PR， 这里就不演示了</p>
]]></content>
  </entry>
  <entry>
    <title>alicloud_alikafka_instance</title>
    <url>/2025/07/devops/terraform/alicloud_alikafka_instance/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>约定格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── aliyun                                             # 云厂商实例文件</span><br><span class="line">│   └── aliyun_ecs_mod_demo                           # 模型名</span><br><span class="line">│       └── aliyun_china_platform_7111                # 云账号名</span><br><span class="line">│           └── ecs_instance_name_20241224121212      # 实例名</span><br><span class="line">│               ├── backend.tf                        # 实例state文件保存说明：oss</span><br><span class="line">│               └── main.tf                           # 实例具体的参数</span><br><span class="line">├── modules                                            # 模型数据文件夹</span><br><span class="line">│   ├── aliyun                                        # 云厂商模型文件夹</span><br><span class="line">│   │   └── aliyun_ecs_mod_demo                       # 模型名</span><br><span class="line">│   │       ├── main.tf                               # 模型定义主文件</span><br><span class="line">│   │       ├── outputs.tf                            # 模型定义输出文件</span><br><span class="line">│   │       └── variables.tf                          # 模型定义参数文件</span><br><span class="line">│   └── tenmod                                         # 另一个云厂商模型</span><br><span class="line">└── tenent                                              # 另一个云厂商实例文件</span><br></pre></td></tr></table></figure>

<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── aliyun</span><br><span class="line">│   └── aliyun_alikafka_demo</span><br><span class="line">│       └── aliyun_china_pt_7111</span><br><span class="line">│           └── alikafka_demo_202502061910</span><br><span class="line">│               ├── backend.tf</span><br><span class="line">│               └── main.tf</span><br><span class="line">└── modules</span><br><span class="line">    └── aliyun</span><br><span class="line">        └── aliyun_alikafka_mod_demo</span><br><span class="line">            ├── main.tf</span><br><span class="line">            └── variables.tf</span><br></pre></td></tr></table></figure>

<h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><h3 id="modules-aliyun-aliyun-alikafka-mod-demo-main-tf"><a href="#modules-aliyun-aliyun-alikafka-mod-demo-main-tf" class="headerlink" title="&#x2F;modules&#x2F;aliyun&#x2F;aliyun_alikafka_mod_demo&#x2F;main.tf"></a>&#x2F;modules&#x2F;aliyun&#x2F;aliyun_alikafka_mod_demo&#x2F;main.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    alicloud = &#123;</span><br><span class="line">      source  = &quot;aliyun/alicloud&quot;</span><br><span class="line">      version = &quot;1.225.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">provider &quot;alicloud&quot; &#123;</span><br><span class="line">  region = var.region</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;alicloud_alikafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">  name          = var.instance_name</span><br><span class="line">  deploy_type   = var.deploy_type</span><br><span class="line">  disk_size     = var.disk_size</span><br><span class="line">  disk_type     = var.disk_type</span><br><span class="line">  vswitch_id    = var.vswitch_id</span><br><span class="line">  partition_num = var.partition_num</span><br><span class="line">  io_max        = var.io_max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="modules-aliyun-aliyun-alikafka-mod-demo-variables-tf"><a href="#modules-aliyun-aliyun-alikafka-mod-demo-variables-tf" class="headerlink" title="&#x2F;modules&#x2F;aliyun&#x2F;aliyun_alikafka_mod_demo&#x2F;variables.tf"></a>&#x2F;modules&#x2F;aliyun&#x2F;aliyun_alikafka_mod_demo&#x2F;variables.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">variable &quot;region&quot; &#123;</span><br><span class="line">  description = &quot;地域&quot;</span><br><span class="line">  type        = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;instance_name&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例名&quot;</span><br><span class="line">  type        = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;deploy_type&quot; &#123;</span><br><span class="line">  // - 4: eip/vpc instance；- 5: vpc instance.</span><br><span class="line">  description = &quot;部署类型&quot;</span><br><span class="line">  type        = number</span><br><span class="line">  default = 5</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([4, 5], var.deploy_type)</span><br><span class="line">    error_message = &quot;The deploy_type must be one of 4, 5&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;disk_size&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例磁盘规格&quot;</span><br><span class="line">  type = number</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([500, 1000], var.disk_size)</span><br><span class="line">    error_message = &quot;The disk_size must be one of 200, 400&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;disk_type&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">0: efficient cloud disk , 1: SSD.</span></span><br><span class="line">  description = &quot;磁盘类型&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 1</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([0, 1], var.disk_type)</span><br><span class="line">    error_message = &quot;The disk_type must be empty, or one of 0, 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;vswitch_id&quot; &#123;</span><br><span class="line">  description = &quot;绑定虚拟交换机id&quot;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;partition_num&quot; &#123;</span><br><span class="line">  description = &quot;分区数量&quot;</span><br><span class="line">  type = number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">variable &quot;io_max&quot; &#123;</span><br><span class="line">  description = &quot;io的最大值&quot;</span><br><span class="line">  type = number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="aliyun-aliyun-alikafka-demo-aliyun-china-pt-7111-alikafka-demo-202502061910-backend-tf"><a href="#aliyun-aliyun-alikafka-demo-aliyun-china-pt-7111-alikafka-demo-202502061910-backend-tf" class="headerlink" title="&#x2F;aliyun&#x2F;aliyun_alikafka_demo&#x2F;aliyun_china_pt_7111&#x2F;alikafka_demo_202502061910&#x2F;backend.tf"></a>&#x2F;aliyun&#x2F;aliyun_alikafka_demo&#x2F;aliyun_china_pt_7111&#x2F;alikafka_demo_202502061910&#x2F;backend.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  backend &quot;oss&quot; &#123;</span><br><span class="line">    endpoint = &quot;oss-cn-hangzhou.aliyuncs.com&quot;</span><br><span class="line">    bucket   = &quot;dz-devops&quot; # 替换为你的 OSS Bucket 名称</span><br><span class="line">    prefix = &quot;terraform_state//aliyun/aliyun_alikafka_demo/aliyun_china_pt_7111/alikafka_demo_202502061910&quot;</span><br><span class="line">    key      = &quot;terraform.tfstate&quot; # 存储状态文件的路径和名称</span><br><span class="line">    region   = &quot;cn-hangzhou&quot;       # OSS 的地域（根据你的实际情况调整）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="aliyun-aliyun-alikafka-demo-aliyun-china-pt-7111-alikafka-demo-202502061910-main-tf"><a href="#aliyun-aliyun-alikafka-demo-aliyun-china-pt-7111-alikafka-demo-202502061910-main-tf" class="headerlink" title="&#x2F;aliyun&#x2F;aliyun_alikafka_demo&#x2F;aliyun_china_pt_7111&#x2F;alikafka_demo_202502061910&#x2F;main.tf"></a>&#x2F;aliyun&#x2F;aliyun_alikafka_demo&#x2F;aliyun_china_pt_7111&#x2F;alikafka_demo_202502061910&#x2F;main.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">module &quot;alikafka_instance&quot; &#123;</span><br><span class="line">  source        = &quot;../../../../modules/aliyun/aliyun_alikafka_mod_demo&quot;</span><br><span class="line">  region        = &quot;cn-hangzhou&quot;</span><br><span class="line">  disk_size     = 500</span><br><span class="line">  instance_name = &quot;alikafka-testV2&quot;</span><br><span class="line">  deploy_type   = 5</span><br><span class="line">  vswitch_id    = &quot;vsw-bp1co65f3q2s0bis9yfkg&quot;</span><br><span class="line">  partition_num = 50</span><br><span class="line">  io_max        = 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><h3 id="获取-AK-SK"><a href="#获取-AK-SK" class="headerlink" title="获取 AK&#x2F;SK"></a>获取 AK&#x2F;SK</h3><p>在首次使用 Terraform 之前，需要前往腾讯云的<a href="https://console.cloud.tencent.com/cam/capi">云 API 密钥页面</a>申请安全凭证SecretId和SecretKey2。若已有可使用的安全凭证，则跳过该步骤2。具体步骤如下2：</p>
<ol>
<li>登录腾讯云<a href="https://console.cloud.tencent.com/cam">访问管理控制台</a>，在左侧导航栏，选择访问密钥&gt;API 密钥管理。</li>
<li>在API 密钥管理页面，单击新建密钥，即可以创建一对SecretId&#x2F;SecretKey。</li>
</ol>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>将获取到的SecretId和SecretKey设置为环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export TENCENTCLOUD_SECRET_ID=your_secret_id</span><br><span class="line">export TENCENTCLOUD_SECRET_KEY=your_secret_key</span><br></pre></td></tr></table></figure>

<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>进入项目根目录，alikafka_demo_202502061910目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./aliyun/aliyun_alikafka_demo/aliyun_china_pt_7111/alikafka_demo_202502061910</span><br></pre></td></tr></table></figure>

<p>初始化 Terraform 项目:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xxx替换为实际backend的ak，将yyy替换为实际backend的sk</span></span><br><span class="line">terraform init -backend-config=&quot;access_key=xxx&quot; -backend-config=&quot;secret_key=yyy&quot;</span><br></pre></td></tr></table></figure>

<p>该命令会下载所需的插件和依赖，并初始化后端配置。<br>类似的输出（首次使用某一个provier时，会先下载）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Initializing the backend...</span><br><span class="line"></span><br><span class="line">Successfully configured the backend &quot;oss&quot;! Terraform will automatically</span><br><span class="line">use this backend unless the backend configuration changes.</span><br><span class="line">Initializing modules...</span><br><span class="line">Initializing provider plugins...</span><br><span class="line">- Reusing previous version of aliyun/alicloud from the dependency lock file</span><br><span class="line">- Using previously-installed aliyun/alicloud v1.225.0</span><br><span class="line"></span><br><span class="line">Terraform has been successfully initialized!</span><br><span class="line"></span><br><span class="line">You may now begin working with Terraform. Try running &quot;terraform plan&quot; to see</span><br><span class="line">any changes that are required for your infrastructure. All Terraform commands</span><br><span class="line">should now work.</span><br><span class="line"></span><br><span class="line">If you ever set or change modules or backend configuration for Terraform,</span><br><span class="line">rerun this command to reinitialize your working directory. If you forget, other</span><br><span class="line">commands will detect it and remind you to do so if necessary.</span><br></pre></td></tr></table></figure>

<p>预览计划变更：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform plan</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.alikafka_instance.alicloud_alikafka_instance.this will be created</span></span><br><span class="line">  + resource &quot;alicloud_alikafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      + config            = (known after apply)</span><br><span class="line">      + deploy_type       = 5</span><br><span class="line">      + disk_size         = 500</span><br><span class="line">      + disk_type         = 1</span><br><span class="line">      + eip_max           = (known after apply)</span><br><span class="line">      + end_point         = (known after apply)</span><br><span class="line">      + group_left        = (known after apply)</span><br><span class="line">      + group_used        = (known after apply)</span><br><span class="line">      + id                = (known after apply)</span><br><span class="line">      + io_max            = 20</span><br><span class="line">      + io_max_spec       = (known after apply)</span><br><span class="line">      + is_partition_buy  = (known after apply)</span><br><span class="line">      + name              = &quot;alikafka-testV2&quot;</span><br><span class="line">      + paid_type         = &quot;PostPaid&quot;</span><br><span class="line">      + partition_left    = (known after apply)</span><br><span class="line">      + partition_num     = 50</span><br><span class="line">      + partition_used    = (known after apply)</span><br><span class="line">      + resource_group_id = (known after apply)</span><br><span class="line">      + security_group    = (known after apply)</span><br><span class="line">      + service_version   = (known after apply)</span><br><span class="line">      + spec_type         = &quot;normal&quot;</span><br><span class="line">      + status            = (known after apply)</span><br><span class="line">      + topic_left        = (known after apply)</span><br><span class="line">      + topic_num_of_buy  = (known after apply)</span><br><span class="line">      + topic_quota       = (known after apply)</span><br><span class="line">      + topic_used        = (known after apply)</span><br><span class="line">      + vpc_id            = (known after apply)</span><br><span class="line">      + vswitch_id        = &quot;vsw-bp1co65f3q2s0bis9yfkg&quot;</span><br><span class="line">      + zone_id           = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">Note: You didn&#x27;t use the -out option to save this plan, so Terraform can&#x27;t guarantee to take exactly these actions if you run &quot;terraform apply&quot; now.</span><br></pre></td></tr></table></figure>

<p>执行变更：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform apply</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.alikafka_instance.alicloud_alikafka_instance.this will be created</span></span><br><span class="line">  + resource &quot;alicloud_alikafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      + config            = (known after apply)</span><br><span class="line">      + deploy_type       = 5</span><br><span class="line">      + disk_size         = 500</span><br><span class="line">      + disk_type         = 1</span><br><span class="line">      + eip_max           = (known after apply)</span><br><span class="line">      + end_point         = (known after apply)</span><br><span class="line">      + group_left        = (known after apply)</span><br><span class="line">      + group_used        = (known after apply)</span><br><span class="line">      + id                = (known after apply)</span><br><span class="line">      + io_max            = 20</span><br><span class="line">      + io_max_spec       = (known after apply)</span><br><span class="line">      + is_partition_buy  = (known after apply)</span><br><span class="line">      + name              = &quot;alikafka-testV2&quot;</span><br><span class="line">      + paid_type         = &quot;PostPaid&quot;</span><br><span class="line">      + partition_left    = (known after apply)</span><br><span class="line">      + partition_num     = 50</span><br><span class="line">      + partition_used    = (known after apply)</span><br><span class="line">      + resource_group_id = (known after apply)</span><br><span class="line">      + security_group    = (known after apply)</span><br><span class="line">      + service_version   = (known after apply)</span><br><span class="line">      + spec_type         = &quot;normal&quot;</span><br><span class="line">      + status            = (known after apply)</span><br><span class="line">      + topic_left        = (known after apply)</span><br><span class="line">      + topic_num_of_buy  = (known after apply)</span><br><span class="line">      + topic_quota       = (known after apply)</span><br><span class="line">      + topic_used        = (known after apply)</span><br><span class="line">      + vpc_id            = (known after apply)</span><br><span class="line">      + vswitch_id        = &quot;vsw-bp1co65f3q2s0bis9yfkg&quot;</span><br><span class="line">      + zone_id           = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">Do you want to perform these actions?</span><br><span class="line">  Terraform will perform the actions described above.</span><br><span class="line">  Only &#x27;yes&#x27; will be accepted to approve.</span><br><span class="line"></span><br><span class="line">  Enter a value: yes</span><br><span class="line"></span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Creating...</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [50s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m0s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [1m50s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m0s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [2m50s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m0s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [3m50s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [4m0s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [4m10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [4m20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [4m30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still creating... [4m40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Creation complete after 4m45s [id=alikafka_post-cn-0gx44g6dm006]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure>

<h3 id="验证创建"><a href="#验证创建" class="headerlink" title="验证创建"></a>验证创建</h3><p>在前端查看是否成功创建实例：<br><img src="/img.png" alt="img.png"></p>
<h3 id="销毁资源"><a href="#销毁资源" class="headerlink" title="销毁资源"></a>销毁资源</h3><p>执行下面的命令进行销毁：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform destroy</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Refreshing state... [id=alikafka_post-cn-0gx44g6dm006]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  - destroy</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.alikafka_instance.alicloud_alikafka_instance.this will be destroyed</span></span><br><span class="line">  - resource &quot;alicloud_alikafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      - config            = jsonencode(</span><br><span class="line">            &#123;</span><br><span class="line">              - &quot;cloud.maxTieredStoreSpace&quot;           = &quot;0&quot;</span><br><span class="line">              - &quot;enable.acl&quot;                          = &quot;false&quot;</span><br><span class="line">              - &quot;enable.compact&quot;                      = &quot;true&quot;</span><br><span class="line">              - &quot;enable.tiered&quot;                       = &quot;false&quot;</span><br><span class="line">              - &quot;enable.vpc_sasl_ssl&quot;                 = &quot;false&quot;</span><br><span class="line">              - &quot;kafka.log.retention.hours&quot;           = &quot;72&quot;</span><br><span class="line">              - &quot;kafka.message.max.bytes&quot;             = &quot;1048576&quot;</span><br><span class="line">              - &quot;kafka.offsets.retention.minutes&quot;     = &quot;10080&quot;</span><br><span class="line">              - &quot;kafka.ssl.bit&quot;                       = &quot;1024&quot;</span><br><span class="line">              - &quot;message.timestamp.difference.max.ms&quot; = &quot;9223372036854775807&quot;</span><br><span class="line">              - &quot;message.timestamp.type&quot;              = &quot;CreateTime&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ) -&gt; null</span><br><span class="line">      - deploy_type       = 5 -&gt; null</span><br><span class="line">      - disk_size         = 500 -&gt; null</span><br><span class="line">      - disk_type         = 1 -&gt; null</span><br><span class="line">      - eip_max           = 0 -&gt; null</span><br><span class="line">      - end_point         = &quot;172.31.1.64:9092,172.31.1.66:9092,172.31.1.65:9092&quot; -&gt; null</span><br><span class="line">      - group_left        = 2100 -&gt; null</span><br><span class="line">      - group_used        = 0 -&gt; null</span><br><span class="line">      - id                = &quot;alikafka_post-cn-0gx44g6dm006&quot; -&gt; null</span><br><span class="line">      - io_max            = 20 -&gt; null</span><br><span class="line">      - io_max_spec       = &quot;alikafka.hw.2xlarge&quot; -&gt; null</span><br><span class="line">      - is_partition_buy  = 1 -&gt; null</span><br><span class="line">      - name              = &quot;alikafka-testV2&quot; -&gt; null</span><br><span class="line">      - paid_type         = &quot;PostPaid&quot; -&gt; null</span><br><span class="line">      - partition_left    = 1050 -&gt; null</span><br><span class="line">      - partition_num     = 50 -&gt; null</span><br><span class="line">      - partition_used    = 0 -&gt; null</span><br><span class="line">      - resource_group_id = &quot;rg-acfmzpn54i5ejry&quot; -&gt; null</span><br><span class="line">      - security_group    = &quot;sg-bp184o2lwjnssf12wf3w&quot; -&gt; null</span><br><span class="line">      - service_version   = &quot;2.2.0&quot; -&gt; null</span><br><span class="line">      - spec_type         = &quot;normal&quot; -&gt; null</span><br><span class="line">      - status            = 5 -&gt; null</span><br><span class="line">      - tags              = &#123;&#125; -&gt; null</span><br><span class="line">      - topic_left        = 1050 -&gt; null</span><br><span class="line">      - topic_num_of_buy  = 1050 -&gt; null</span><br><span class="line">      - topic_quota       = 1050 -&gt; null</span><br><span class="line">      - topic_used        = 0 -&gt; null</span><br><span class="line">      - vpc_id            = &quot;vpc-bp1sro6pb0sec14x7s05l&quot; -&gt; null</span><br><span class="line">      - vswitch_id        = &quot;vsw-bp1co65f3q2s0bis9yfkg&quot; -&gt; null</span><br><span class="line">      - zone_id           = &quot;zonei&quot; -&gt; null</span><br><span class="line">        # (1 unchanged attribute hidden)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 0 to add, 0 to change, 1 to destroy.</span><br><span class="line"></span><br><span class="line">Do you really want to destroy all resources?</span><br><span class="line">  Terraform will destroy all your managed infrastructure, as shown above.</span><br><span class="line">  There is no undo. Only &#x27;yes&#x27; will be accepted to confirm.</span><br><span class="line"></span><br><span class="line">  Enter a value: yes</span><br><span class="line"></span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Destroying... [id=alikafka_post-cn-0gx44g6dm006]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 10s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 20s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 30s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 40s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 50s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m1s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m11s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m21s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m31s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m41s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 1m51s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 2m1s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 2m11s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 2m21s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Still destroying... [id=alikafka_post-cn-0gx44g6dm006, 2m31s elapsed]</span><br><span class="line">module.alikafka_instance.alicloud_alikafka_instance.this: Destruction complete after 2m37s</span><br><span class="line"></span><br><span class="line">Destroy complete! Resources: 1 destroyed.</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>Npd代码结构了解</title>
    <url>/2025/07/devops/npd/Npd%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="1-pkg目录结构"><a href="#1-pkg目录结构" class="headerlink" title="1 pkg目录结构"></a>1 pkg目录结构</h1><p>这里是各个monitor的实现。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── custompluginmonitor             -&gt; 用于实现自定义监视插件。node-problem-detector 支持通过插件监视特定状态或事件，此目录中包含与用户自定义插件相关的代码。</span><br><span class="line">├── exporters                       -&gt; 用于包含导出器（exporters）的实现，导出器负责将监视到的数据发送到外部系统，比如监控系统（例如 Prometheus）。导出器在数据收集和监控集成中起到关键作用。</span><br><span class="line">├── healthchecker                   -&gt; 实现健康检查逻辑，确保 node-problem-detector 本身和其他依赖的组件处于健康状态。这是监控和维护软件稳定性的重要部分。</span><br><span class="line">├── logcounter                      -&gt; 实现了 logcounter 的功能，通常用于计数和分析系统日志，以检测异常行为或问题。它可以与系统日志监控结合使用。</span><br><span class="line">├── problemdaemon                   -&gt; 实现问题守护程序。这个守护程序负责监测和识别节点中的问题，通过问题发现机制收集指标并生成告警。</span><br><span class="line">├── problemdetector                 -&gt; 包含问题检测的核心逻辑。这是 node-problem-detector 的主要功能部分，负责从不同的来源收集信息，并根据这些信息识别和报告节点问题。</span><br><span class="line">├── problemmetrics                  -&gt; 包含问题指标的实现，用于收集、处理和导出有关节点状态和问题的数据。这些指标可以展示在监控界面上，帮助用户理解系统的健康状况。</span><br><span class="line">├── systemlogmonitor                -&gt; 实现了系统日志监控的功能。它处理系统日志，分析日志内容，以检测可能导致问题的事件和错误。</span><br><span class="line">├── systemstatsmonitor              -&gt; 用于监控系统的各种统计数据，例如 CPU 使用率、内存使用情况等。它负责收集和报告这些统计信息，以帮助验证节点的健康状态。</span><br><span class="line">├── types                           -&gt; 用于定义项目中使用的各种类型结构体和常量。这些类型通常用于数据传输和处理，为核心逻辑提供数据模型。</span><br><span class="line">├── util                            -&gt; 包含一些公用工具函数和库，这些函数可以在其他模块中复用，提高代码的可维护性和可读性。</span><br><span class="line">└── version                         -&gt; 保存与版本相关的信息和结构。它用于管理版本号并提供版本信息的功能</span><br></pre></td></tr></table></figure>

<h1 id="2-problemdaemon"><a href="#2-problemdaemon" class="headerlink" title="2 problemdaemon"></a>2 problemdaemon</h1><h2 id="2-1-Register"><a href="#2-1-Register" class="headerlink" title="2.1 Register"></a>2.1 Register</h2><p>pkg&#x2F;problemdaemon&#x2F;problem_daemon.go:32</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">        handlers = make(map[types.ProblemDaemonType]types.ProblemDaemonHandler)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Register registers a problem daemon factory method, which will be used to create the problem daemon.</span><br><span class="line">func Register(problemDaemonType types.ProblemDaemonType, handler types.ProblemDaemonHandler) &#123;</span><br><span class="line">        handlers[problemDaemonType] = handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册一个问题守护进程工厂方法。<br>参数：</p>
<ul>
<li>problemDaemonType: 需要注册的守护进程类型。</li>
<li>handler: 对应的处理器，其中包含创建守护进程的方法。<br>作用：将指定类型的处理器添加到 handlers 映射中，以便后续根据类型获取对应的处理器。</li>
</ul>
<h2 id="2-2-GetProblemDaemonNames"><a href="#2-2-GetProblemDaemonNames" class="headerlink" title="2.2 GetProblemDaemonNames"></a>2.2 GetProblemDaemonNames</h2><p>pkg&#x2F;problemdaemon&#x2F;problem_daemon.go:37</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// GetProblemDaemonNames retrieves all available problem daemon types.</span><br><span class="line">func GetProblemDaemonNames() []types.ProblemDaemonType &#123;</span><br><span class="line">        problemDaemonTypes := []types.ProblemDaemonType&#123;&#125;</span><br><span class="line">        for problemDaemonType := range handlers &#123;</span><br><span class="line">                problemDaemonTypes = append(problemDaemonTypes, problemDaemonType)</span><br><span class="line">        &#125;</span><br><span class="line">        return problemDaemonTypes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检索所有可用的问题守护进程类型。</p>
<p>返回值：返回一个包含所有注册的守护进程类型的切片。</p>
<p>实现细节：遍历 handlers 映射，将每种问题守护进程类型添加到返回的切片中。</p>
<h2 id="2-3-GetProblemDaemonHandlerOrDie"><a href="#2-3-GetProblemDaemonHandlerOrDie" class="headerlink" title="2.3 GetProblemDaemonHandlerOrDie"></a>2.3 GetProblemDaemonHandlerOrDie</h2><p>pkg&#x2F;problemdaemon&#x2F;problem_daemon.go:46</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// GetProblemDaemonHandlerOrDie retrieves the ProblemDaemonHandler for a specific type of problem daemon, panic if error occurs..</span><br><span class="line">func GetProblemDaemonHandlerOrDie(problemDaemonType types.ProblemDaemonType) types.ProblemDaemonHandler &#123;</span><br><span class="line">        handler, ok := handlers[problemDaemonType]</span><br><span class="line">        if !ok &#123;</span><br><span class="line">                panic(fmt.Sprintf(&quot;Problem daemon handler for %v does not exist&quot;, problemDaemonType))</span><br><span class="line">        &#125;</span><br><span class="line">        return handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取特定类型问题守护进程的处理器。</p>
<p>参数：问题守护进程类型。</p>
<p>返回值：返回对应的处理器。</p>
<p>实现细节：如果指定类型没有找到对应的处理器，则触发恐慌（panic），这通常用于在初始化时确保配置的有效性。</p>
<h2 id="2-4-NewProblemDaemons"><a href="#2-4-NewProblemDaemons" class="headerlink" title="2.4 NewProblemDaemons"></a>2.4 NewProblemDaemons</h2><p>pkg&#x2F;problemdaemon&#x2F;problem_daemon.go:55</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// NewProblemDaemons creates all problem daemons based on the configurations provided.</span><br><span class="line">func NewProblemDaemons(monitorConfigPaths types.ProblemDaemonConfigPathMap) []types.Monitor &#123;</span><br><span class="line">        problemDaemonMap := make(map[string]types.Monitor)</span><br><span class="line">        for problemDaemonType, configs := range monitorConfigPaths &#123;</span><br><span class="line">                for _, config := range *configs &#123;</span><br><span class="line">                        if _, ok := problemDaemonMap[config]; ok &#123;</span><br><span class="line">                                // Skip the config if it&#x27;s duplicated.</span><br><span class="line">                                klog.Warningf(&quot;Duplicated problem daemon configuration %q&quot;, config)</span><br><span class="line">                                continue</span><br><span class="line">                        &#125;</span><br><span class="line">                        problemDaemonMap[config] = handlers[problemDaemonType].CreateProblemDaemonOrDie(config)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        problemDaemons := []types.Monitor&#123;&#125;</span><br><span class="line">        for _, problemDaemon := range problemDaemonMap &#123;</span><br><span class="line">                problemDaemons = append(problemDaemons, problemDaemon)</span><br><span class="line">        &#125;</span><br><span class="line">        return problemDaemons</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据提供的配置创建所有问题守护进程。</p>
<p>参数：</p>
<p>monitorConfigPaths: 包含每种问题守护进程类型及其对应配置路径的映射。<br>返回值：返回创建的所有 Monitor 实例的切片。<br>实现细节</p>
<ul>
<li>创建空映射：使用 problemDaemonMap 存储已创建的守护进程，以避免重复。</li>
<li>遍历配置：<ul>
<li>对于配置中的每种问题守护进程类型及其相应的配置路径，检查是否已经创建。</li>
<li>如果配置已存在，则记录警告并跳过。</li>
<li>使用注册的处理器创建新的问题守护进程并将其添加到映射中。</li>
</ul>
</li>
<li>返回值构建：将地图中的所有守护进程转换为切片并返回。</li>
</ul>
<h1 id="3-problem-detector"><a href="#3-problem-detector" class="headerlink" title="3 problem_detector"></a>3 problem_detector</h1><h2 id="3-1-problemDetector定义"><a href="#3-1-problemDetector定义" class="headerlink" title="3.1 problemDetector定义"></a>3.1 problemDetector定义</h2><p>pkg&#x2F;problemdetector&#x2F;problem_detector.go:33</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// ProblemDetector collects statuses from all problem daemons and update the node condition and send node event.</span><br><span class="line">type ProblemDetector interface &#123;</span><br><span class="line">        Run(context.Context) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type problemDetector struct &#123;</span><br><span class="line">        monitors  []types.Monitor</span><br><span class="line">        exporters []types.Exporter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段：</p>
<p>monitors: 存储监控器的切片，用于收集问题状态。</p>
<p>exporters: 存储导出器的切片，用于将收集到的状态发送到外部系统或用户。</p>
<p>方法说明： Run(context.Context) error 启动问题检测器，并在上下文被取消或出现错误时返回错误。</p>
<h2 id="3-2-NewProblemDetector"><a href="#3-2-NewProblemDetector" class="headerlink" title="3.2 NewProblemDetector"></a>3.2 NewProblemDetector</h2><p>pkg&#x2F;problemdetector&#x2F;problem_detector.go:40</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// NewProblemDetector creates the problem detector. Currently we just directly passed in the problem daemons, but</span><br><span class="line">// in the future we may want to let the problem daemons register themselves.</span><br><span class="line">func NewProblemDetector(monitors []types.Monitor, exporters []types.Exporter) ProblemDetector &#123;</span><br><span class="line">        return &amp;problemDetector&#123;</span><br><span class="line">                monitors:  monitors,</span><br><span class="line">                exporters: exporters,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个新的问题检测器实例。</p>
<p>参数：</p>
<p>monitors: 监控器数组，用于检测不同问题。</p>
<p>exporters: 导出器数组，用于将状态发送给外部系统。</p>
<p>返回值：返回实现 ProblemDetector 接口的新的 problemDetector 实例。</p>
<h2 id="3-3-Run"><a href="#3-3-Run" class="headerlink" title="3.3 Run"></a>3.3 Run</h2><p>pkg&#x2F;problemdetector&#x2F;problem_detector.go:48</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// Run starts the problem detector.</span><br><span class="line">func (p *problemDetector) Run(ctx context.Context) error &#123;</span><br><span class="line">        // Start the log monitors one by one.</span><br><span class="line">        var chans []&lt;-chan *types.Status</span><br><span class="line">        failureCount := 0</span><br><span class="line">        for _, m := range p.monitors &#123;</span><br><span class="line">                ch, err := m.Start()</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        // Do not return error and keep on trying the following config files.</span><br><span class="line">                        klog.Errorf(&quot;Failed to start problem daemon %v: %v&quot;, m, err)</span><br><span class="line">                        failureCount++</span><br><span class="line">                        continue</span><br><span class="line">                &#125;</span><br><span class="line">                if ch != nil &#123;</span><br><span class="line">                        chans = append(chans, ch)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        allMonitors := p.monitors</span><br><span class="line"></span><br><span class="line">        if len(allMonitors) == failureCount &#123;</span><br><span class="line">                return fmt.Errorf(&quot;no problem daemon is successfully setup&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        defer func() &#123;</span><br><span class="line">                for _, m := range allMonitors &#123;</span><br><span class="line">                        m.Stop()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        ch := groupChannel(chans)</span><br><span class="line">        klog.Info(&quot;Problem detector started&quot;)</span><br><span class="line"></span><br><span class="line">        for &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-ctx.Done():</span><br><span class="line">                        return nil</span><br><span class="line">                case status := &lt;-ch:</span><br><span class="line">                        for _, exporter := range p.exporters &#123;</span><br><span class="line">                                exporter.ExportProblems(status)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行问题检测器的主要运行逻辑。</p>
<p>实现细节：</p>
<ul>
<li>开始监控器：遍历并启动每个监控器。</li>
<li>如果启动失败，记录错误并增加失败计数。</li>
<li>如果成功，则将返回的通道添加到 chans 切片。</li>
<li>检查失败情况：如果所有监控器都失败，则返回错误。</li>
<li>延迟关闭：在函数结束时停止所有监控器。</li>
<li>通道组合：调用 groupChannel 函数，用于将所有监控器的状态通道组合成单一通道。</li>
<li>监听状态：使用 select 不断监听上下文和监控器的状态。</li>
<li>如果收到状态，从所有导出器导出问题。</li>
</ul>
<h2 id="3-4-groupChannel"><a href="#3-4-groupChannel" class="headerlink" title="3.4 groupChannel"></a>3.4 groupChannel</h2><p>pkg&#x2F;problemdetector&#x2F;problem_detector.go:91</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func groupChannel(chans []&lt;-chan *types.Status) &lt;-chan *types.Status &#123;</span><br><span class="line">        statuses := make(chan *types.Status)</span><br><span class="line">        for _, ch := range chans &#123;</span><br><span class="line">                go func(c &lt;-chan *types.Status) &#123;</span><br><span class="line">                        for status := range c &#123;</span><br><span class="line">                                statuses &lt;- status</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;(ch)</span><br><span class="line">        &#125;</span><br><span class="line">        return statuses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将多个状态通道组合为一个通道。</p>
<p>参数：切片 chans，包含多个状态通道。</p>
<p>返回值：返回一个新的通道 statuses，用于接收来自所有监控器的状态。</p>
<p>实现细节</p>
<p>启动多个 goroutine，每个 goroutine 从一个监控器的通道读取状态，并将其转发到新的 statuses 通道中。</p>
<h1 id="4-problemmetrics"><a href="#4-problemmetrics" class="headerlink" title="4 problemmetrics"></a>4 problemmetrics</h1><h2 id="4-1-ProblemMetricsManager定义"><a href="#4-1-ProblemMetricsManager定义" class="headerlink" title="4.1 ProblemMetricsManager定义"></a>4.1 ProblemMetricsManager定义</h2><p>pkg&#x2F;problemmetrics&#x2F;problem_metrics.go:40</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// ProblemMetricsManager manages problem-converted metrics.</span><br><span class="line">// ProblemMetricsManager is thread-safe.</span><br><span class="line">type ProblemMetricsManager struct &#123;</span><br><span class="line">        problemCounter           metrics.Int64MetricInterface</span><br><span class="line">        problemGauge             metrics.Int64MetricInterface</span><br><span class="line">        problemTypeToReason      map[string]string</span><br><span class="line">        problemTypeToReasonMutex sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段：</p>
<ul>
<li>problemCounter: 一个整型指标接口，用于计数特定问题发生的次数。</li>
<li>problemGauge: 一个整型指标接口，用于表示特定问题是否对节点产生影响。</li>
<li>problemTypeToReason: 一个映射，保存问题类型与原因的关系。</li>
<li>problemTypeToReasonMutex: 一个互斥锁，用于保护 problemTypeToReason 的并发访问。</li>
</ul>
<h2 id="4-2-init"><a href="#4-2-init" class="headerlink" title="4.2 init"></a>4.2 init</h2><p>pkg&#x2F;problemmetrics&#x2F;problem_metrics.go:31</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// GlobalProblemMetricsManager is a singleton of ProblemMetricsManager,</span><br><span class="line">// which should be used to manage all problem-converted metrics across all</span><br><span class="line">// problem daemons.</span><br><span class="line">var GlobalProblemMetricsManager *ProblemMetricsManager</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">        GlobalProblemMetricsManager = NewProblemMetricsManagerOrDie()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GlobalProblemMetricsManager: 全局唯一的 ProblemMetricsManager 实例，用于管理所有问题相关的指标。</p>
<p>init 函数: 在程序启动时初始化 GlobalProblemMetricsManager，确保其可用。</p>
<h2 id="4-3-NewProblemMetricsManagerOrDie"><a href="#4-3-NewProblemMetricsManagerOrDie" class="headerlink" title="4.3 NewProblemMetricsManagerOrDie"></a>4.3 NewProblemMetricsManagerOrDie</h2><p>pkg&#x2F;problemmetrics&#x2F;problem_metrics.go:47</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func NewProblemMetricsManagerOrDie() *ProblemMetricsManager &#123;</span><br><span class="line">        pmm := ProblemMetricsManager&#123;&#125;</span><br><span class="line"></span><br><span class="line">        var err error</span><br><span class="line">        pmm.problemCounter, err = metrics.NewInt64Metric(</span><br><span class="line">                metrics.ProblemCounterID,</span><br><span class="line">                string(metrics.ProblemCounterID),</span><br><span class="line">                &quot;Number of times a specific type of problem have occurred.&quot;,</span><br><span class="line">                &quot;1&quot;,</span><br><span class="line">                metrics.Sum,</span><br><span class="line">                []string&#123;&quot;reason&quot;&#125;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                klog.Fatalf(&quot;Failed to create problem_counter metric: %v&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pmm.problemGauge, err = metrics.NewInt64Metric(</span><br><span class="line">                metrics.ProblemGaugeID,</span><br><span class="line">                string(metrics.ProblemGaugeID),</span><br><span class="line">                &quot;Whether a specific type of problem is affecting the node or not.&quot;,</span><br><span class="line">                &quot;1&quot;,</span><br><span class="line">                metrics.LastValue,</span><br><span class="line">                []string&#123;&quot;type&quot;, &quot;reason&quot;&#125;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                klog.Fatalf(&quot;Failed to create problem_gauge metric: %v&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pmm.problemTypeToReason = make(map[string]string)</span><br><span class="line"></span><br><span class="line">        return &amp;pmm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建并初始化 ProblemMetricsManager 实例。</p>
<p>实现细节：</p>
<p>创建 problemCounter 指标，用于记录特定问题的发生次数，接收标签 reason。</p>
<p>创建 problemGauge 指标，用于指示特定问题是否正在影响节点，接收标签 type 和 reason。</p>
<p>如果创建指标失败，则程序会崩溃（Fatalf）。</p>
<p>初始化问题类型到原因的映射。</p>
<h2 id="4-4-IncrementProblemCounter"><a href="#4-4-IncrementProblemCounter" class="headerlink" title="4.4 IncrementProblemCounter"></a>4.4 IncrementProblemCounter</h2><p>pkg&#x2F;problemmetrics&#x2F;problem_metrics.go:79</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// IncrementProblemCounter increments the value of a problem counter.</span><br><span class="line">func (pmm *ProblemMetricsManager) IncrementProblemCounter(reason string, count int64) error &#123;</span><br><span class="line">        if pmm.problemCounter == nil &#123;</span><br><span class="line">                return errors.New(&quot;problem counter is being incremented before initialized.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pmm.problemCounter.Record(map[string]string&#123;&quot;reason&quot;: reason&#125;, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加问题计数器的值，根据 reason 标签记录统计数据。</p>
<p>参数：</p>
<p>reason: 问题发生的原因。</p>
<p>count: 要增加的数量。</p>
<p>返回值：返回可能的错误。</p>
<h2 id="4-5-SetProblemGauge"><a href="#4-5-SetProblemGauge" class="headerlink" title="4.5 SetProblemGauge"></a>4.5 SetProblemGauge</h2><p>pkg&#x2F;problemmetrics&#x2F;problem_metrics.go:88</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// SetProblemGauge sets the value of a problem gauge.</span><br><span class="line">func (pmm *ProblemMetricsManager) SetProblemGauge(problemType string, reason string, value bool) error &#123;</span><br><span class="line">        if pmm.problemGauge == nil &#123;</span><br><span class="line">                return errors.New(&quot;problem gauge is being set before initialized.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pmm.problemTypeToReasonMutex.Lock()</span><br><span class="line">        defer pmm.problemTypeToReasonMutex.Unlock()</span><br><span class="line"></span><br><span class="line">        // We clear the last reason, because the expected behavior is that at any point of time,</span><br><span class="line">        // for each type of permanent problem, there should be at most one reason got set to 1.</span><br><span class="line">        // This behavior is consistent with the behavior of node condition in Kubernetes.</span><br><span class="line">        // However, problemGauges with different &quot;type&quot; and &quot;reason&quot; are considered as different</span><br><span class="line">        // metrics in Prometheus. So we need to clear the previous metrics explicitly.</span><br><span class="line">        if lastReason, ok := pmm.problemTypeToReason[problemType]; ok &#123;</span><br><span class="line">                err := pmm.problemGauge.Record(map[string]string&#123;&quot;type&quot;: problemType, &quot;reason&quot;: lastReason&#125;, 0)</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        return fmt.Errorf(&quot;failed to clear previous reason %q for type %q: %v&quot;,</span><br><span class="line">                                problemType, lastReason, err)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pmm.problemTypeToReason[problemType] = reason</span><br><span class="line"></span><br><span class="line">        var valueInt int64</span><br><span class="line">        if value &#123;</span><br><span class="line">                valueInt = 1</span><br><span class="line">        &#125;</span><br><span class="line">        return pmm.problemGauge.Record(map[string]string&#123;&quot;type&quot;: problemType, &quot;reason&quot;: reason&#125;, valueInt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置问题量规的值，指示特定问题对节点的影响。</p>
<p>参数：</p>
<ul>
<li>problemType: 问题类型（例如，节点不可用）。</li>
<li>reason: 具体原因。</li>
<li>value: 表示问题的状态，true表示问题存在 (1)，false表示问题消失 (0)。</li>
</ul>
<p>实现细节：</p>
<ul>
<li>使用互斥锁保护对 problemTypeToReason 的并发访问。</li>
<li>清除之前的原因（如果存在），保证每个问题类型在任何时刻都最多只有一个原因被设置为 1。</li>
<li>记录新的量规值。</li>
</ul>
<h1 id="5-exporters"><a href="#5-exporters" class="headerlink" title="5 exporters"></a>5 exporters</h1><p>目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── k8sexporter</span><br><span class="line">│   ├── condition</span><br><span class="line">│   ├── k8s_exporter.go</span><br><span class="line">│   └── problemclient</span><br><span class="line">├── prometheusexporter</span><br><span class="line">│   └── prometheus_exporter.go</span><br><span class="line">├── register.go</span><br><span class="line">├── register_test.go</span><br><span class="line">└── stackdriver</span><br><span class="line">    ├── config</span><br><span class="line">    ├── gce</span><br><span class="line">    ├── stackdriver_exporter.go</span><br><span class="line">    └── stackdriver_exporter_test.go</span><br></pre></td></tr></table></figure>
<p>这里就涉及到了三个exporter，分别是k8sexporter、prometheusexporter、stackdriver_exporter</p>
<p>这三个是比较独立的，因为能力是完全不一样的，</p>
<ul>
<li>exporter：专注于将types.Status的event和conditation上报，并且会有一些http服务接口开放(healthz、conditions、&#x2F;debug&#x2F;pprof)，</li>
<li>prometheusexporter：直接用的prometheuse的库，简单理解就是为了让prometheuse可以采集到数据</li>
<li>stackdriver_exporter：处理与 Google Stackdriver 的集成，Stackdriver 是 Google Cloud 提供的监控和管理平台，该exporter负责将指标数据发送到<br>Stackdriver，以便在 Google Cloud 环境中监控应用程序和集群状态。</li>
</ul>
<p>这里来说说我的理解吧，prometheusexporter和stackdriver_exporter这两个exporter是为了将metric数据发送到对应的监控平台，而k8sexporter则是为了将types.Status发送到k8s，目前已经开始向register继承方向延展，如stackdriver_exporter已经使用该模式并且已经统一了struct的实现方法，但是prometheusexporter和k8sexporter还没完成演变，目前还是通过package直接调用的方式使用的。</p>
<p>这个模块就不进行代码级别解析了，整体是非常简单的。</p>
<h1 id="6-healthchecker"><a href="#6-healthchecker" class="headerlink" title="6 healthchecker"></a>6 healthchecker</h1><p>目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── health_checker.go</span><br><span class="line">├── health_checker_darwin.go</span><br><span class="line">├── health_checker_linux.go</span><br><span class="line">├── health_checker_test.go</span><br><span class="line">├── health_checker_windows.go</span><br><span class="line">└── types</span><br><span class="line">├── types.go</span><br><span class="line">├── types_test.go</span><br><span class="line">├── types_unix.go</span><br><span class="line">└── types_windows.go</span><br></pre></td></tr></table></figure>

<p>6.1 healthChecker定义<br>pkg&#x2F;healthchecker&#x2F;health_checker.go:31</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type healthChecker struct &#123;</span><br><span class="line">  component       string</span><br><span class="line">  service         string</span><br><span class="line">  enableRepair    bool</span><br><span class="line">  healthCheckFunc func () (bool, error)</span><br><span class="line">  // The repair is &quot;best-effort&quot; and ignores the error from the underlying actions.</span><br><span class="line">  // The bash commands to kill the process will fail if the service is down and hence ignore.</span><br><span class="line">  repairFunc         func ()</span><br><span class="line">  uptimeFunc         func () (time.Duration, error)</span><br><span class="line">  crictlPath         string</span><br><span class="line">  healthCheckTimeout time.Duration</span><br><span class="line">  coolDownTime       time.Duration</span><br><span class="line">  loopBackTime       time.Duration</span><br><span class="line">  logPatternsToCheck map[string]int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段含义：</p>
<ul>
<li>component：被检查的 Kubernetes 组件名称（如 Kubelet、Kube Proxy 等）。</li>
<li>service：服务名称或标识符。</li>
<li>enableRepair：布尔值，指示是否在发现服务不健康时尝试修复它。</li>
<li>healthCheckFunc：一个函数，用于执行健康检查，返回健康状态和可能的错误。</li>
<li>repairFunc：一个函数，用于尝试修复不健康的服务。</li>
<li>uptimeFunc：一个函数，用于获取服务的运行时间。</li>
<li>crictlPath：指向 CRI 工具的路径。</li>
<li>healthCheckTimeout：健康检查的超时设置。</li>
<li>coolDownTime：在尝试修复之前要求服务必须正常运行的时间。</li>
<li>loopBackTime：用于回溯检查日志的时间段。</li>
<li>logPatternsToCheck：一个映射，包含要检查的日志模式及其出现次数阈值。</li>
</ul>
<h2 id="6-2-NewHealthChecker"><a href="#6-2-NewHealthChecker" class="headerlink" title="6.2 NewHealthChecker"></a>6.2 NewHealthChecker</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:48</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// NewHealthChecker returns a new health checker configured with the given options.</span><br><span class="line">func NewHealthChecker(hco *options.HealthCheckerOptions) (types.HealthChecker, error) &#123;</span><br><span class="line">  hc := &amp;healthChecker&#123;</span><br><span class="line">    component:          hco.Component,</span><br><span class="line">    enableRepair:       hco.EnableRepair,</span><br><span class="line">    crictlPath:         hco.CriCtlPath,</span><br><span class="line">    healthCheckTimeout: hco.HealthCheckTimeout,</span><br><span class="line">    coolDownTime:       hco.CoolDownTime,</span><br><span class="line">    service:            hco.Service,</span><br><span class="line">    loopBackTime:       hco.LoopBackTime,</span><br><span class="line">    logPatternsToCheck: hco.LogPatterns.GetLogPatternCountMap(),</span><br><span class="line">  &#125;</span><br><span class="line">  hc.healthCheckFunc = getHealthCheckFunc(hco)</span><br><span class="line">  hc.repairFunc = getRepairFunc(hco)</span><br><span class="line">  hc.uptimeFunc = getUptimeFunc(hco.Service)</span><br><span class="line">  return hc, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NewHealthChecker会根据输入的options.HealthCheckerOptions来进行types.HealthChecker的构造。</p>
<h2 id="6-3-CheckHealth"><a href="#6-3-CheckHealth" class="headerlink" title="6.3 CheckHealth"></a>6.3 CheckHealth</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:67</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// CheckHealth checks for the health of the component and tries to repair if enabled.</span><br><span class="line">// Returns true if healthy, false otherwise.</span><br><span class="line">func (hc *healthChecker) CheckHealth() (bool, error) &#123;</span><br><span class="line">        healthy, err := hc.healthCheckFunc()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return healthy, err</span><br><span class="line">        &#125;</span><br><span class="line">        logPatternHealthy, err := logPatternHealthCheck(hc.service, hc.loopBackTime, hc.logPatternsToCheck)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return logPatternHealthy, err</span><br><span class="line">        &#125;</span><br><span class="line">        if healthy &amp;&amp; logPatternHealthy &#123;</span><br><span class="line">                return true, nil</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // The service is unhealthy.</span><br><span class="line">        // Attempt repair based on flag.</span><br><span class="line">        if hc.enableRepair &#123;</span><br><span class="line">                // repair if the service has been up for the cool down period.</span><br><span class="line">                uptime, err := hc.uptimeFunc()</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        klog.Infof(&quot;error in getting uptime for %v: %v\n&quot;, hc.component, err)</span><br><span class="line">                        return false, nil</span><br><span class="line">                &#125;</span><br><span class="line">                klog.Infof(&quot;%v is unhealthy, component uptime: %v\n&quot;, hc.component, uptime)</span><br><span class="line">                if uptime &gt; hc.coolDownTime &#123;</span><br><span class="line">                        klog.Infof(&quot;%v cooldown period of %v exceeded, repairing&quot;, hc.component, hc.coolDownTime)</span><br><span class="line">                        hc.repairFunc()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查组件的健康状态，返回是否健康，并在不健康的情况下尝试修复。</p>
<p>逻辑：</p>
<ul>
<li>调用 healthCheckFunc 执行健康检查。</li>
<li>使用 logPatternHealthCheck 检查日志模式。</li>
<li>如果组件不健康且启用了修复，检查组件的运行时间并调用修复函数。</li>
</ul>
<h2 id="6-4-logPatternHealthCheck"><a href="#6-4-logPatternHealthCheck" class="headerlink" title="6.4 logPatternHealthCheck"></a>6.4 logPatternHealthCheck</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// logPatternHealthCheck checks for the provided logPattern occurrences in the service logs.</span><br><span class="line">// Returns true if the pattern is empty or does not exist logThresholdCount times since start of service, false otherwise.</span><br><span class="line">func logPatternHealthCheck(service string, loopBackTime time.Duration, logPatternsToCheck map[string]int) (bool, error) &#123;</span><br><span class="line">        if len(logPatternsToCheck) == 0 &#123;</span><br><span class="line">                return true, nil</span><br><span class="line">        &#125;</span><br><span class="line">        uptimeFunc := getUptimeFunc(service)</span><br><span class="line">        klog.Infof(&quot;Getting uptime for service: %v\n&quot;, service)</span><br><span class="line">        uptime, err := uptimeFunc()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                klog.Warningf(&quot;Failed to get the uptime: %+v&quot;, err)</span><br><span class="line">                return true, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logStartTime := time.Now().Add(-uptime).Format(types.LogParsingTimeLayout)</span><br><span class="line">        if loopBackTime &gt; 0 &amp;&amp; uptime &gt; loopBackTime &#123;</span><br><span class="line">                logStartTime = time.Now().Add(-loopBackTime).Format(types.LogParsingTimeLayout)</span><br><span class="line">        &#125;</span><br><span class="line">        for pattern, count := range logPatternsToCheck &#123;</span><br><span class="line">                healthy, err := checkForPattern(service, logStartTime, pattern, count)</span><br><span class="line">                if err != nil || !healthy &#123;</span><br><span class="line">                        return healthy, err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查服务日志中指定模式的出现次数。</p>
<p>参数：</p>
<ul>
<li>service：被监控的服务名称。</li>
<li>loopBackTime：用于确定要检查的日志时间范围。</li>
<li>logPatternsToCheck：要检查的日志模式及其出现的阈值。<br>返回值：布尔值表示健康状态和可能的错误。</li>
</ul>
<h2 id="6-5-healthCheckEndpointOKFunc"><a href="#6-5-healthCheckEndpointOKFunc" class="headerlink" title="6.5 healthCheckEndpointOKFunc"></a>6.5 healthCheckEndpointOKFunc</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:126</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// healthCheckEndpointOKFunc returns a function to check the status of an http endpoint</span><br><span class="line">func healthCheckEndpointOKFunc(endpoint string, timeout time.Duration) func() (bool, error) &#123;</span><br><span class="line">        return func() (bool, error) &#123;</span><br><span class="line">                httpClient := http.Client&#123;Timeout: timeout&#125;</span><br><span class="line">                response, err := httpClient.Get(endpoint)</span><br><span class="line">                if err != nil || response.StatusCode != http.StatusOK &#123;</span><br><span class="line">                        return false, nil</span><br><span class="line">                &#125;</span><br><span class="line">                return true, nil</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回一个函数，该函数检查给定 HTTP 端点的健康状态。</p>
<p>参数：端点 URI 和超时时间。</p>
<p>返回值：健康检查函数。</p>
<h2 id="6-6-getHealthCheckFunc"><a href="#6-6-getHealthCheckFunc" class="headerlink" title="6.6 getHealthCheckFunc"></a>6.6 getHealthCheckFunc</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:138</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// getHealthCheckFunc returns the health check function based on the component.</span><br><span class="line">func getHealthCheckFunc(hco *options.HealthCheckerOptions) func() (bool, error) &#123;</span><br><span class="line">        switch hco.Component &#123;</span><br><span class="line">        case types.KubeletComponent:</span><br><span class="line">                return healthCheckEndpointOKFunc(types.KubeletHealthCheckEndpoint(), hco.HealthCheckTimeout)</span><br><span class="line">        case types.KubeProxyComponent:</span><br><span class="line">                return healthCheckEndpointOKFunc(types.KubeProxyHealthCheckEndpoint(), hco.HealthCheckTimeout)</span><br><span class="line">        case types.DockerComponent:</span><br><span class="line">                return func() (bool, error) &#123;</span><br><span class="line">                        if _, err := execCommand(hco.HealthCheckTimeout, getDockerPath(), &quot;ps&quot;); err != nil &#123;</span><br><span class="line">                                return false, nil</span><br><span class="line">                        &#125;</span><br><span class="line">                        return true, nil</span><br><span class="line">                &#125;</span><br><span class="line">        case types.CRIComponent:</span><br><span class="line">                return func() (bool, error) &#123;</span><br><span class="line">                        _, err := execCommand(</span><br><span class="line">                                hco.HealthCheckTimeout,</span><br><span class="line">                                hco.CriCtlPath,</span><br><span class="line">                                &quot;--timeout=&quot;+hco.CriTimeout.String(),</span><br><span class="line">                                &quot;--runtime-endpoint=&quot;+hco.CriSocketPath,</span><br><span class="line">                                &quot;pods&quot;,</span><br><span class="line">                                &quot;--latest&quot;,</span><br><span class="line">                        )</span><br><span class="line">                        if err != nil &#123;</span><br><span class="line">                                return false, nil</span><br><span class="line">                        &#125;</span><br><span class="line">                        return true, nil</span><br><span class="line">                &#125;</span><br><span class="line">        default:</span><br><span class="line">                klog.Warningf(&quot;Unsupported component: %v&quot;, hco.Component)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据组件类型返回相应的健康检查方法。</p>
<p>参数：健康检查选项。</p>
<p>返回值：执行健康检查的函数。</p>
<h2 id="6-7-execCommand"><a href="#6-7-execCommand" class="headerlink" title="6.7 execCommand"></a>6.7 execCommand</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker.go:174</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// execCommand executes the bash command and returns the (output, error) from command, error if timeout occurs.</span><br><span class="line">func execCommand(timeout time.Duration, command string, args ...string) (string, error) &#123;</span><br><span class="line">        ctx, cancel := context.WithTimeout(context.Background(), timeout)</span><br><span class="line">        defer cancel()</span><br><span class="line">        cmd := exec.CommandContext(ctx, command, args...)</span><br><span class="line">        out, err := cmd.CombinedOutput()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                klog.Infof(&quot;command %v failed: %v, %s\n&quot;, cmd, err, string(out))</span><br><span class="line">                return &quot;&quot;, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return strings.TrimSuffix(string(out), &quot;\n&quot;), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行给定的命令，并在指定的超时时间内返回输出和错误。</p>
<p>参数：超时时间、命令和参数。</p>
<p>返回值：命令的输出和错误信息。</p>
<h2 id="6-8-getUptimeFunc"><a href="#6-8-getUptimeFunc" class="headerlink" title="6.8 getUptimeFunc"></a>6.8 getUptimeFunc</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker_linux.go:32</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// getUptimeFunc returns the time for which the given service has been running.</span><br><span class="line">func getUptimeFunc(service string) func() (time.Duration, error) &#123;</span><br><span class="line">        return func() (time.Duration, error) &#123;</span><br><span class="line">                // Using InactiveExitTimestamp to capture the exact time when systemd tried starting the service. The service will</span><br><span class="line">                // transition from inactive -&gt; activating and the timestamp is captured.</span><br><span class="line">                // Source : https://www.freedesktop.org/wiki/Software/systemd/dbus/</span><br><span class="line">                // Using ActiveEnterTimestamp resulted in race condition where the service was repeatedly killed by plugin when</span><br><span class="line">                // RestartSec of systemd and invoke interval of plugin got in sync. The service was repeatedly killed in</span><br><span class="line">                // activating state and hence ActiveEnterTimestamp was never updated.</span><br><span class="line">                out, err := execCommand(types.CmdTimeout, &quot;systemctl&quot;, &quot;show&quot;, service, &quot;--property=InactiveExitTimestamp&quot;)</span><br><span class="line"></span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        return time.Duration(0), err</span><br><span class="line">                &#125;</span><br><span class="line">                val := strings.Split(out, &quot;=&quot;)</span><br><span class="line">                if len(val) &lt; 2 &#123;</span><br><span class="line">                        return time.Duration(0), errors.New(&quot;could not parse the service uptime time correctly&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                t, err := time.Parse(types.UptimeTimeLayout, val[1])</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        return time.Duration(0), err</span><br><span class="line">                &#125;</span><br><span class="line">                return time.Since(t), nil</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回一个函数，计算指定服务的运行时间。</p>
<p>参数：</p>
<ul>
<li><p>service string - 被监控服务的名称。</p>
</li>
<li><p>返回值：返回一个函数，该函数返回服务运行的持续时间或错误。</p>
</li>
<li><p>实现细节</p>
</li>
<li><p>使用 systemctl show 命令获取 InactiveExitTimestamp，这是服务从 inactive 状态转换时的时间戳。</p>
</li>
<li><p>解析命令的输出，将时间戳转换为 time.Time 类型，并计算自该时间以来的持续时间。</p>
</li>
<li><p>此方法可用于获取服务的当前运行时间，以便评估是否在修复之前达到冷却时间。</p>
</li>
</ul>
<h2 id="6-9-getRepairFunc"><a href="#6-9-getRepairFunc" class="headerlink" title="6.9 getRepairFunc"></a>6.9 getRepairFunc</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker_linux.go:58</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// getRepairFunc returns the repair function based on the component.</span><br><span class="line">func getRepairFunc(hco *options.HealthCheckerOptions) func() &#123;</span><br><span class="line">        // Use `systemctl kill` instead of `systemctl restart` for the repair function.</span><br><span class="line">        // We start to rely on the kernel message difference for the two commands to</span><br><span class="line">        // indicate if the component restart is due to an administrative plan (restart)</span><br><span class="line">        // or a system issue that needs repair (kill).</span><br><span class="line">        // See https://github.com/kubernetes/node-problem-detector/issues/847.</span><br><span class="line">        switch hco.Component &#123;</span><br><span class="line">        case types.DockerComponent:</span><br><span class="line">                // Use &quot;docker ps&quot; for docker health check. Not using crictl for docker to remove</span><br><span class="line">                // dependency on the kubelet.</span><br><span class="line">                return func() &#123;</span><br><span class="line">                        execCommand(types.CmdTimeout, &quot;pkill&quot;, &quot;-SIGUSR1&quot;, &quot;dockerd&quot;)</span><br><span class="line">                        execCommand(types.CmdTimeout, &quot;systemctl&quot;, &quot;kill&quot;, &quot;--kill-who=main&quot;, hco.Service)</span><br><span class="line">                &#125;</span><br><span class="line">        default:</span><br><span class="line">                // Just kill the service for all other components</span><br><span class="line">                return func() &#123;</span><br><span class="line">                        execCommand(types.CmdTimeout, &quot;systemctl&quot;, &quot;kill&quot;, &quot;--kill-who=main&quot;, hco.Service)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据服务的组件类型返回一个演示修复功能的方法。</p>
<p>参数：</p>
<ul>
<li>hco *options.HealthCheckerOptions - 健康检查的选项。</li>
<li>返回值：返回一个函数，该函数执行相应修复操作。</li>
</ul>
<p>实现细节</p>
<ul>
<li>对于 Docker 组件，通过 pkill 发送 SIGUSR1 信号以更优雅地停止 Docker 守护进程。</li>
<li>对于其他组件，调用 systemctl kill 命令终止主要进程。</li>
<li>这种设计使得修复功能能够根据不同的组件采取合适的处理方式。</li>
</ul>
<h2 id="6-10-checkForPattern"><a href="#6-10-checkForPattern" class="headerlink" title="6.10 checkForPattern"></a>6.10 checkForPattern</h2><p>pkg&#x2F;healthchecker&#x2F;health_checker_linux.go:82</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// checkForPattern returns (true, nil) if logPattern occurs less than logCountThreshold number of times since last</span><br><span class="line">// service restart. (false, nil) otherwise.</span><br><span class="line">func checkForPattern(service, logStartTime, logPattern string, logCountThreshold int) (bool, error) &#123;</span><br><span class="line">        out, err := execCommand(types.CmdTimeout, &quot;/bin/sh&quot;, &quot;-c&quot;,</span><br><span class="line">                // Query service logs since the logStartTime</span><br><span class="line">                `journalctl --unit &quot;`+service+`&quot; --since &quot;`+logStartTime+</span><br><span class="line">                        // Grep the pattern</span><br><span class="line">                        `&quot; | grep -i &quot;`+logPattern+</span><br><span class="line">                        // Get the count of occurrences</span><br><span class="line">                        `&quot; | wc -l`)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return true, err</span><br><span class="line">        &#125;</span><br><span class="line">        occurrences, err := strconv.Atoi(out)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return true, err</span><br><span class="line">        &#125;</span><br><span class="line">        if occurrences &gt;= logCountThreshold &#123;</span><br><span class="line">                klog.Infof(&quot;%s failed log pattern check, %s occurrences: %v&quot;, service, logPattern, occurrences)</span><br><span class="line">                return false, nil</span><br><span class="line">        &#125;</span><br><span class="line">        return true, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查指定服务的日志中是否包含特定模式，并返回其出现次数是否达到阈值。</p>
<p>参数：</p>
<ul>
<li>service：被监控服务的名称。</li>
<li>logStartTime：起始时间，用于过滤日志。</li>
<li>logPattern：需要检查的日志模式。</li>
<li>logCountThreshold：模式出现的最大次数阈值。</li>
<li>返回值：返回一个布尔值，指示是否健康，以及可能的错误。</li>
</ul>
<p>实现细节</p>
<ul>
<li>使用 journalctl 命令获取从指定时间开始的服务日志，并通过 grep 过滤符合条件的日志模式。</li>
<li>使用 wc -l 计算匹配的行数。</li>
<li>如果日志模式出现的次数大于阈值，记录相关信息并返回健康检查失败的结果。</li>
</ul>
<h1 id="7-logcounter"><a href="#7-logcounter" class="headerlink" title="7 logcounter"></a>7 logcounter</h1><h2 id="7-1-logCounter定义"><a href="#7-1-logCounter定义" class="headerlink" title="7.1 logCounter定义"></a>7.1 logCounter定义</h2><p>pkg&#x2F;logcounter&#x2F;log_counter.go:42</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type logCounter struct &#123;</span><br><span class="line">        logCh         &lt;-chan *systemtypes.Log</span><br><span class="line">        buffer        systemlogmonitor.LogBuffer</span><br><span class="line">        pattern       string</span><br><span class="line">        revertPattern string</span><br><span class="line">        clock         clock.Clock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字段解释：</p>
<ul>
<li>logCh：只读通道，用于接收系统日志。</li>
<li>buffer：存储日志的缓冲区，以便分析和计数。</li>
<li>pattern：处理日志时使用的匹配模式。</li>
<li>revertPattern：可用来反向计数的模式。</li>
<li>clock：用于获取当前时间的时钟，支持模拟时钟功能。</li>
</ul>
<h2 id="7-2-NewJournaldLogCounter"><a href="#7-2-NewJournaldLogCounter" class="headerlink" title="7.2 NewJournaldLogCounter"></a>7.2 NewJournaldLogCounter</h2><p>pkg&#x2F;logcounter&#x2F;log_counter.go:50</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func NewJournaldLogCounter(options *options.LogCounterOptions) (types.LogCounter, error) &#123;</span><br><span class="line">        watcher := journald.NewJournaldWatcher(watchertypes.WatcherConfig&#123;</span><br><span class="line">                Plugin:       &quot;journald&quot;,</span><br><span class="line">                PluginConfig: map[string]string&#123;journaldSourceKey: options.JournaldSource&#125;,</span><br><span class="line">                LogPath:      options.LogPath,</span><br><span class="line">                Lookback:     options.Lookback,</span><br><span class="line">                Delay:        options.Delay,</span><br><span class="line">        &#125;)</span><br><span class="line">        logCh, err := watcher.Watch()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return nil, fmt.Errorf(&quot;error watching journald: %v&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">        return &amp;logCounter&#123;</span><br><span class="line">                logCh:         logCh,</span><br><span class="line">                buffer:        systemlogmonitor.NewLogBuffer(bufferSize),</span><br><span class="line">                pattern:       options.Pattern,</span><br><span class="line">                revertPattern: options.RevertPattern,</span><br><span class="line">                clock:         clock.RealClock&#123;&#125;,</span><br><span class="line">        &#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化并返回一个新的 logCounter 实例。</p>
<p>参数：</p>
<ul>
<li>options *options.LogCounterOptions - 包含配置信息（例如日志源、路径、模式等）。</li>
<li>返回值：返回一个实现了 types.LogCounter 接口的 logCounter 实例。</li>
</ul>
<p>实现细节</p>
<ul>
<li>创建一个 journald 日志观察者实例来监控指定的日志路径。</li>
<li>如果监视操作成功，建立日志通道并创建 logCounter 的实例，设置缓冲区、匹配模式等。</li>
</ul>
<h2 id="7-3-Count"><a href="#7-3-Count" class="headerlink" title="7.3 Count"></a>7.3 Count</h2><p>pkg&#x2F;logcounter&#x2F;log_counter.go:71</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func (e *logCounter) Count() (count int, err error) &#123;</span><br><span class="line">        start := e.clock.Now()</span><br><span class="line">        for &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case log, ok := &lt;-e.logCh:</span><br><span class="line">                        if !ok &#123;</span><br><span class="line">                                err = fmt.Errorf(&quot;log channel closed unexpectedly&quot;)</span><br><span class="line">                                return</span><br><span class="line">                        &#125;</span><br><span class="line">                        if start.Before(log.Timestamp) &#123;</span><br><span class="line">                                return</span><br><span class="line">                        &#125;</span><br><span class="line">                        e.buffer.Push(log)</span><br><span class="line">                        if len(e.buffer.Match(e.pattern)) != 0 &#123;</span><br><span class="line">                                count++</span><br><span class="line">                        &#125;</span><br><span class="line">                        if e.revertPattern != &quot;&quot; &amp;&amp; len(e.buffer.Match(e.revertPattern)) != 0 &#123;</span><br><span class="line">                                count--</span><br><span class="line">                        &#125;</span><br><span class="line">                case &lt;-e.clock.After(timeout):</span><br><span class="line">                        return</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计在运行期间匹配的日志条目数量。</p>
<p>返回值：返回符合条件的日志计数及任何潜在的错误。</p>
<p>实现细节</p>
<ul>
<li>使用当前时间 (start) 记录开始时刻。</li>
<li>在无限循环中，使用 select 语句监听日志通道和超时事件。</li>
<li>如果从 logCh 读取到日志：<ul>
<li>检查通道是否已经关闭。</li>
<li>如果读取到的日志时间戳晚于开始时间，则停止计数。</li>
<li>将日志条目压入缓冲区。</li>
<li>检查当前日志是否与模式匹配，如果匹配则计数加一；如果匹配反向模式，则计数减一。</li>
<li>如果在超时时间内没有收到新日志，结束循环并返回计数。</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>kubebuilder的makefile文件</title>
    <url>/2025/07/kubernetes/Operator%E5%BC%80%E5%8F%91/kubebuilder%E7%9A%84makefile%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="1、Makefile简介"><a href="#1、Makefile简介" class="headerlink" title="1、Makefile简介"></a>1、Makefile简介</h1><p>Makefile 是一种用于自动化构建软件项目的文件。它通常用于管理和执行编译、链接、测试等一系列任务，以提高开发效率。</p>
<h2 id="1-1-目标与依赖"><a href="#1-1-目标与依赖" class="headerlink" title="1.1 目标与依赖"></a>1.1 目标与依赖</h2><h3 id="1-1-1目标（Targets）"><a href="#1-1-1目标（Targets）" class="headerlink" title="1.1.1目标（Targets）"></a>1.1.1目标（Targets）</h3><ul>
<li>代表一个任务或一个文件的生成结果。例如，编译生成的可执行文件、库文件等都可以是目标。</li>
<li>常见的目标有 “all”（表示构建整个项目）、“clean”（用于清理生成的文件）等。</li>
</ul>
<h3 id="1-1-2-依赖（Dependencies）"><a href="#1-1-2-依赖（Dependencies）" class="headerlink" title="1.1.2 依赖（Dependencies）"></a>1.1.2 依赖（Dependencies）</h3><ul>
<li>目标所依赖的其他文件或目标。只有当依赖发生变化时，才会重新执行生成目标的命令。</li>
<li>例如，一个可执行文件可能依赖于多个源文件和库文件。</li>
</ul>
<h2 id="1-2-规则与命令"><a href="#1-2-规则与命令" class="headerlink" title="1.2 规则与命令"></a>1.2 规则与命令</h2><h3 id="1-2-1-规则（Rules）"><a href="#1-2-1-规则（Rules）" class="headerlink" title="1.2.1 规则（Rules）"></a>1.2.1 规则（Rules）</h3><ul>
<li>描述了如何从依赖生成目标。通常由目标、依赖和命令三部分组成。</li>
<li>格式一般为：target: dependencies，接着是命令部分，每行命令前面必须以制表符（Tab）开头。</li>
</ul>
<h3 id="1-2-2-命令（Commands）"><a href="#1-2-2-命令（Commands）" class="headerlink" title="1.2.2 命令（Commands）"></a>1.2.2 命令（Commands）</h3><ul>
<li>用于执行生成目标的具体操作。可以是编译器命令、链接器命令、文件复制命令等。</li>
<li>例如，编译 C 语言源文件的命令可能是gcc -o target source.c。</li>
</ul>
<h2 id="1-3-变量与函数"><a href="#1-3-变量与函数" class="headerlink" title="1.3 变量与函数"></a>1.3 变量与函数</h2><h3 id="1-3-1-变量（Variables）"><a href="#1-3-1-变量（Variables）" class="headerlink" title="1.3.1 变量（Variables）"></a>1.3.1 变量（Variables）</h3><ul>
<li>可以定义和使用变量来存储常用的值，如编译器名称、编译选项、源文件列表等。</li>
<li>变量定义方式为VARIABLE &#x3D; value，使用时用$(VARIABLE)。</li>
</ul>
<h3 id="1-3-2-函数（Functions）"><a href="#1-3-2-函数（Functions）" class="headerlink" title="1.3.2 函数（Functions）"></a>1.3.2 函数（Functions）</h3><ul>
<li>Makefile 提供了一些内置函数，可以进行字符串处理、文件操作等。</li>
<li>例如，$(wildcard *.c)可以获取当前目录下所有的 C 语言源文件。</li>
</ul>
<h2 id="1-4-优势"><a href="#1-4-优势" class="headerlink" title="1.4 优势"></a>1.4 优势</h2><h3 id="1-4-1-自动化构建"><a href="#1-4-1-自动化构建" class="headerlink" title="1.4.1 自动化构建"></a>1.4.1 自动化构建</h3><ul>
<li>可以自动执行一系列构建步骤，减少手动操作和错误。</li>
<li>当源文件发生变化时，只重新构建受影响的部分，提高构建效率。</li>
</ul>
<h3 id="1-4-2-可重复性"><a href="#1-4-2-可重复性" class="headerlink" title="1.4.2 可重复性"></a>1.4.2 可重复性</h3><p>确保在不同的环境中都能以相同的方式构建项目。</p>
<h3 id="1-4-3-易于维护"><a href="#1-4-3-易于维护" class="headerlink" title="1.4.3 易于维护"></a>1.4.3 易于维护</h3><p>项目的构建过程集中在一个文件中，便于修改和管理。</p>
<h1 id="2、kubebuilder-makefile"><a href="#2、kubebuilder-makefile" class="headerlink" title="2、kubebuilder makefile"></a>2、kubebuilder makefile</h1><h2 id="2-1-kubebuilder-项目makefile"><a href="#2-1-kubebuilder-项目makefile" class="headerlink" title="2.1 kubebuilder 项目makefile"></a>2.1 kubebuilder 项目makefile</h2><p>一个kubebuilder创建的operator项目的makefile文件内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Image URL to use all building/pushing image targets</span></span><br><span class="line">IMG ?= controller:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ENVTEST_K8S_VERSION refers to the version of kubebuilder assets to be downloaded by envtest binary.</span></span><br><span class="line">ENVTEST_K8S_VERSION = 1.31.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Get the currently used golang install path (<span class="keyword">in</span> GOPATH/bin, unless GOBIN is <span class="built_in">set</span>)</span></span><br><span class="line">ifeq (,$(shell go env GOBIN))</span><br><span class="line">GOBIN=$(shell go env GOPATH)/bin</span><br><span class="line">else</span><br><span class="line">GOBIN=$(shell go env GOBIN)</span><br><span class="line">endif</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONTAINER_TOOL defines the container tool to be used <span class="keyword">for</span> building images.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Be aware that the target commands are only tested with Docker <span class="built_in">which</span> is</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">scaffolded by default. However, you might want to replace it to use other</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tools. (i.e. podman)</span></span><br><span class="line">CONTAINER_TOOL ?= docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Setting SHELL to bash allows bash commands to be executed by recipes.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Options are <span class="built_in">set</span> to <span class="built_in">exit</span> when a recipe line exits non-zero or a piped <span class="built_in">command</span> fails.</span></span><br><span class="line">SHELL = /usr/bin/env bash -o pipefail</span><br><span class="line">.SHELLFLAGS = -ec</span><br><span class="line"></span><br><span class="line">.PHONY: all</span><br><span class="line">all: build</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#@ General</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The <span class="built_in">help</span> target prints out all targets with their descriptions organized</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">beneath their categories. The categories are represented by <span class="string">&#x27;##@&#x27;</span> and the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target descriptions by <span class="string">&#x27;##&#x27;</span>. The awk <span class="built_in">command</span> is responsible <span class="keyword">for</span> reading the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">entire <span class="built_in">set</span> of makefiles included <span class="keyword">in</span> this invocation, looking <span class="keyword">for</span> lines of the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file as xyz: <span class="comment">## something, and then pretty-format the target and help. Then,</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span> there<span class="string">&#x27;s a line with ##@ something, that gets pretty-printed as a category.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">More info on the usage of ANSI control characters for terminal formatting:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">More info on the awk command:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">http://linuxcommand.org/lc3_adv_awk.php</span></span></span><br><span class="line"></span><br><span class="line">.PHONY: help</span><br><span class="line">help: ## Display this help.</span><br><span class="line">        @awk &#x27;BEGIN &#123;FS = &quot;:.*##&quot;; printf &quot;\nUsage:\n  make \033[36m&lt;target&gt;\033[0m\n&quot;&#125; /^[a-zA-Z_0-9-]+:.*?##/ &#123; printf &quot;  \033[36m%-15s\033[0m %s\n&quot;, $$1, $$2 &#125; /^##@/ &#123; printf &quot;\n\033[1m%s\033[0m\n&quot;, substr($$0, 5) &#125; &#x27; $(MAKEFILE_LIST)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">#@ Development</span></span></span><br><span class="line"></span><br><span class="line">.PHONY: manifests</span><br><span class="line">manifests: controller-gen ## Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects.</span><br><span class="line">        $(CONTROLLER_GEN) rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line"></span><br><span class="line">.PHONY: generate</span><br><span class="line">generate: controller-gen ## Generate code containing DeepCopy, DeepCopyInto, and DeepCopyObject method implementations.</span><br><span class="line">        $(CONTROLLER_GEN) object:headerFile=&quot;hack/boilerplate.go.txt&quot; paths=&quot;./...&quot;</span><br><span class="line"></span><br><span class="line">.PHONY: fmt</span><br><span class="line">fmt: ## Run go fmt against code.</span><br><span class="line">        go fmt ./...</span><br><span class="line"></span><br><span class="line">.PHONY: vet</span><br><span class="line">vet: ## Run go vet against code.</span><br><span class="line">        go vet ./...</span><br><span class="line"></span><br><span class="line">.PHONY: test</span><br><span class="line">test: manifests generate fmt vet envtest ## Run tests.</span><br><span class="line">        KUBEBUILDER_ASSETS=&quot;$(shell $(ENVTEST) use $(ENVTEST_K8S_VERSION) --bin-dir $(LOCALBIN) -p path)&quot; go test $$(go list ./... | grep -v /e2e) -coverprofile cover.out</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Utilize Kind or modify the e2e tests to load the image locally, enabling compatibility with other vendors.</span></span></span><br><span class="line">.PHONY: test-e2e  # Run the e2e tests against a Kind k8s instance that is spun up.</span><br><span class="line">test-e2e:</span><br><span class="line">        go test ./test/e2e/ -v -ginkgo.v</span><br><span class="line"></span><br><span class="line">.PHONY: lint</span><br><span class="line">lint: golangci-lint ## Run golangci-lint linter</span><br><span class="line">        $(GOLANGCI_LINT) run</span><br><span class="line"></span><br><span class="line">.PHONY: lint-fix</span><br><span class="line">lint-fix: golangci-lint ## Run golangci-lint linter and perform fixes</span><br><span class="line">        $(GOLANGCI_LINT) run --fix</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">#@ Build</span></span></span><br><span class="line"></span><br><span class="line">.PHONY: build</span><br><span class="line">build: manifests generate fmt vet ## Build manager binary.</span><br><span class="line">        go build -o bin/manager cmd/main.go</span><br><span class="line"></span><br><span class="line">.PHONY: run</span><br><span class="line">run: manifests generate fmt vet ## Run a controller from your host.</span><br><span class="line">        go run ./cmd/main.go</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">If you wish to build the manager image targeting other platforms you can use the --platform flag.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">(i.e. docker build --platform linux/arm64). However, you must enable docker buildKit for it.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">More info: https://docs.docker.com/develop/develop-images/build_enhancements/</span></span></span><br><span class="line">.PHONY: docker-build</span><br><span class="line">docker-build: ## Build docker image with the manager.</span><br><span class="line">        $(CONTAINER_TOOL) build -t $&#123;IMG&#125; .</span><br><span class="line"></span><br><span class="line">.PHONY: docker-push</span><br><span class="line">docker-push: ## Push docker image with the manager.</span><br><span class="line">        $(CONTAINER_TOOL) push $&#123;IMG&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">PLATFORMS defines the target platforms for the manager image be built to provide support to multiple</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">architectures. (i.e. make docker-buildx IMG=myregistry/mypoperator:0.0.1). To use this option you need to:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">- be able to use docker buildx. More info: https://docs.docker.com/build/buildx/</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">- have enabled BuildKit. More info: https://docs.docker.com/develop/develop-images/build_enhancements/</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">- be able to push the image to your registry (i.e. if you do not set a valid value via IMG=&lt;myregistry/image:&lt;tag&gt;&gt; then the export will fail)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">To adequately provide solutions that are compatible with multiple platforms, you should consider using this option.</span></span></span><br><span class="line">PLATFORMS ?= linux/arm64,linux/amd64,linux/s390x,linux/ppc64le</span><br><span class="line">.PHONY: docker-buildx</span><br><span class="line">docker-buildx: ## Build and push docker image for the manager for cross-platform support</span><br><span class="line">        # copy existing Dockerfile and insert --platform=$&#123;BUILDPLATFORM&#125; into Dockerfile.cross, and preserve the original Dockerfile</span><br><span class="line">        sed -e &#x27;1 s/\(^FROM\)/FROM --platform=\$$\&#123;BUILDPLATFORM\&#125;/; t&#x27; -e &#x27; 1,// s//FROM --platform=\$$\&#123;BUILDPLATFORM\&#125;/&#x27; Dockerfile &gt; Dockerfile.cross</span><br><span class="line">        - $(CONTAINER_TOOL) buildx create --name myapp-operator-builder</span><br><span class="line">        $(CONTAINER_TOOL) buildx use myapp-operator-builder</span><br><span class="line">        - $(CONTAINER_TOOL) buildx build --push --platform=$(PLATFORMS) --tag $&#123;IMG&#125; -f Dockerfile.cross .</span><br><span class="line">        - $(CONTAINER_TOOL) buildx rm myapp-operator-builder</span><br><span class="line">        rm Dockerfile.cross</span><br><span class="line"></span><br><span class="line">.PHONY: build-installer</span><br><span class="line">build-installer: manifests generate kustomize ## Generate a consolidated YAML with CRDs and deployment.</span><br><span class="line">        mkdir -p dist</span><br><span class="line">        cd config/manager &amp;&amp; $(KUSTOMIZE) edit set image controller=$&#123;IMG&#125;</span><br><span class="line">        $(KUSTOMIZE) build config/default &gt; dist/install.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">#@ Deployment</span></span></span><br><span class="line"></span><br><span class="line">ifndef ignore-not-found</span><br><span class="line">  ignore-not-found = false</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">.PHONY: install</span><br><span class="line">install: manifests kustomize ## Install CRDs into the K8s cluster specified in ~/.kube/config.</span><br><span class="line">        $(KUSTOMIZE) build config/crd | $(KUBECTL) apply -f -</span><br><span class="line"></span><br><span class="line">.PHONY: uninstall</span><br><span class="line">uninstall: manifests kustomize ## Uninstall CRDs from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found=true to ignore resource not found errors during deletion.</span><br><span class="line">        $(KUSTOMIZE) build config/crd | $(KUBECTL) delete --ignore-not-found=$(ignore-not-found) -f -</span><br><span class="line"></span><br><span class="line">.PHONY: deploy</span><br><span class="line">deploy: manifests kustomize ## Deploy controller to the K8s cluster specified in ~/.kube/config.</span><br><span class="line">        cd config/manager &amp;&amp; $(KUSTOMIZE) edit set image controller=$&#123;IMG&#125;</span><br><span class="line">        $(KUSTOMIZE) build config/default | $(KUBECTL) apply -f -</span><br><span class="line"></span><br><span class="line">.PHONY: undeploy</span><br><span class="line">undeploy: kustomize ## Undeploy controller from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found=true to ignore resource not found errors during deletion.</span><br><span class="line">        $(KUSTOMIZE) build config/default | $(KUBECTL) delete --ignore-not-found=$(ignore-not-found) -f -</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">#@ Dependencies</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"># Location to install dependencies to</span></span></span><br><span class="line">LOCALBIN ?= $(shell pwd)/bin</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">(LOCALBIN):</span></span></span><br><span class="line">        mkdir -p $(LOCALBIN)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"># Tool Binaries</span></span></span><br><span class="line">KUBECTL ?= kubectl</span><br><span class="line">KUSTOMIZE ?= $(LOCALBIN)/kustomize</span><br><span class="line">CONTROLLER_GEN ?= $(LOCALBIN)/controller-gen</span><br><span class="line">ENVTEST ?= $(LOCALBIN)/setup-envtest</span><br><span class="line">GOLANGCI_LINT = $(LOCALBIN)/golangci-lint</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"># Tool Versions</span></span></span><br><span class="line">KUSTOMIZE_VERSION ?= v5.4.3</span><br><span class="line">CONTROLLER_TOOLS_VERSION ?= v0.16.1</span><br><span class="line">ENVTEST_VERSION ?= release-0.19</span><br><span class="line">GOLANGCI_LINT_VERSION ?= v1.59.1</span><br><span class="line"></span><br><span class="line">.PHONY: kustomize</span><br><span class="line">kustomize: $(KUSTOMIZE) ## Download kustomize locally if necessary.</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">(KUSTOMIZE): $(LOCALBIN)</span></span></span><br><span class="line">        $(call go-install-tool,$(KUSTOMIZE),sigs.k8s.io/kustomize/kustomize/v5,$(KUSTOMIZE_VERSION))</span><br><span class="line"></span><br><span class="line">.PHONY: controller-gen</span><br><span class="line">controller-gen: $(CONTROLLER_GEN) ## Download controller-gen locally if necessary.</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">(CONTROLLER_GEN): $(LOCALBIN)</span></span></span><br><span class="line">        $(call go-install-tool,$(CONTROLLER_GEN),sigs.k8s.io/controller-tools/cmd/controller-gen,$(CONTROLLER_TOOLS_VERSION))</span><br><span class="line"></span><br><span class="line">.PHONY: envtest</span><br><span class="line">envtest: $(ENVTEST) ## Download setup-envtest locally if necessary.</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">(ENVTEST): $(LOCALBIN)</span></span></span><br><span class="line">        $(call go-install-tool,$(ENVTEST),sigs.k8s.io/controller-runtime/tools/setup-envtest,$(ENVTEST_VERSION))</span><br><span class="line"></span><br><span class="line">.PHONY: golangci-lint</span><br><span class="line">golangci-lint: $(GOLANGCI_LINT) ## Download golangci-lint locally if necessary.</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">(GOLANGCI_LINT): $(LOCALBIN)</span></span></span><br><span class="line">        $(call go-install-tool,$(GOLANGCI_LINT),github.com/golangci/golangci-lint/cmd/golangci-lint,$(GOLANGCI_LINT_VERSION))</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">go-install-tool will &#x27;</span>go install<span class="string">&#x27; any package with custom target and name of binary, if it doesn&#x27;</span>t exist</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$1</span> - target path with name of binary</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$2</span> - package url <span class="built_in">which</span> can be installed</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$3</span> - specific version of package</span></span><br><span class="line">define go-install-tool</span><br><span class="line">@[ -f &quot;$(1)-$(3)&quot; ] || &#123; \</span><br><span class="line">set -e; \</span><br><span class="line">package=$(2)@$(3) ;\</span><br><span class="line">echo &quot;Downloading $$&#123;package&#125;&quot; ;\</span><br><span class="line">rm -f $(1) || true ;\</span><br><span class="line">GOBIN=$(LOCALBIN) go install $$&#123;package&#125; ;\</span><br><span class="line">mv $(1) $(1)-$(3) ;\</span><br><span class="line">&#125; ;\</span><br><span class="line">ln -sf $(1)-$(3) $(1)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<h2 id="2-2-变量定义部分"><a href="#2-2-变量定义部分" class="headerlink" title="2.2 变量定义部分"></a>2.2 变量定义部分</h2><h3 id="2-2-1-IMG（定义构建和推送Docker镜像的目标镜像URL）"><a href="#2-2-1-IMG（定义构建和推送Docker镜像的目标镜像URL）" class="headerlink" title="2.2.1 IMG（定义构建和推送Docker镜像的目标镜像URL）"></a>2.2.1 IMG（定义构建和推送Docker镜像的目标镜像URL）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Image URL to use all building/pushing image targets</span></span><br><span class="line">IMG ?= controller:latest</span><br></pre></td></tr></table></figure>
<p>作用：定义构建和推送Docker镜像的目标镜像URL<br>解释：如果没有在命令中指定IMG，则默认值为controller:latest</p>
<h3 id="2-2-2-ENVTEST-K8S-VERSION（定义envtest工具下载的Kubernetes资产版本）"><a href="#2-2-2-ENVTEST-K8S-VERSION（定义envtest工具下载的Kubernetes资产版本）" class="headerlink" title="2.2.2 ENVTEST_K8S_VERSION（定义envtest工具下载的Kubernetes资产版本）"></a>2.2.2 ENVTEST_K8S_VERSION（定义envtest工具下载的Kubernetes资产版本）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ENVTEST_K8S_VERSION refers to the version of kubebuilder assets to be downloaded by envtest binary.</span></span><br><span class="line">ENVTEST_K8S_VERSION = 1.31.0</span><br></pre></td></tr></table></figure>
<p>作用：定义envtest工具下载的Kubernetes资产版本<br>解释：envtest是一个用于测试的工具，这个变量制定了要下载的Kubernetes版本。</p>
<h3 id="2-2-3-GOBIN（当前使用的Go的安装路径）"><a href="#2-2-3-GOBIN（当前使用的Go的安装路径）" class="headerlink" title="2.2.3 GOBIN（当前使用的Go的安装路径）"></a>2.2.3 GOBIN（当前使用的Go的安装路径）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Get the currently used golang install path (<span class="keyword">in</span> GOPATH/bin, unless GOBIN is <span class="built_in">set</span>)</span></span><br><span class="line">ifeq (,$(shell go env GOBIN))</span><br><span class="line">GOBIN=$(shell go env GOPATH)/bin</span><br><span class="line">else</span><br><span class="line">GOBIN=$(shell go env GOBIN)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>作用：获取当前使用的Go的安装路径<br>解释：如果GONBIN环境变量未设置，则使用GOPATCH&#x2F;bin作为默认路径；否则使用GOBIN的值。</p>
<h3 id="2-2-4-CONTAINER-TOOL（用于构建镜像的容器工具）"><a href="#2-2-4-CONTAINER-TOOL（用于构建镜像的容器工具）" class="headerlink" title="2.2.4 CONTAINER_TOOL（用于构建镜像的容器工具）"></a>2.2.4 CONTAINER_TOOL（用于构建镜像的容器工具）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONTAINER_TOOL defines the container tool to be used <span class="keyword">for</span> building images.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Be aware that the target commands are only tested with Docker <span class="built_in">which</span> is</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">scaffolded by default. However, you might want to replace it to use other</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tools. (i.e. podman)</span></span><br><span class="line">CONTAINER_TOOL ?= docker</span><br></pre></td></tr></table></figure>

<p>作用：定义用于构建镜像的容器工具<br>解释：默认值为docker，但是可以替换为其他工具，例如podman</p>
<h3 id="2-2-5-SHELL-和-SHELLFLAGS（设置Makefile使用的shell和shell选项）"><a href="#2-2-5-SHELL-和-SHELLFLAGS（设置Makefile使用的shell和shell选项）" class="headerlink" title="2.2.5 SHELL 和 .SHELLFLAGS（设置Makefile使用的shell和shell选项）"></a>2.2.5 SHELL 和 .SHELLFLAGS（设置Makefile使用的shell和shell选项）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Setting SHELL to bash allows bash commands to be executed by recipes.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Options are <span class="built_in">set</span> to <span class="built_in">exit</span> when a recipe line exits non-zero or a piped <span class="built_in">command</span> fails.</span></span><br><span class="line">SHELL = /usr/bin/env bash -o pipefail</span><br><span class="line">.SHELLFLAGS = -ec</span><br></pre></td></tr></table></figure>

<p>作用：设置Makefile使用的shell和shell选项<br>解释：</p>
<ul>
<li>SHELL设置为&#x2F;usr&#x2F;bin&#x2F;env bash -o pipefail</li>
<li>.SHELLFLAGS 设置为-ec，表示shell应该立即退出并在任何命令失败时报告错误</li>
</ul>
<h2 id="2-3-目标定义部分"><a href="#2-3-目标定义部分" class="headerlink" title="2.3 目标定义部分"></a>2.3 目标定义部分</h2><h3 id="2-3-1-通用目标"><a href="#2-3-1-通用目标" class="headerlink" title="2.3.1 通用目标"></a>2.3.1 通用目标</h3><h4 id="2-3-1-1-all（定义默认目标，调用build目标）"><a href="#2-3-1-1-all（定义默认目标，调用build目标）" class="headerlink" title="2.3.1.1 all（定义默认目标，调用build目标）"></a>2.3.1.1 all（定义默认目标，调用build目标）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">all: build</span><br></pre></td></tr></table></figure>
<p>作用：定义默认目标，调用build目标<br>解释：当运行make时，如果没有指定目标。默认会执行build目标。</p>
<h4 id="2-3-1-2-help（显示帮助信息）"><a href="#2-3-1-2-help（显示帮助信息）" class="headerlink" title="2.3.1.2 help（显示帮助信息）"></a>2.3.1.2 help（显示帮助信息）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: help</span><br><span class="line">help: ## Display this help.</span><br><span class="line">        @awk &#x27;BEGIN &#123;FS = &quot;:.*##&quot;; printf &quot;\nUsage:\n  make \033[36m&lt;target&gt;\033[0m\n&quot;&#125; /^[a-zA-Z_0-9-]+:.*?##/ &#123; printf &quot;  \033[36m%-15s\033[0m %s\n&quot;, $$1, $$2 &#125; /^##@/ &#123; printf &quot;\n\033[1m%s\033[0m\n&quot;, substr($$0, 5) &#125; &#x27; $(MAKEFILE_LIST)</span><br></pre></td></tr></table></figure>
<p>作用：显示帮助信息<br>解释：使用awk命令解析Makefile,提取每个目标的描述，并按类别组织显示。##@表示类别，##表示目标描述</p>
<h3 id="2-3-2-开发目标"><a href="#2-3-2-开发目标" class="headerlink" title="2.3.2 开发目标"></a>2.3.2 开发目标</h3><h4 id="2-3-2-1-manifests（生成WebhookConfiguration、ClusterRole和CustomResourceDefinition-对象）"><a href="#2-3-2-1-manifests（生成WebhookConfiguration、ClusterRole和CustomResourceDefinition-对象）" class="headerlink" title="2.3.2.1 manifests（生成WebhookConfiguration、ClusterRole和CustomResourceDefinition 对象）"></a>2.3.2.1 manifests（生成WebhookConfiguration、ClusterRole和CustomResourceDefinition 对象）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: manifests</span><br><span class="line">manifests: controller-gen ## Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects.</span><br><span class="line">        $(CONTROLLER_GEN) rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br></pre></td></tr></table></figure>
<p>作用：生成WebhookConfiguration、ClusterRole和CustomResourceDefinition 对象<br>解释：使用controller-gen工具生成必要的Kubernetes资源文件，并保存到config&#x2F;crd&#x2F;bases目录</p>
<h4 id="2-3-2-2-generate（生成包含DeepCopy、DeepCopyInto-和DeepCopyObject方法实现的代码。）"><a href="#2-3-2-2-generate（生成包含DeepCopy、DeepCopyInto-和DeepCopyObject方法实现的代码。）" class="headerlink" title="2.3.2.2 generate（生成包含DeepCopy、DeepCopyInto, 和DeepCopyObject方法实现的代码。）"></a>2.3.2.2 generate（生成包含DeepCopy、DeepCopyInto, 和DeepCopyObject方法实现的代码。）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: generate</span><br><span class="line">generate: controller-gen ## Generate code containing DeepCopy, DeepCopyInto, and DeepCopyObject method implementations.</span><br><span class="line">        $(CONTROLLER_GEN) object:headerFile=&quot;hack/boilerplate.go.txt&quot; paths=&quot;./...&quot;</span><br></pre></td></tr></table></figure>
<p>作用：生成包含DeepCopy、DeepCopyInto, 和DeepCopyObject方法实现的代码。<br>解释：使用controller-gen工具生成GO代码，这些代码自动生成对象的深拷贝方法。</p>
<h4 id="2-3-2-3-fmt（格式化代码）"><a href="#2-3-2-3-fmt（格式化代码）" class="headerlink" title="2.3.2.3 fmt（格式化代码）"></a>2.3.2.3 fmt（格式化代码）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: fmt</span><br><span class="line">fmt: ## Run go fmt against code.</span><br><span class="line">        go fmt ./...</span><br></pre></td></tr></table></figure>
<p>作用：格式化代码<br>解释：使用go fmt命令格式化项目中的所有Go代码</p>
<h4 id="2-3-2-4-vet（检查代码中的潜在问题）"><a href="#2-3-2-4-vet（检查代码中的潜在问题）" class="headerlink" title="2.3.2.4 vet（检查代码中的潜在问题）"></a>2.3.2.4 vet（检查代码中的潜在问题）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: vet</span><br><span class="line">vet: ## Run go vet against code.</span><br><span class="line">        go vet ./...</span><br></pre></td></tr></table></figure>
<p>作用：检查代码中的潜在问题<br>解释：使用go vet命令检查项目中的所有Go代码，查找可能的问题。</p>
<h4 id="2-3-2-5-test（运行测试）"><a href="#2-3-2-5-test（运行测试）" class="headerlink" title="2.3.2.5 test（运行测试）"></a>2.3.2.5 test（运行测试）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: test</span><br><span class="line">test: manifests generate fmt vet envtest ## Run tests.</span><br><span class="line">        KUBEBUILDER_ASSETS=&quot;$(shell $(ENVTEST) use $(ENVTEST_K8S_VERSION) --bin-dir $(LOCALBIN) -p path)&quot; go test $$(go list ./... | grep -v /e2e) -coverprofile cover.out</span><br></pre></td></tr></table></figure>
<p>作用：运行测试<br>解释：</p>
<ul>
<li>先运行manifests、generate、fmt和vet目标</li>
<li>使用envtest工具设置环境变量KUBEBUILDER_ASSETS，然后运行项目中的所有测试(排除e2e测试)</li>
</ul>
<h4 id="2-3-2-6-test-e2e（运行端到端测试）"><a href="#2-3-2-6-test-e2e（运行端到端测试）" class="headerlink" title="2.3.2.6 test-e2e（运行端到端测试）"></a>2.3.2.6 test-e2e（运行端到端测试）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Utilize Kind or modify the e2e tests to load the image locally, enabling compatibility with other vendors.</span></span><br><span class="line">.PHONY: test-e2e  # Run the e2e tests against a Kind k8s instance that is spun up.</span><br><span class="line">test-e2e:</span><br><span class="line">        go test ./test/e2e/ -v -ginkgo.v</span><br></pre></td></tr></table></figure>
<p>作用：运行端到端测试<br>解释：使用go test命令运行test&#x2F;e2e目录中的端到端测试，并启动详细输出。</p>
<h4 id="2-3-2-7-lint（运行代码风格检查）"><a href="#2-3-2-7-lint（运行代码风格检查）" class="headerlink" title="2.3.2.7 lint（运行代码风格检查）"></a>2.3.2.7 lint（运行代码风格检查）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: lint</span><br><span class="line">lint: golangci-lint ## Run golangci-lint linter</span><br><span class="line">        $(GOLANGCI_LINT) run</span><br></pre></td></tr></table></figure>
<p>作用：运行代码风格检查<br>解释：使用golangci-lint工具运行代码风格检查</p>
<h4 id="2-3-2-8-lint-fix-（运行代码风格检查并自动修复问题）"><a href="#2-3-2-8-lint-fix-（运行代码风格检查并自动修复问题）" class="headerlink" title="2.3.2.8 lint-fix （运行代码风格检查并自动修复问题）"></a>2.3.2.8 lint-fix （运行代码风格检查并自动修复问题）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: lint-fix</span><br><span class="line">lint-fix: golangci-lint ## Run golangci-lint linter and perform fixes</span><br><span class="line">        $(GOLANGCI_LINT) run --fix</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>作用：运行代码风格检查并自动修复问题<br>解释：使用golangci-lint工具运行代码风格检查，并使用–fix选项自动修复发现的问题。</p>
<h3 id="2-3-3-构建目标"><a href="#2-3-3-构建目标" class="headerlink" title="2.3.3 构建目标"></a>2.3.3 构建目标</h3><h4 id="2-3-3-1-build（构建controller的二进制文件）"><a href="#2-3-3-1-build（构建controller的二进制文件）" class="headerlink" title="2.3.3.1 build（构建controller的二进制文件）"></a>2.3.3.1 build（构建controller的二进制文件）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: build</span><br><span class="line">build: manifests generate fmt vet ## Build manager binary.</span><br><span class="line">        go build -o bin/manager cmd/main.go</span><br></pre></td></tr></table></figure>
<p>作用：构建controller的二进制文件<br>解释：</p>
<ul>
<li>先运行manifests、generate、fmt和vet目标</li>
<li>使用go build命令编译cmd&#x2F;main.go文件，并将生成的二进制文件保存到bin&#x2F;manager。</li>
</ul>
<h4 id="2-3-3-2-run（在主机上运行controller）"><a href="#2-3-3-2-run（在主机上运行controller）" class="headerlink" title="2.3.3.2 run（在主机上运行controller）"></a>2.3.3.2 run（在主机上运行controller）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: run</span><br><span class="line">run: manifests generate fmt vet ## Run a controller from your host.</span><br><span class="line">        go run ./cmd/main.go</span><br></pre></td></tr></table></figure>
<p>作用：在主机上运行controller<br>解释：</p>
<ul>
<li>先运行manifests、generate、fmt和vet目标</li>
<li>使用go run命令运行cmd&#x2F;main.go文件</li>
</ul>
<h4 id="2-3-3-3-docker-build（构建Docker镜像）"><a href="#2-3-3-3-docker-build（构建Docker镜像）" class="headerlink" title="2.3.3.3 docker-build（构建Docker镜像）"></a>2.3.3.3 docker-build（构建Docker镜像）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If you wish to build the manager image targeting other platforms you can use the --platform flag.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(i.e. docker build --platform linux/arm64). However, you must <span class="built_in">enable</span> docker buildKit <span class="keyword">for</span> it.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">More info: https://docs.docker.com/develop/develop-images/build_enhancements/</span></span><br><span class="line">.PHONY: docker-build</span><br><span class="line">docker-build: ## Build docker image with the manager.</span><br><span class="line">        $(CONTAINER_TOOL) build -t $&#123;IMG&#125; .</span><br></pre></td></tr></table></figure>
<p>作用：构建Docker镜像<br>解释：使用CONTAINER_TOOL(默认为docker)构建docker镜像，并使用IMG变量指定镜像名称和标签</p>
<h4 id="2-3-3-4-docker-push（推送Docker镜像）"><a href="#2-3-3-4-docker-push（推送Docker镜像）" class="headerlink" title="2.3.3.4 docker-push（推送Docker镜像）"></a>2.3.3.4 docker-push（推送Docker镜像）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: docker-push</span><br><span class="line">docker-push: ## Push docker image with the manager.</span><br><span class="line">        $(CONTAINER_TOOL) push $&#123;IMG&#125;</span><br></pre></td></tr></table></figure>
<p>作用：推送Docker镜像<br>解释：使用CONTAINER_TOOL(默认为docker)推送构建好的Docker镜像到指定的仓库</p>
<h4 id="2-3-3-5-docker-buildx（构建并推送多平台支持的Docker镜像）"><a href="#2-3-3-5-docker-buildx（构建并推送多平台支持的Docker镜像）" class="headerlink" title="2.3.3.5 docker-buildx（构建并推送多平台支持的Docker镜像）"></a>2.3.3.5 docker-buildx（构建并推送多平台支持的Docker镜像）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PLATFORMS defines the target platforms <span class="keyword">for</span> the manager image be built to provide support to multiple</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">architectures. (i.e. make docker-buildx IMG=myregistry/mypoperator:0.0.1). To use this option you need to:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">- be able to use docker buildx. More info: https://docs.docker.com/build/buildx/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">- have enabled BuildKit. More info: https://docs.docker.com/develop/develop-images/build_enhancements/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">- be able to push the image to your registry (i.e. <span class="keyword">if</span> you <span class="keyword">do</span> not <span class="built_in">set</span> a valid value via IMG=&lt;myregistry/image:&lt;tag&gt;&gt; <span class="keyword">then</span> the <span class="built_in">export</span> will fail)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">To adequately provide solutions that are compatible with multiple platforms, you should consider using this option.</span></span><br><span class="line">PLATFORMS ?= linux/arm64,linux/amd64,linux/s390x,linux/ppc64le</span><br><span class="line">.PHONY: docker-buildx</span><br><span class="line">docker-buildx: ## Build and push docker image for the manager for cross-platform support</span><br><span class="line">        # copy existing Dockerfile and insert --platform=$&#123;BUILDPLATFORM&#125; into Dockerfile.cross, and preserve the original Dockerfile</span><br><span class="line">        sed -e &#x27;1 s/\(^FROM\)/FROM --platform=\$$\&#123;BUILDPLATFORM\&#125;/; t&#x27; -e &#x27; 1,// s//FROM --platform=\$$\&#123;BUILDPLATFORM\&#125;/&#x27; Dockerfile &gt; Dockerfile.cross</span><br><span class="line">        - $(CONTAINER_TOOL) buildx create --name myapp-operator-builder</span><br><span class="line">        $(CONTAINER_TOOL) buildx use myapp-operator-builder</span><br><span class="line">        - $(CONTAINER_TOOL) buildx build --push --platform=$(PLATFORMS) --tag $&#123;IMG&#125; -f Dockerfile.cross .</span><br><span class="line">        - $(CONTAINER_TOOL) buildx rm myapp-operator-builder</span><br><span class="line">        rm Dockerfile.cross</span><br></pre></td></tr></table></figure>

<p>作用：构建并推送多平台支持的Docker镜像<br>解释：</p>
<ul>
<li>使用sed命令复制现有的Dockerfile并插入–platform&#x3D;${BUILDPLATFORM}选项,生成Dockerfile.cross</li>
<li>创建一个名为myapp-builder的构建器</li>
<li>使用buildx构建并推送多平台镜像</li>
<li>删除构建器和临时生成的Dockerfile.cross</li>
</ul>
<h4 id="2-3-3-6-docker-installer（生成包含CRDs和部署的合并YAML文件）"><a href="#2-3-3-6-docker-installer（生成包含CRDs和部署的合并YAML文件）" class="headerlink" title="2.3.3.6 docker-installer（生成包含CRDs和部署的合并YAML文件）"></a>2.3.3.6 docker-installer（生成包含CRDs和部署的合并YAML文件）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: build-installer</span><br><span class="line">build-installer: manifests generate kustomize ## Generate a consolidated YAML with CRDs and deployment.</span><br><span class="line">        mkdir -p dist</span><br><span class="line">        cd config/manager &amp;&amp; $(KUSTOMIZE) edit set image controller=$&#123;IMG&#125;</span><br><span class="line">        $(KUSTOMIZE) build config/default &gt; dist/install.yaml</span><br></pre></td></tr></table></figure>
<p>作用：生成包含CRDs和部署的合并YAML文件<br>解释：</p>
<ul>
<li>创建dist目录</li>
<li>使用kustomize工具设置controller镜像为IMG</li>
<li>使用kustomize构建config&#x2F;default目录中的资源，并保存到dist&#x2F;install.yaml</li>
</ul>
<h3 id="2-3-4-部署目标"><a href="#2-3-4-部署目标" class="headerlink" title="2.3.4 部署目标"></a>2.3.4 部署目标</h3><h4 id="2-3-4-1-install（安装CRDs到Kubernetes集群）"><a href="#2-3-4-1-install（安装CRDs到Kubernetes集群）" class="headerlink" title="2.3.4.1 install（安装CRDs到Kubernetes集群）"></a>2.3.4.1 install（安装CRDs到Kubernetes集群）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: install</span><br><span class="line">install: manifests kustomize ## Install CRDs into the K8s cluster specified in ~/.kube/config.</span><br><span class="line">        $(KUSTOMIZE) build config/crd | $(KUBECTL) apply -f -</span><br></pre></td></tr></table></figure>
<p>作用：安装CRDs到Kubernetes集群<br>解释：</p>
<ul>
<li>先运行manifests和kustomize目标</li>
<li>使用kustomize 构建config&#x2F;crd目录中的资源，并使用kubectl将其应用到集群。</li>
</ul>
<h4 id="2-3-4-2-uninstall（从Kubernetes集群卸载CRDs）"><a href="#2-3-4-2-uninstall（从Kubernetes集群卸载CRDs）" class="headerlink" title="2.3.4.2 uninstall（从Kubernetes集群卸载CRDs）"></a>2.3.4.2 uninstall（从Kubernetes集群卸载CRDs）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: uninstall</span><br><span class="line">uninstall: manifests kustomize ## Uninstall CRDs from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found=true to ignore resource not found errors during deletion.</span><br><span class="line">        $(KUSTOMIZE) build config/crd | $(KUBECTL) delete --ignore-not-found=$(ignore-not-found) -f -</span><br></pre></td></tr></table></figure>

<p>作用：从Kubernetes集群卸载CRDs<br>解释：</p>
<ul>
<li>先运行manifests和kustomize目标</li>
<li>使用kustomize 构建config&#x2F;crd目录中的资源，并使用kubectl将其从集群中删除，可以通过ignore-not-found&#x3D;true忽略资源未找到的错误</li>
</ul>
<h4 id="2-3-4-3-deploy（部署controller到Kubernetes集群）"><a href="#2-3-4-3-deploy（部署controller到Kubernetes集群）" class="headerlink" title="2.3.4.3 deploy（部署controller到Kubernetes集群）"></a>2.3.4.3 deploy（部署controller到Kubernetes集群）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: deploy</span><br><span class="line">deploy: manifests kustomize ## Deploy controller to the K8s cluster specified in ~/.kube/config.</span><br><span class="line">        cd config/manager &amp;&amp; $(KUSTOMIZE) edit set image controller=$&#123;IMG&#125;</span><br><span class="line">        $(KUSTOMIZE) build config/default | $(KUBECTL) apply -f -</span><br></pre></td></tr></table></figure>
<p>作用：部署controller到Kubernetes集群<br>解释：</p>
<ul>
<li>先运行manifests和kustomize目标</li>
<li>使用kustomize设置controller镜像为IMG</li>
<li>使用kustomize构建config&#x2F;default目录中的资源，并使用kubectl将其应用到集群</li>
</ul>
<h4 id="2-3-4-4-undeploy（从Kubernetes集群中卸载Controller）"><a href="#2-3-4-4-undeploy（从Kubernetes集群中卸载Controller）" class="headerlink" title="2.3.4.4 undeploy（从Kubernetes集群中卸载Controller）"></a>2.3.4.4 undeploy（从Kubernetes集群中卸载Controller）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: undeploy</span><br><span class="line">undeploy: kustomize ## Undeploy controller from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found=true to ignore resource not found errors during deletion.</span><br><span class="line">        $(KUSTOMIZE) build config/default | $(KUBECTL) delete --ignore-not-found=$(ignore-not-found) -f -</span><br></pre></td></tr></table></figure>
<p>作用：从Kubernetes集群中卸载Controller<br>解释：使用kustomize 构建config&#x2F;default目录中的资源，并使用kubectl将其从集群中删除。可以通过ignore-not-found&#x3D;true忽略资源未找到的错误</p>
<h3 id="2-3-5-依赖目标"><a href="#2-3-5-依赖目标" class="headerlink" title="2.3.5 依赖目标"></a>2.3.5 依赖目标</h3><h4 id="2-3-5-1-ignore-not-found（定义ignore-not-found变量，默认值为false）"><a href="#2-3-5-1-ignore-not-found（定义ignore-not-found变量，默认值为false）" class="headerlink" title="2.3.5.1 ignore-not-found（定义ignore-not-found变量，默认值为false）"></a>2.3.5.1 ignore-not-found（定义ignore-not-found变量，默认值为false）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifndef ignore-not-found</span><br><span class="line">  ignore-not-found = false</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>作用：定义ignore-not-found变量，默认值为false<br>解释：如果命令行中未指定ignore-not-found，则默认值为false</p>
<h4 id="2-3-5-2-LOCALBIN（定义本地二进制文件的安装目录）"><a href="#2-3-5-2-LOCALBIN（定义本地二进制文件的安装目录）" class="headerlink" title="2.3.5.2 LOCALBIN（定义本地二进制文件的安装目录）"></a>2.3.5.2 LOCALBIN（定义本地二进制文件的安装目录）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Location to install dependencies to</span></span></span><br><span class="line">LOCALBIN ?= $(shell pwd)/bin</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(LOCALBIN):</span></span><br><span class="line">        mkdir -p $(LOCALBIN)</span><br></pre></td></tr></table></figure>
<p>作用：定义本地二进制文件的安装目录，默认为当前目录下的bin目录<br>解释：如果LOCALBIN未设置，则默认为$(shell pwd)&#x2F;bin。如果LOCALBIN目录不存在，则创建它。</p>
<h4 id="2-3-5-3-工具二进制文件（定义各种工具的路径和默认值）"><a href="#2-3-5-3-工具二进制文件（定义各种工具的路径和默认值）" class="headerlink" title="2.3.5.3 工具二进制文件（定义各种工具的路径和默认值）"></a>2.3.5.3 工具二进制文件（定义各种工具的路径和默认值）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Tool Binaries</span></span></span><br><span class="line">KUBECTL ?= kubectl</span><br><span class="line">KUSTOMIZE ?= $(LOCALBIN)/kustomize</span><br><span class="line">CONTROLLER_GEN ?= $(LOCALBIN)/controller-gen</span><br><span class="line">ENVTEST ?= $(LOCALBIN)/setup-envtest</span><br><span class="line">GOLANGCI_LINT = $(LOCALBIN)/golangci-lint</span><br></pre></td></tr></table></figure>
<p>作用：定义各种工具的路径和默认值<br>解释：</p>
<ul>
<li>KUBECTL：默认为kubectl</li>
<li>KUSTOMIZE：默认为$(LOCALBIN)&#x2F;kustomize</li>
<li>CONTROLLER_GEN：默认为$(LOCALBIN)&#x2F;controller-gen</li>
<li>ENVTEST：默认为$(LOCALBIN)&#x2F;setup-envtest</li>
<li>GOLANGCI_LINT： 默认为$(LOCALBIN)&#x2F;golangci-lint</li>
</ul>
<h4 id="2-3-5-4-工具版本（定义各个工具的版本）"><a href="#2-3-5-4-工具版本（定义各个工具的版本）" class="headerlink" title="2.3.5.4 工具版本（定义各个工具的版本）"></a>2.3.5.4 工具版本（定义各个工具的版本）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Tool Versions</span></span></span><br><span class="line">KUSTOMIZE_VERSION ?= v5.4.3</span><br><span class="line">CONTROLLER_TOOLS_VERSION ?= v0.16.1</span><br><span class="line">ENVTEST_VERSION ?= release-0.19</span><br><span class="line">GOLANGCI_LINT_VERSION ?= v1.59.1</span><br></pre></td></tr></table></figure>
<p>作用：定义各个工具的版本<br>解释：</p>
<ul>
<li>KUSTOMIZE_VERSION：默认为v5.4.3</li>
<li>CONTROLLER_TOOLS_VERSION：默认为v0.16.1</li>
<li>ENVTEST_VERSION：默认为release-0.19</li>
<li>GOLANGCI_LINT_VERSION：默认为v1.59.1</li>
</ul>
<h4 id="2-3-5-5-kustomize（下载kustomize工具）"><a href="#2-3-5-5-kustomize（下载kustomize工具）" class="headerlink" title="2.3.5.5 kustomize（下载kustomize工具）"></a>2.3.5.5 kustomize（下载kustomize工具）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: kustomize</span><br><span class="line">kustomize: $(KUSTOMIZE) ## Download kustomize locally if necessary.</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(KUSTOMIZE): $(LOCALBIN)</span></span><br><span class="line">        $(call go-install-tool,$(KUSTOMIZE),sigs.k8s.io/kustomize/kustomize/v5,$(KUSTOMIZE_VERSION))</span><br></pre></td></tr></table></figure>
<p>作用：下载kustomize工具(如有必要)<br>解释：如果kustomize文件不存在，则调用 go-install-tool函数下载kustomize工具</p>
<h4 id="2-3-5-6-controller-gen（下载controller-gen工具）"><a href="#2-3-5-6-controller-gen（下载controller-gen工具）" class="headerlink" title="2.3.5.6 controller-gen（下载controller-gen工具）"></a>2.3.5.6 controller-gen（下载controller-gen工具）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: controller-gen</span><br><span class="line">controller-gen: $(CONTROLLER_GEN) ## Download controller-gen locally if necessary.</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(CONTROLLER_GEN): $(LOCALBIN)</span></span><br><span class="line">        $(call go-install-tool,$(CONTROLLER_GEN),sigs.k8s.io/controller-tools/cmd/controller-gen,$(CONTROLLER_TOOLS_VERSION))</span><br></pre></td></tr></table></figure>
<p>作用：下载controller-gen工具(如有必要)<br>解释：如果$(CONTROLLER_GEN)文件不存在，则调用 go-install-tool函数下载controller-gen工具</p>
<h4 id="2-3-5-7-envtest（下载setup-envtest工具）"><a href="#2-3-5-7-envtest（下载setup-envtest工具）" class="headerlink" title="2.3.5.7 envtest（下载setup-envtest工具）"></a>2.3.5.7 envtest（下载setup-envtest工具）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: envtest</span><br><span class="line">envtest: $(ENVTEST) ## Download setup-envtest locally if necessary.</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(ENVTEST): $(LOCALBIN)</span></span><br><span class="line">        $(call go-install-tool,$(ENVTEST),sigs.k8s.io/controller-runtime/tools/setup-envtest,$(ENVTEST_VERSION))</span><br></pre></td></tr></table></figure>
<p>作用：下载setup-envtest工具(如有必要)<br>解释：如果$(ENVTEST)文件不存在，则调用go-install-tool函数下载setup-envtes工具</p>
<h4 id="2-3-5-8-golangci-lint（下载golangci-lint工具）"><a href="#2-3-5-8-golangci-lint（下载golangci-lint工具）" class="headerlink" title="2.3.5.8 golangci-lint（下载golangci-lint工具）"></a>2.3.5.8 golangci-lint（下载golangci-lint工具）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: golangci-lint</span><br><span class="line">golangci-lint: $(GOLANGCI_LINT) ## Download golangci-lint locally if necessary.</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(GOLANGCI_LINT): $(LOCALBIN)</span></span><br><span class="line">        $(call go-install-tool,$(GOLANGCI_LINT),github.com/golangci/golangci-lint/cmd/golangci-lint,$(GOLANGCI_LINT_VERSION))</span><br></pre></td></tr></table></figure>
<p>作用：下载golangci-lint工具(如有必要)<br>解释：如果$(GOLANGCI_LINT)文件不存在，则调用go-install-tool函数下载golangci-lint工具。</p>
<h2 id="2-4-自定义函数"><a href="#2-4-自定义函数" class="headerlink" title="2.4 自定义函数"></a>2.4 自定义函数</h2><h3 id="2-4-1-go-install-tool（下载并安装指定的Go包）"><a href="#2-4-1-go-install-tool（下载并安装指定的Go包）" class="headerlink" title="2.4.1 go-install-tool（下载并安装指定的Go包）"></a>2.4.1 go-install-tool（下载并安装指定的Go包）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go-install-tool will <span class="string">&#x27;go install&#x27;</span> any package with custom target and name of binary, <span class="keyword">if</span> it doesn<span class="string">&#x27;t exist</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">$1 - target path with name of binary</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">$2 - package url which can be installed</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">$3 - specific version of package</span></span></span><br><span class="line">define go-install-tool</span><br><span class="line">@[ -f &quot;$(1)-$(3)&quot; ] || &#123; \</span><br><span class="line">set -e; \</span><br><span class="line">package=$(2)@$(3) ;\</span><br><span class="line">echo &quot;Downloading $$&#123;package&#125;&quot; ;\</span><br><span class="line">rm -f $(1) || true ;\</span><br><span class="line">GOBIN=$(LOCALBIN) go install $$&#123;package&#125; ;\</span><br><span class="line">mv $(1) $(1)-$(3) ;\</span><br><span class="line">&#125; ;\</span><br><span class="line">ln -sf $(1)-$(3) $(1)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>作用：下载并安装指定的Go包<br>解释：</p>
<ul>
<li>$1：目标路径和二进制文件名</li>
<li>$2：包的URL</li>
<li>$3:包的具体版本</li>
<li>如果目标文件$(1)~$(3)不存在，则执行以下步骤</li>
<li>设置set -e，确保任何命令执行失败立即退出</li>
<li>设置package变量为包的URL和版本</li>
<li>输出下载信息</li>
<li>删除旧的二进制文件(如果存在)</li>
<li>使用go install命令安装包，并将二进制文件保存在LOCALBIN目录</li>
<li>将生成的二进制文件重命令为$(1)-$(3)</li>
<li>最后创建一个符号链接，指向$(1)-$(3)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Kustomize与Helm对比</title>
    <url>/2025/07/kubernetes/Operator%E5%BC%80%E5%8F%91/Kustomize%E4%B8%8EHelm%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><p>K8s 是一个开源容器编排平台，可自动执行容器化应用程序的部署、扩展和管理。近年来，K8s 已成为采用云原生架构和容器化技术的组织的标准。</p>
<p>但是由于K8s的复杂性，所以很多公司以及开源组织都在开发相关的工具来简化k8s的使用门槛，这其中就包括两个很优秀的开源工具，Kustomize<br>（K8s 的配置管理器）和Helm （K8s 的包管理器）。</p>
<p>本文将针对二者来进行对比。</p>
<table>
<thead>
<tr>
<th></th>
<th>Kustomize</th>
<th>Helm</th>
</tr>
</thead>
<tbody><tr>
<td>操作方法</td>
<td>overlays</td>
<td>templating</td>
</tr>
<tr>
<td>使用成本</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td>是否支持封装</td>
<td>简单</td>
<td>是</td>
</tr>
<tr>
<td>kubectl集成</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>kubectl集成</td>
<td>声明式</td>
<td>命令式</td>
</tr>
</tbody></table>
<h1 id="1、Kustomize"><a href="#1、Kustomize" class="headerlink" title="1、Kustomize"></a>1、Kustomize</h1><p>Kustomize 是 k8s集群的配置定制工具。它允许管理员使用非模板文件进行声明性更改，而不影响原始清单文件。</p>
<p>来看一下kubebuilder生成项目的Kustomize配置，以&#x2F;config&#x2F;crd目录为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── crd</span><br><span class="line">│   ├── bases</span><br><span class="line">│   │   └── apps.kubenode.alibaba-inc.com_myapps.yaml</span><br><span class="line">│   ├── kustomization.yaml</span><br><span class="line">│   ├── kustomizeconfig.yaml</span><br><span class="line">│   └── patches</span><br><span class="line">│       ├── cainjection_in_myapps.yaml</span><br><span class="line">│       └── webhook_in_myapps.yaml</span><br></pre></td></tr></table></figure>

<p>其中config&#x2F;crd目录是执行<code>kubebuilder create api</code>后生成的，最原始的目录结构是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── crd</span><br><span class="line">│   ├── kustomization.yaml</span><br><span class="line">│   └── kustomizeconfig.yaml</span><br></pre></td></tr></table></figure>

<p>所以bases子目录和patches子目录都是执行<code>make manifests</code>后生成的。</p>
<p>执行<code>kubebuilder create api</code>可以参考：<a href="https://blog.csdn.net/qq_41004932/article/details/142702284">https://blog.csdn.net/qq_41004932/article/details/142702284</a></p>
<p>执行<code>make manifests</code>可以参考：<a href="https://blog.csdn.net/qq_41004932/article/details/142703870">https://blog.csdn.net/qq_41004932/article/details/142703870</a></p>
<p>在 Kubebuilder 生成的项目中，config&#x2F;crd 目录下的文件主要用于管理和配置自定义资源定义（Custom Resource Definitions, CRDs）。这些文件通过 Kustomize 工具进行管理，以便于在不同的环境中部署和管理 CRDs。下面是每个文件的作用解释：</p>
<ol>
<li>bases 目录<br>bases&#x2F;apps.kubenode.alibaba-inc.com_myapps.yaml:<br>这个文件包含了自定义资源定义（CRD）的 YAML 描述。它定义了你的自定义资源（Custom Resource, CR）的结构和元数据。<br>例如，如果我们创建了一个名为 MyApp 的自定义资源，这个文件将描述 MyApp 的 API 版本、资源名称、字段等。</li>
<li>kustomization.yaml:<br>这个文件是 Kustomize 的配置文件，用于定义如何组合和修改 Kubernetes 资源文件。<br>它指定了哪些资源文件（如 CRD 文件）需要被应用，并且可以包含补丁文件和其他配置选项。<br>例如，它可以指定 bases 目录中的 CRD 文件，以及 patches 目录中的补丁文件。</li>
<li>kustomizeconfig.yaml:<br>这个文件通常用于配置 Kustomize 的一些高级选项，但在这个上下文中可能不是必需的。它可能会包含一些特定的配置项，用于定制 Kustomize 的行为。<br>在大多数情况下，这个文件可能不需要手动编辑。</li>
<li>patches&#x2F;cainjection_in_myapps.yaml:<br>这个文件是一个补丁文件，用于在 CRD 上应用 Webhook 注入（例如，证书注入）。<br>例如，如果你的 CRD 需要与 mutating 或 validating webhooks 一起工作，这个补丁文件会确保 Webhook 配置正确地注入到 CRD 中。</li>
<li>patches&#x2F;webhook_in_myapps.yaml:<br>这个文件也是一个补丁文件，用于在 CRD 上应用 Webhook 配置。<br>例如，它可能会添加或修改 Webhook 的配置，以便在创建或更新自定义资源时触发特定的行为。</li>
</ol>
<p>总结</p>
<p>bases 目录：包含 CRD 的基本定义文件。</p>
<p>kustomization.yaml：Kustomize 的配置文件，用于定义如何组合和修改资源文件。</p>
<p>kustomizeconfig.yaml：Kustomize 的高级配置文件（可选）。</p>
<p>patches 目录：包含用于修改 CRD 的补丁文件，通常用于注入 Webhook 配置。</p>
<p>如果我们像让这个crd根据不同的环境做针对性部署的，例如下面的目录结构:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── crd</span><br><span class="line">│   ├── bases</span><br><span class="line">│   │   └── apps.kubenode.alibaba-inc.com_myapps.yaml</span><br><span class="line">│   ├── development</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── patches</span><br><span class="line">│   │       └── webhook_in_myapps.yaml</span><br><span class="line">│   ├── testing</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── patches</span><br><span class="line">│   │       └── webhook_in_myapps.yaml</span><br><span class="line">│   ├── production</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── patches</span><br><span class="line">│   │       └── webhook_in_myapps.yaml</span><br><span class="line">│   ├── kustomization.yaml</span><br><span class="line">│   ├── kustomizeconfig.yaml</span><br><span class="line">│   └── patches</span><br><span class="line">│       ├── cainjection_in_myapps.yaml</span><br><span class="line">│       └── webhook_in_myapps.yaml</span><br></pre></td></tr></table></figure>

<p>所有自定义规范都包含在 kustomization.yaml 文件中，该文件将规范叠加在现有清单之上以生成资源的自定义版本。</p>
<p>所以我们可以根据这一特性，针对不同的环境，对crd进行定制。</p>
<h1 id="2、Helm"><a href="#2、Helm" class="headerlink" title="2、Helm"></a>2、Helm</h1><p>Helm 是一个能够在 K8s 上打包、部署和管理应用程序的工具，即使是最复杂的 K8s 应用程序它都可以帮助定义，安装和升级，同时Helm 也是 <a href="https://cncf.io/">CNCF</a> 的毕业项目。<br>这里涉及到了以及关于helm的重要概念：</p>
<ul>
<li>Helm Charts：预先配置yaml的模板，在这里叫Chart，用于描述 K8s 应用程序的yaml和配置</li>
<li>Helm Client：用于与 Helm 交互并管理这些Chart版本的命令行界面</li>
<li>Chart 仓库：管理Chart的仓库，跟Maven的Nexus一个意思，比如在公司环境构建上传，在客户的机房连接到这Chart 仓库下载Chart，并部署到k8s中。</li>
</ul>
<h1 id="2-1-helm示例"><a href="#2-1-helm示例" class="headerlink" title="2.1 helm示例"></a>2.1 helm示例</h1><p>helm的示例需要用到kubectl、helm以及k8s集群，相应的安装参考：</p>
<ul>
<li>mac环境：<a href="https://blog.csdn.net/qq_41004932/article/details/142684319">https://blog.csdn.net/qq_41004932/article/details/142684319</a></li>
<li>ubuntu环境：<a href="https://blog.csdn.net/qq_41004932/article/details/142691490">https://blog.csdn.net/qq_41004932/article/details/142691490</a></li>
<li>kind集群：<a href="https://blog.csdn.net/qq_41004932/article/details/142691490">https://blog.csdn.net/qq_41004932/article/details/142691490</a></li>
</ul>
<p>Helm Charts 是预先配置的 K8s 资源包。Helm Chart 包含部署特定应用程序或服务所需的所有信息，包括 K8s 清单、环境变量和其他配置</p>
<p>目录名称是Chart的名称，如<a href="https://helm.sh/docs/topics/charts/">Helm 文档</a>所示，我们通过helm create demo命令创建一个Chart，执行完以后，默认会生成一个 nginx 的Chart。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm create demo</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm create demo                                                                                                                      [10:33:35]</span></span><br><span class="line">Creating demo</span><br></pre></td></tr></table></figure>

<p>查看目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── charts</span><br><span class="line">├── templates</span><br><span class="line">│   ├── NOTES.txt</span><br><span class="line">│   ├── _helpers.tpl</span><br><span class="line">│   ├── deployment.yaml</span><br><span class="line">│   ├── hpa.yaml</span><br><span class="line">│   ├── ingress.yaml</span><br><span class="line">│   ├── service.yaml</span><br><span class="line">│   ├── serviceaccount.yaml</span><br><span class="line">│   └── tests</span><br><span class="line">│       └── test-connection.yaml</span><br><span class="line">└── values.yaml</span><br><span class="line"></span><br><span class="line">3 directories, 10 files</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Chart-yaml"><a href="#2-2-Chart-yaml" class="headerlink" title="2.2 Chart.yaml"></a>2.2 Chart.yaml</h2><p>定义了当前 chart版本，以及描述当前chart用途，其中 name 参数表示 chart 名称，后期上传下载都会用此名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v2</span><br><span class="line">name: demo</span><br><span class="line">description: A Helm chart for Kubernetes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A chart can be either an <span class="string">&#x27;application&#x27;</span> or a <span class="string">&#x27;library&#x27;</span> chart.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Application charts are a collection of templates that can be packaged into versioned archives</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to be deployed.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Library charts provide useful utilities or functions for the chart developer. They&#x27;re included as</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a dependency of application charts to inject those utilities and <span class="built_in">functions</span> into the rendering</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pipeline. Library charts <span class="keyword">do</span> not define any templates and therefore cannot be deployed.</span></span><br><span class="line">type: application</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is the chart version. This version number should be incremented each <span class="keyword">time</span> you make changes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to the chart and its templates, including the app version.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Versions are expected to follow Semantic Versioning (https://semver.org/)</span></span><br><span class="line">version: 0.1.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is the version number of the application being deployed. This version number should be</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">incremented each <span class="keyword">time</span> you make changes to the application. Versions are not expected to</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">follow Semantic Versioning. They should reflect the version the application is using.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">It is recommended to use it with quotes.</span></span><br><span class="line">appVersion: &quot;1.16.0&quot;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-values-yaml"><a href="#2-3-values-yaml" class="headerlink" title="2.3 values.yaml"></a>2.3 values.yaml</h2><p>可变参数，都是在此文件中定义，在yaml模板中引用，比如：image.repository，而引用则通过.Values+变量的名进行引用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default values <span class="keyword">for</span> demo.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is a YAML-formatted file.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Declare variables to be passed into your templates.</span></span><br><span class="line"></span><br><span class="line">replicaCount: 1</span><br><span class="line"></span><br><span class="line">image:</span><br><span class="line">  repository: nginx</span><br><span class="line">  pullPolicy: IfNotPresent</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Overrides the image tag whose default is the chart appVersion.</span></span><br><span class="line">  tag: &quot;&quot;</span><br><span class="line"></span><br><span class="line">imagePullSecrets: []</span><br><span class="line">nameOverride: &quot;&quot;</span><br><span class="line">fullnameOverride: &quot;&quot;</span><br><span class="line"></span><br><span class="line">serviceAccount:</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Specifies whether a service account should be created</span></span><br><span class="line">  create: true</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Annotations to add to the service account</span></span><br><span class="line">  annotations: &#123;&#125;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">The name of the service account to use.</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">If not <span class="built_in">set</span> and create is <span class="literal">true</span>, a name is generated using the fullname template</span></span><br><span class="line">  name: &quot;&quot;</span><br><span class="line"></span><br><span class="line">podAnnotations: &#123;&#125;</span><br><span class="line"></span><br><span class="line">podSecurityContext: &#123;&#125;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">fsGroup: 2000</span></span><br><span class="line"></span><br><span class="line">securityContext: &#123;&#125;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">capabilities:</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">  drop:</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">  - ALL</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">readOnlyRootFilesystem: <span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">runAsNonRoot: <span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">runAsUser: 1000</span></span><br><span class="line"></span><br><span class="line">service:</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">ingress:</span><br><span class="line">  enabled: false</span><br><span class="line">  className: &quot;&quot;</span><br><span class="line">  annotations: &#123;&#125;</span><br><span class="line">    # kubernetes.io/ingress.class: nginx</span><br><span class="line">    # kubernetes.io/tls-acme: &quot;true&quot;</span><br><span class="line">  hosts:</span><br><span class="line">    - host: chart-example.local</span><br><span class="line">      paths:</span><br><span class="line">        - path: /</span><br><span class="line">          pathType: ImplementationSpecific</span><br><span class="line">  tls: []</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"> - secretName: chart-example-tls</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">   hosts:</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">     - chart-example.local</span></span><br><span class="line"></span><br><span class="line">resources: &#123;&#125;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">We usually recommend not to specify default resources and to leave this as a conscious</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">choice <span class="keyword">for</span> the user. This also increases chances charts run on environments with little</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">resources, such as Minikube. If you <span class="keyword">do</span> want to specify resources, uncomment the following</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">lines, adjust them as necessary, and remove the curly braces after <span class="string">&#x27;resources:&#x27;</span>.</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">limits:</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">  cpu: 100m</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">  memory: 128Mi</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">requests:</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">  cpu: 100m</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">  memory: 128Mi</span></span><br><span class="line"></span><br><span class="line">autoscaling:</span><br><span class="line">  enabled: false</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  maxReplicas: 100</span><br><span class="line">  targetCPUUtilizationPercentage: 80</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">targetMemoryUtilizationPercentage: 80</span></span><br><span class="line"></span><br><span class="line">nodeSelector: &#123;&#125;</span><br><span class="line"></span><br><span class="line">tolerations: []</span><br><span class="line"></span><br><span class="line">affinity: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-helpers-tpl"><a href="#2-4-helpers-tpl" class="headerlink" title="2.4 _helpers.tpl"></a>2.4 _helpers.tpl</h2><p>定义通用代码块，然后yaml 文件会通过 include 引用</p>
<p>定义:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- define &quot;demo.name&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix &quot;-&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>引用:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;&#123; include &quot;demo.fullname&quot; . &#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-templates"><a href="#2-5-templates" class="headerlink" title="2.5 templates"></a>2.5 templates</h2><p>此目录主要存放的是要部署的 yaml文件模板，同时也包含_helpers.tpl文件，模板会引用values.yaml、Chart.yaml定义的参数，以及_helpers.tpl定义的通用代码块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; include &quot;demo.fullname&quot; . &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    &#123;&#123;- include &quot;demo.labels&quot; . | nindent 4 &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  &#123;&#123;- if not .Values.autoscaling.enabled &#125;&#125;</span><br><span class="line">  replicas: &#123;&#123; .Values.replicaCount &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      &#123;&#123;- include &quot;demo.selectorLabels&quot; . | nindent 6 &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      &#123;&#123;- with .Values.podAnnotations &#125;&#125;</span><br><span class="line">      annotations:</span><br><span class="line">        &#123;&#123;- toYaml . | nindent 8 &#125;&#125;</span><br><span class="line">      &#123;&#123;- end &#125;&#125;</span><br><span class="line">      labels:</span><br><span class="line">        &#123;&#123;- include &quot;demo.selectorLabels&quot; . | nindent 8 &#125;&#125;</span><br><span class="line">    spec:</span><br><span class="line">      &#123;&#123;- with .Values.imagePullSecrets &#125;&#125;</span><br><span class="line">      imagePullSecrets:</span><br><span class="line">        &#123;&#123;- toYaml . | nindent 8 &#125;&#125;</span><br><span class="line">      &#123;&#123;- end &#125;&#125;</span><br><span class="line">      serviceAccountName: &#123;&#123; include &quot;demo.serviceAccountName&quot; . &#125;&#125;</span><br><span class="line">      securityContext:</span><br><span class="line">        &#123;&#123;- toYaml .Values.podSecurityContext | nindent 8 &#125;&#125;</span><br><span class="line">      containers:</span><br><span class="line">        - name: &#123;&#123; .Chart.Name &#125;&#125;</span><br><span class="line">          securityContext:</span><br><span class="line">            &#123;&#123;- toYaml .Values.securityContext | nindent 12 &#125;&#125;</span><br><span class="line">          image: &quot;&#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag | default .Chart.AppVersion &#125;&#125;&quot;</span><br><span class="line">          imagePullPolicy: &#123;&#123; .Values.image.pullPolicy &#125;&#125;</span><br><span class="line">          ports:</span><br><span class="line">            - name: http</span><br><span class="line">              containerPort: &#123;&#123; .Values.service.port &#125;&#125;</span><br><span class="line">              protocol: TCP</span><br><span class="line">          livenessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /</span><br><span class="line">              port: http</span><br><span class="line">          readinessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /</span><br><span class="line">              port: http</span><br><span class="line">          resources:</span><br><span class="line">            &#123;&#123;- toYaml .Values.resources | nindent 12 &#125;&#125;</span><br><span class="line">      &#123;&#123;- with .Values.nodeSelector &#125;&#125;</span><br><span class="line">      nodeSelector:</span><br><span class="line">        &#123;&#123;- toYaml . | nindent 8 &#125;&#125;</span><br><span class="line">      &#123;&#123;- end &#125;&#125;</span><br><span class="line">      &#123;&#123;- with .Values.affinity &#125;&#125;</span><br><span class="line">      affinity:</span><br><span class="line">        &#123;&#123;- toYaml . | nindent 8 &#125;&#125;</span><br><span class="line">      &#123;&#123;- end &#125;&#125;</span><br><span class="line">      &#123;&#123;- with .Values.tolerations &#125;&#125;</span><br><span class="line">      tolerations:</span><br><span class="line">        &#123;&#123;- toYaml . | nindent 8 &#125;&#125;</span><br><span class="line">      &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">image: &quot;&#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag | default .Chart.AppVersion &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-部署"><a href="#2-5-部署" class="headerlink" title="2.5 部署"></a>2.5 部署</h2><p>如果想部署的话，可以使用下面命令进行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm package helm-demo</span><br></pre></td></tr></table></figure>

<p>可以发现，这里helm是将要部署的资源当作一个整体来进行操作的，也就是讲一个资源的所有yaml配置作为一个整体的形式来进行操作。</p>
<h1 id="3、主要差异"><a href="#3、主要差异" class="headerlink" title="3、主要差异"></a>3、主要差异</h1><h2 id="3-1-操作方法"><a href="#3-1-操作方法" class="headerlink" title="3.1 操作方法"></a>3.1 操作方法</h2><p>Kustomize 依赖特定于目录的kustomization.yaml文件来构建各个资源并对其进行更改。这些文件将补丁和覆盖应用到共享基文件夹中声明的资源，以提供自动化的多环境配置。</p>
<p>Helm 通过引用value.yaml文件作为变量源，使用模板生成有效的 K8s 配置。模板目录托管 Helm Chart在部署期间用于创建资源的文件。</p>
<h2 id="3-2-便捷性"><a href="#3-2-便捷性" class="headerlink" title="3.2 便捷性"></a>3.2 便捷性</h2><p>从K8s 版本 1.14 开始，Kustomize 与 kubectl CLI 捆绑在一起，因此不需要掌握任何其他工具。Kustomize 支持声明式部署，并对每个文件使用纯 YAML，从而更容易使用。</p>
<p>Helm 为K8s包管理任务添加了额外的抽象层，从而加快了希望简化集群配置和发布自动化的团队的学习曲线。Helm Chart 相对Kustomize复杂，不过功能更加强大。</p>
<h2 id="3-3-打包"><a href="#3-3-打包" class="headerlink" title="3.3 打包"></a>3.3 打包</h2><p>Kustomize 缺乏的打包功能，并且每个资源都必须在基本文件夹中声明，并在覆盖kustomization.yaml文件中单独声明变体。</p>
<p>而Helm将所有必需的K8s资源都打包到一个文件夹中，该文件夹可以根据需要重复使用。Helm 还允许设置应用程序默认值，并且使用values.yaml文件修改参数，从而注入引用的 yaml 文件中。</p>
<h2 id="3-4-原生-kubectl-集成"><a href="#3-4-原生-kubectl-集成" class="headerlink" title="3.4 原生 kubectl 集成"></a>3.4 原生 kubectl 集成</h2><p>从 K8s 1.14 版开始，Kustomize 就预装了 kubectl，Helm 并未与 K8s 预先集成，因此必须手动安装 Helm。</p>
<h2 id="3-5-Kustomize-与-Helm-何时使用"><a href="#3-5-Kustomize-与-Helm-何时使用" class="headerlink" title="3.5 Kustomize 与 Helm - 何时使用"></a>3.5 Kustomize 与 Helm - 何时使用</h2><h3 id="3-5-1-何时使用-Kustomize"><a href="#3-5-1-何时使用-Kustomize" class="headerlink" title="3.5.1 何时使用 Kustomize"></a>3.5.1 何时使用 Kustomize</h3><p>Kustomize允许在不改变原始文件的情况下进行精确更改。 因此可以有以下场景</p>
<ul>
<li>应用配置的变体管理：当你需要管理多个环境（例如开发、测试、生产）中应用的变体时，Kustomize 是一个很好的选择。它允许你为不同的环境创建不同的配置，并使用一套基础配置来定义通用部分。</li>
<li>持续集成和持续部署（CI&#x2F;CD）流水线：Kustomize 可以与 CI&#x2F;CD 工具集成，帮助你实现自动化部署。通过在流水线中使用 Kustomize，你可以根据需要生成特定环境的配置，并将其应用到集群中。</li>
</ul>
<h3 id="3-5-2-何时使用-Helm"><a href="#3-5-2-何时使用-Helm" class="headerlink" title="3.5.2 何时使用 Helm"></a>3.5.2 何时使用 Helm</h3><p>Helm 将所有 K8s 对象封装到一个包中，减少了与各个yaml 文件的交互。除此之外，大多数第三方供应商还提供预构建的 Helm 图表，以简化将其产品部署到 K8s 中的过程。因此，Helm 通常是安装现成解决方案（例如监控、数据库和消息中间件等）的首选</p>
]]></content>
  </entry>
  <entry>
    <title>operator开发脚手架</title>
    <url>/2025/07/kubernetes/Operator%E5%BC%80%E5%8F%91/operator%E5%BC%80%E5%8F%91%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="1、脚手架工具"><a href="#1、脚手架工具" class="headerlink" title="1、脚手架工具"></a>1、脚手架工具</h1><p>Operator的实现方式主要包括OperatorSDK和KubeBuilder，目前KubeBuilder在阿里使用的比较多。</p>
<p><a href="https://github.com/kubernetes-sigs/kubebuilder?spm=ata.21736010.0.0.5e4b6ec8eEasr9">KubeBuilder</a></p>
<p><a href="https://github.com/operator-framework/operator-sdk?spm=ata.21736010.0.0.5e4b6ec8eEasr9">OperatorSDK</a></p>
<p>我们这里主要是用KubeBuilder来进行，其中OperatorSDK其实也是应用了KubeBuilder。</p>
<h1 id="2、创建Operator工程"><a href="#2、创建Operator工程" class="headerlink" title="2、创建Operator工程"></a>2、创建Operator工程</h1><p>创建脚手架工程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir myapp-operator</span><br><span class="line">cd myapp-operator/</span><br><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">kubebuilder init --domain kubenode.kingtest.com</span><br></pre></td></tr></table></figure>

<p>创建脚手架结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubebuilder init --domain kubenode.kingtest.com</span><br><span class="line">INFO Writing kustomize manifests for you to edit... </span><br><span class="line">INFO Writing scaffold for you to edit...          </span><br><span class="line">INFO Get controller runtime:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go get sigs.k8s.io/controller-runtime@v0.19.0</span> </span><br><span class="line">go: downloading sigs.k8s.io/controller-runtime v0.19.0</span><br><span class="line">go: downloading k8s.io/apimachinery v0.31.0</span><br><span class="line">go: downloading k8s.io/api v0.31.0</span><br><span class="line">go: downloading k8s.io/client-go v0.31.0</span><br><span class="line">go: downloading k8s.io/utils v0.0.0-20240711033017-18e509b52bc8</span><br><span class="line">go: downloading github.com/go-logr/logr v1.4.2</span><br><span class="line">go: downloading k8s.io/klog/v2 v2.130.1</span><br><span class="line">go: downloading golang.org/x/exp v0.0.0-20230515195305-f3d0a9c9a5cc</span><br><span class="line">go: downloading github.com/evanphx/json-patch/v5 v5.9.0</span><br><span class="line">go: downloading github.com/prometheus/client_golang v1.19.1</span><br><span class="line">go: downloading gomodules.xyz/jsonpatch/v2 v2.4.0</span><br><span class="line">go: downloading github.com/gogo/protobuf v1.3.2</span><br><span class="line">go: downloading github.com/google/gofuzz v1.2.0</span><br><span class="line">go: downloading sigs.k8s.io/structured-merge-diff/v4 v4.4.1</span><br><span class="line">go: downloading k8s.io/apiextensions-apiserver v0.31.0</span><br><span class="line">go: downloading sigs.k8s.io/json v0.0.0-20221116044647-bc3834ca7abd</span><br><span class="line">go: downloading k8s.io/kube-openapi v0.0.0-20240228011516-70dd3763d340</span><br><span class="line">go: downloading github.com/google/uuid v1.6.0</span><br><span class="line">go: downloading github.com/prometheus/client_model v0.6.1</span><br><span class="line">go: downloading github.com/prometheus/common v0.55.0</span><br><span class="line">go: downloading github.com/fsnotify/fsnotify v1.7.0</span><br><span class="line">go: downloading golang.org/x/net v0.26.0</span><br><span class="line">go: downloading gopkg.in/inf.v0 v0.9.1</span><br><span class="line">go: downloading github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da</span><br><span class="line">go: downloading github.com/imdario/mergo v0.3.6</span><br><span class="line">go: downloading github.com/spf13/pflag v1.0.5</span><br><span class="line">go: downloading golang.org/x/term v0.21.0</span><br><span class="line">go: downloading github.com/golang/protobuf v1.5.4</span><br><span class="line">go: downloading github.com/google/gnostic-models v0.6.8</span><br><span class="line">go: downloading golang.org/x/time v0.3.0</span><br><span class="line">go: downloading sigs.k8s.io/yaml v1.4.0</span><br><span class="line">go: downloading github.com/beorn7/perks v1.0.1</span><br><span class="line">go: downloading github.com/cespare/xxhash/v2 v2.3.0</span><br><span class="line">go: downloading github.com/prometheus/procfs v0.15.1</span><br><span class="line">go: downloading golang.org/x/sys v0.21.0</span><br><span class="line">go: downloading google.golang.org/protobuf v1.34.2</span><br><span class="line">go: downloading golang.org/x/oauth2 v0.21.0</span><br><span class="line">go: downloading github.com/json-iterator/go v1.1.12</span><br><span class="line">go: downloading gopkg.in/yaml.v2 v2.4.0</span><br><span class="line">go: downloading github.com/fxamacker/cbor/v2 v2.7.0</span><br><span class="line">go: downloading github.com/google/go-cmp v0.6.0</span><br><span class="line">go: downloading gopkg.in/yaml.v3 v3.0.1</span><br><span class="line">go: downloading github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc</span><br><span class="line">go: downloading github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822</span><br><span class="line">go: downloading github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd</span><br><span class="line">go: downloading github.com/modern-go/reflect2 v1.0.2</span><br><span class="line">go: downloading github.com/go-openapi/jsonreference v0.20.2</span><br><span class="line">go: downloading github.com/go-openapi/swag v0.22.4</span><br><span class="line">go: downloading golang.org/x/text v0.16.0</span><br><span class="line">go: downloading github.com/go-openapi/jsonpointer v0.19.6</span><br><span class="line">go: downloading github.com/emicklei/go-restful/v3 v3.11.0</span><br><span class="line">go: downloading github.com/mailru/easyjson v0.7.7</span><br><span class="line">go: downloading github.com/josharian/intern v1.0.0</span><br><span class="line">go: downloading github.com/x448/float16 v0.8.4</span><br><span class="line">go: downloading github.com/pkg/errors v0.9.1</span><br><span class="line">INFO Update dependencies:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go mod tidy</span>           </span><br><span class="line">go: downloading github.com/onsi/ginkgo/v2 v2.19.0</span><br><span class="line">go: downloading github.com/stretchr/testify v1.9.0</span><br><span class="line">go: downloading github.com/onsi/gomega v1.33.1</span><br><span class="line">go: downloading github.com/go-logr/zapr v1.3.0</span><br><span class="line">go: downloading go.uber.org/zap v1.26.0</span><br><span class="line">go: downloading k8s.io/apiserver v0.31.0</span><br><span class="line">go: downloading go.uber.org/goleak v1.3.0</span><br><span class="line">go: downloading github.com/evanphx/json-patch v0.5.2</span><br><span class="line">go: downloading gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c</span><br><span class="line">go: downloading gopkg.in/evanphx/json-patch.v4 v4.12.0</span><br><span class="line">go: downloading github.com/kr/pretty v0.3.1</span><br><span class="line">go: downloading go.uber.org/multierr v1.11.0</span><br><span class="line">go: downloading github.com/go-task/slim-sprig/v3 v3.0.0</span><br><span class="line">go: downloading golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d</span><br><span class="line">go: downloading github.com/google/pprof v0.0.0-20240525223248-4bfdf5a9a2af</span><br><span class="line">go: downloading github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2</span><br><span class="line">go: downloading github.com/rogpeppe/go-internal v1.12.0</span><br><span class="line">go: downloading github.com/kr/text v0.2.0</span><br><span class="line">go: downloading k8s.io/component-base v0.31.0</span><br><span class="line">go: downloading go.opentelemetry.io/otel v1.28.0</span><br><span class="line">go: downloading go.opentelemetry.io/otel/trace v1.28.0</span><br><span class="line">go: downloading google.golang.org/grpc v1.65.0</span><br><span class="line">go: downloading sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.30.3</span><br><span class="line">go: downloading golang.org/x/sync v0.7.0</span><br><span class="line">go: downloading github.com/google/cel-go v0.20.1</span><br><span class="line">go: downloading github.com/blang/semver/v4 v4.0.0</span><br><span class="line">go: downloading go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.53.0</span><br><span class="line">go: downloading go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.27.0</span><br><span class="line">go: downloading go.opentelemetry.io/otel/sdk v1.28.0</span><br><span class="line">go: downloading google.golang.org/genproto/googleapis/api v0.0.0-20240528184218-531527333157</span><br><span class="line">go: downloading github.com/felixge/httpsnoop v1.0.4</span><br><span class="line">go: downloading go.opentelemetry.io/otel/metric v1.28.0</span><br><span class="line">go: downloading github.com/asaskevich/govalidator v0.0.0-20190424111038-f61b66f89f4a</span><br><span class="line">go: downloading github.com/go-logr/stdr v1.2.2</span><br><span class="line">go: downloading google.golang.org/genproto/googleapis/rpc v0.0.0-20240701130421-f6361c86f094</span><br><span class="line">go: downloading github.com/antlr4-go/antlr/v4 v4.13.0</span><br><span class="line">go: downloading google.golang.org/genproto v0.0.0-20230822172742-b8732ec3820d</span><br><span class="line">go: downloading github.com/spf13/cobra v1.8.1</span><br><span class="line">go: downloading github.com/stoewer/go-strcase v1.2.0</span><br><span class="line">go: downloading github.com/inconshreveable/mousetrap v1.1.0</span><br><span class="line">go: downloading go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.28.0</span><br><span class="line">go: downloading github.com/cenkalti/backoff/v4 v4.3.0</span><br><span class="line">go: downloading go.opentelemetry.io/proto/otlp v1.3.1</span><br><span class="line">go: downloading github.com/grpc-ecosystem/grpc-gateway/v2 v2.20.0</span><br><span class="line">go: downloading github.com/grpc-ecosystem/grpc-gateway v1.16.0</span><br><span class="line">Next: define a resource with:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubebuilder create api</span></span><br></pre></td></tr></table></figure>

<p>本步骤创建了 Go module 工程的模板文件，引入了必要的依赖。<br>这里先设置了go的代理，不然会无法下载依赖。<br>第一次新建工程时，会下载一些依赖(go: downloading 。。。)<br>查看此时的项目结构:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmd</span><br><span class="line">│   └── main.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── manager_metrics_patch.yaml</span><br><span class="line">│   │   └── metrics_service.yaml</span><br><span class="line">│   ├── manager</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── manager.yaml</span><br><span class="line">│   ├── network-policy</span><br><span class="line">│   │   ├── allow-metrics-traffic.yaml</span><br><span class="line">│   │   └── kustomization.yaml</span><br><span class="line">│   ├── prometheus</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── monitor.yaml</span><br><span class="line">│   └── rbac</span><br><span class="line">│       ├── kustomization.yaml</span><br><span class="line">│       ├── leader_election_role_binding.yaml</span><br><span class="line">│       ├── leader_election_role.yaml</span><br><span class="line">│       ├── metrics_auth_role_binding.yaml</span><br><span class="line">│       ├── metrics_auth_role.yaml</span><br><span class="line">│       ├── metrics_reader_role.yaml</span><br><span class="line">│       ├── role_binding.yaml</span><br><span class="line">│       ├── role.yaml</span><br><span class="line">│       └── service_account.yaml</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   └── boilerplate.go.txt</span><br><span class="line">├── Makefile</span><br><span class="line">├── PROJECT</span><br><span class="line">├── README.md</span><br><span class="line">└── test</span><br><span class="line">    ├── e2e</span><br><span class="line">    │   ├── e2e_suite_test.go</span><br><span class="line">    │   └── e2e_test.go</span><br><span class="line">    └── utils</span><br><span class="line">        └── utils.go</span><br><span class="line"></span><br><span class="line">12 directories, 29 files</span><br></pre></td></tr></table></figure>

<p>创建API，生成CRD和Controller:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubebuilder create api --group apps --version v1 --kind Myapp</span><br></pre></td></tr></table></figure>

<p>参数含义：</p>
<ul>
<li>group参数表示组的概念</li>
<li>version定义版本</li>
<li>kind定义自定义资源类型</li>
<li>以上参数组成 自定义yaml 的 apiVersion和kind</li>
<li>执行kubebuilder create api时直接带上–namespaced&#x3D;false可以将该对象设计为集群级别（类似node、pv）</li>
</ul>
<p>创建API结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubebuilder create api --group apps --version v1 --kind Myapp</span><br><span class="line">INFO Create Resource [y/n]                        </span><br><span class="line">y</span><br><span class="line">INFO Create Controller [y/n]                      </span><br><span class="line">y</span><br><span class="line">INFO Writing kustomize manifests for you to edit... </span><br><span class="line">INFO Writing scaffold for you to edit...          </span><br><span class="line">INFO api/v1/myapp_types.go                        </span><br><span class="line">INFO api/v1/groupversion_info.go                  </span><br><span class="line">INFO internal/controller/suite_test.go            </span><br><span class="line">INFO internal/controller/myapp_controller.go      </span><br><span class="line">INFO internal/controller/myapp_controller_test.go </span><br><span class="line">INFO Update dependencies:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go mod tidy</span>           </span><br><span class="line">INFO Running make:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make generate</span>                </span><br><span class="line">mkdir -p /home/king/workspace/king-devops/operator/myapp-operator/bin</span><br><span class="line">Downloading sigs.k8s.io/controller-tools/cmd/controller-gen@v0.16.1</span><br><span class="line">go: downloading sigs.k8s.io/controller-tools v0.16.1</span><br><span class="line">go: downloading github.com/fatih/color v1.17.0</span><br><span class="line">go: downloading golang.org/x/tools v0.24.0</span><br><span class="line">go: downloading github.com/gobuffalo/flect v1.0.2</span><br><span class="line">go: downloading golang.org/x/net v0.28.0</span><br><span class="line">go: downloading github.com/mattn/go-isatty v0.0.20</span><br><span class="line">go: downloading github.com/mattn/go-colorable v0.1.13</span><br><span class="line">go: downloading golang.org/x/sys v0.23.0</span><br><span class="line">go: downloading golang.org/x/sync v0.8.0</span><br><span class="line">go: downloading golang.org/x/mod v0.20.0</span><br><span class="line">go: downloading golang.org/x/text v0.17.0</span><br><span class="line">/home/king/workspace/king-devops/operator/myapp-operator/bin/controller-gen object:headerFile=&quot;hack/boilerplate.go.txt&quot; paths=&quot;./...&quot;</span><br><span class="line">Next: implement your new API and generate the manifests (e.g. CRDs,CRs) with:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make manifests</span></span><br></pre></td></tr></table></figure>

<p>此时的目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── api</span><br><span class="line">│   └── v1</span><br><span class="line">│       ├── groupversion_info.go</span><br><span class="line">│       ├── myapp_types.go</span><br><span class="line">│       └── zz_generated.deepcopy.go</span><br><span class="line">├── bin</span><br><span class="line">│   ├── controller-gen -&gt; /home/king/workspace/king-devops/operator/myapp-operator/bin/controller-gen-v0.16.1</span><br><span class="line">│   └── controller-gen-v0.16.1</span><br><span class="line">├── cmd</span><br><span class="line">│   └── main.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── crd</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── kustomizeconfig.yaml</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── manager_metrics_patch.yaml</span><br><span class="line">│   │   └── metrics_service.yaml</span><br><span class="line">│   ├── manager</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── manager.yaml</span><br><span class="line">│   ├── network-policy</span><br><span class="line">│   │   ├── allow-metrics-traffic.yaml</span><br><span class="line">│   │   └── kustomization.yaml</span><br><span class="line">│   ├── prometheus</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── monitor.yaml</span><br><span class="line">│   ├── rbac</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── leader_election_role_binding.yaml</span><br><span class="line">│   │   ├── leader_election_role.yaml</span><br><span class="line">│   │   ├── metrics_auth_role_binding.yaml</span><br><span class="line">│   │   ├── metrics_auth_role.yaml</span><br><span class="line">│   │   ├── metrics_reader_role.yaml</span><br><span class="line">│   │   ├── myapp_editor_role.yaml</span><br><span class="line">│   │   ├── myapp_viewer_role.yaml</span><br><span class="line">│   │   ├── role_binding.yaml</span><br><span class="line">│   │   ├── role.yaml</span><br><span class="line">│   │   └── service_account.yaml</span><br><span class="line">│   └── samples</span><br><span class="line">│       ├── apps_v1_myapp.yaml</span><br><span class="line">│       └── kustomization.yaml</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   └── boilerplate.go.txt</span><br><span class="line">├── internal</span><br><span class="line">│   └── controller</span><br><span class="line">│       ├── myapp_controller.go</span><br><span class="line">│       ├── myapp_controller_test.go</span><br><span class="line">│       └── suite_test.go</span><br><span class="line">├── Makefile</span><br><span class="line">├── PROJECT</span><br><span class="line">├── README.md</span><br><span class="line">└── test</span><br><span class="line">    ├── e2e</span><br><span class="line">    │   ├── e2e_suite_test.go</span><br><span class="line">    │   └── e2e_test.go</span><br><span class="line">    └── utils</span><br><span class="line">        └── utils.go</span><br><span class="line"></span><br><span class="line">19 directories, 43 files</span><br></pre></td></tr></table></figure>

<p>如果需要在Nginx CRUD 时进行合法性检查， 可以生成webhook:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubebuilder create webhook --group apps --version v1 --kind Myapp --conversion --defaulting --programmatic-validation</span><br></pre></td></tr></table></figure>

<p>参数含义：</p>
<ul>
<li>group参数表示组的概念</li>
<li>version定义版本</li>
<li>kind定义自定义资源类型</li>
<li>以上参数组成 自定义yaml 的 apiVersion和kind</li>
<li>defaulting：默认值设置（Defaulting） 的目的是在CRD对象创建或更新时，如果某些字段没有被显式设置值，自动为其填充一个合理的默认值。这对于确保资源实例有一套统一的、预先定义的配置非常有用，可以减少用户的配置负担，并保证资源的一致性。例如，如果你定义了一个监控应用的CRD，可能希望默认开启日志记录功能，除非用户明确关闭它。</li>
<li>programmatic-validation：程序化验证（Programmatic Validation） 则是在CRD对象创建或更新前，对提交的数据进行逻辑验证的机制。与CRD schema提供的静态验证相比，程序化验证可以实现更加复杂的业务逻辑验证。这意味着你可以在webhook服务中编写代码来检查CRD实例的数据是否满足特定的业务规则或约束条件。例如，你可以验证一个资源请求的内存配额是否超过了集群的最大允许值，或者确保引用的其他资源确实存在。</li>
<li>conversion：自动数据迁移：conversion webhook可以在后台自动将CRD的一个版本转换为另一个版本，无需人工干预，从而简化了版本升级过程。<ul>
<li>兼容性保障：即使API发生变化，也能确保旧客户端和新客户端都能够正常工作，提高了系统的向后和向前兼容性。</li>
<li>复杂逻辑处理：对于简单的字段添加或删除，Kubernetes的自动转换器可能足够用。但涉及到复杂的数据结构调整或逻辑变换时，就需要自定义conversion webhook来精确控制转换过程。</li>
</ul>
</li>
</ul>
<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubebuilder create webhook --group apps --version v1 --kind Myapp --conversion --defaulting --programmatic-validation</span><br><span class="line">INFO Writing kustomize manifests for you to edit... </span><br><span class="line">INFO Writing scaffold for you to edit...          </span><br><span class="line">INFO api/v1/myapp_webhook.go                      </span><br><span class="line">INFO api/v1/myapp_webhook_test.go                 </span><br><span class="line">INFO Webhook server has been set up for you.</span><br><span class="line">You need to implement the conversion.Hub and conversion.Convertible interfaces for your CRD types. </span><br><span class="line">INFO api/v1/webhook_suite_test.go                 </span><br><span class="line">INFO Update dependencies:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go mod tidy</span>           </span><br><span class="line">INFO Running make:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make generate</span>                </span><br><span class="line">/home/king/workspace/king-devops/operator/myapp-operator/bin/controller-gen object:headerFile=&quot;hack/boilerplate.go.txt&quot; paths=&quot;./...&quot;</span><br><span class="line">Next: implement your new Webhook and generate the manifests with:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make manifests</span></span><br></pre></td></tr></table></figure>

<p>此时目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── api</span><br><span class="line">│   └── v1</span><br><span class="line">│       ├── groupversion_info.go</span><br><span class="line">│       ├── myapp_types.go</span><br><span class="line">│       ├── myapp_webhook.go</span><br><span class="line">│       ├── myapp_webhook_test.go</span><br><span class="line">│       ├── webhook_suite_test.go</span><br><span class="line">│       └── zz_generated.deepcopy.go</span><br><span class="line">├── bin</span><br><span class="line">│   ├── controller-gen -&gt; /home/king/workspace/king-devops/operator/myapp-operator/bin/controller-gen-v0.16.1</span><br><span class="line">│   └── controller-gen-v0.16.1</span><br><span class="line">├── cmd</span><br><span class="line">│   └── main.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── certmanager</span><br><span class="line">│   │   ├── certificate.yaml</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── kustomizeconfig.yaml</span><br><span class="line">│   ├── crd</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── kustomizeconfig.yaml</span><br><span class="line">│   │   └── patches</span><br><span class="line">│   │       ├── cainjection_in_myapps.yaml</span><br><span class="line">│   │       └── webhook_in_myapps.yaml</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── manager_metrics_patch.yaml</span><br><span class="line">│   │   ├── manager_webhook_patch.yaml</span><br><span class="line">│   │   ├── metrics_service.yaml</span><br><span class="line">│   │   └── webhookcainjection_patch.yaml</span><br><span class="line">│   ├── manager</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── manager.yaml</span><br><span class="line">│   ├── network-policy</span><br><span class="line">│   │   ├── allow-metrics-traffic.yaml</span><br><span class="line">│   │   ├── allow-webhook-traffic.yaml</span><br><span class="line">│   │   └── kustomization.yaml</span><br><span class="line">│   ├── prometheus</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── monitor.yaml</span><br><span class="line">│   ├── rbac</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── leader_election_role_binding.yaml</span><br><span class="line">│   │   ├── leader_election_role.yaml</span><br><span class="line">│   │   ├── metrics_auth_role_binding.yaml</span><br><span class="line">│   │   ├── metrics_auth_role.yaml</span><br><span class="line">│   │   ├── metrics_reader_role.yaml</span><br><span class="line">│   │   ├── myapp_editor_role.yaml</span><br><span class="line">│   │   ├── myapp_viewer_role.yaml</span><br><span class="line">│   │   ├── role_binding.yaml</span><br><span class="line">│   │   ├── role.yaml</span><br><span class="line">│   │   └── service_account.yaml</span><br><span class="line">│   ├── samples</span><br><span class="line">│   │   ├── apps_v1_myapp.yaml</span><br><span class="line">│   │   └── kustomization.yaml</span><br><span class="line">│   └── webhook</span><br><span class="line">│       ├── kustomization.yaml</span><br><span class="line">│       ├── kustomizeconfig.yaml</span><br><span class="line">│       └── service.yaml</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   └── boilerplate.go.txt</span><br><span class="line">├── internal</span><br><span class="line">│   └── controller</span><br><span class="line">│       ├── myapp_controller.go</span><br><span class="line">│       ├── myapp_controller_test.go</span><br><span class="line">│       └── suite_test.go</span><br><span class="line">├── Makefile</span><br><span class="line">├── PROJECT</span><br><span class="line">├── README.md</span><br><span class="line">└── test</span><br><span class="line">    ├── e2e</span><br><span class="line">    │   ├── e2e_suite_test.go</span><br><span class="line">    │   └── e2e_test.go</span><br><span class="line">    └── utils</span><br><span class="line">        └── utils.go</span><br><span class="line"></span><br><span class="line">22 directories, 57 files</span><br></pre></td></tr></table></figure>

<p>最终的工程结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── api</span><br><span class="line">│   └── v1</span><br><span class="line">│       ├── groupversion_info.go</span><br><span class="line">│       ├── myapp_types.go</span><br><span class="line">│       ├── myapp_webhook.go</span><br><span class="line">│       ├── myapp_webhook_test.go</span><br><span class="line">│       ├── webhook_suite_test.go</span><br><span class="line">│       └── zz_generated.deepcopy.go</span><br><span class="line">├── bin</span><br><span class="line">│   ├── controller-gen -&gt; /home/king/workspace/king-devops/operator/myapp-operator/bin/controller-gen-v0.16.1</span><br><span class="line">│   └── controller-gen-v0.16.1</span><br><span class="line">├── cmd</span><br><span class="line">│   └── main.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── certmanager</span><br><span class="line">│   │   ├── certificate.yaml</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── kustomizeconfig.yaml</span><br><span class="line">│   ├── crd</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── kustomizeconfig.yaml</span><br><span class="line">│   │   └── patches</span><br><span class="line">│   │       ├── cainjection_in_myapps.yaml</span><br><span class="line">│   │       └── webhook_in_myapps.yaml</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── manager_metrics_patch.yaml</span><br><span class="line">│   │   ├── manager_webhook_patch.yaml</span><br><span class="line">│   │   ├── metrics_service.yaml</span><br><span class="line">│   │   └── webhookcainjection_patch.yaml</span><br><span class="line">│   ├── manager</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── manager.yaml</span><br><span class="line">│   ├── network-policy</span><br><span class="line">│   │   ├── allow-metrics-traffic.yaml</span><br><span class="line">│   │   ├── allow-webhook-traffic.yaml</span><br><span class="line">│   │   └── kustomization.yaml</span><br><span class="line">│   ├── prometheus</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── monitor.yaml</span><br><span class="line">│   ├── rbac</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── leader_election_role_binding.yaml</span><br><span class="line">│   │   ├── leader_election_role.yaml</span><br><span class="line">│   │   ├── metrics_auth_role_binding.yaml</span><br><span class="line">│   │   ├── metrics_auth_role.yaml</span><br><span class="line">│   │   ├── metrics_reader_role.yaml</span><br><span class="line">│   │   ├── myapp_editor_role.yaml</span><br><span class="line">│   │   ├── myapp_viewer_role.yaml</span><br><span class="line">│   │   ├── role_binding.yaml</span><br><span class="line">│   │   ├── role.yaml</span><br><span class="line">│   │   └── service_account.yaml</span><br><span class="line">│   ├── samples</span><br><span class="line">│   │   ├── apps_v1_myapp.yaml</span><br><span class="line">│   │   └── kustomization.yaml</span><br><span class="line">│   └── webhook</span><br><span class="line">│       ├── kustomization.yaml</span><br><span class="line">│       ├── kustomizeconfig.yaml</span><br><span class="line">│       └── service.yaml</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   └── boilerplate.go.txt</span><br><span class="line">├── internal</span><br><span class="line">│   └── controller</span><br><span class="line">│       ├── myapp_controller.go</span><br><span class="line">│       ├── myapp_controller_test.go</span><br><span class="line">│       └── suite_test.go</span><br><span class="line">├── Makefile</span><br><span class="line">├── PROJECT</span><br><span class="line">├── README.md</span><br><span class="line">└── test</span><br><span class="line">    ├── e2e</span><br><span class="line">    │   ├── e2e_suite_test.go</span><br><span class="line">    │   └── e2e_test.go</span><br><span class="line">    └── utils</span><br><span class="line">        └── utils.go</span><br><span class="line"></span><br><span class="line">22 directories, 57 files</span><br></pre></td></tr></table></figure>

<p>关键目录及其内容的概述：</p>
<ul>
<li>Dockerfile: 定义了用于构建Operator容器镜像的Docker配置文件。</li>
<li>Makefile: 包含了一系列预定义的Make任务，用于构建、测试、运行和部署Operator。</li>
<li>PROJECT: 存储项目元数据的文件，Kubebuilder使用它来跟踪项目的状态和配置。</li>
<li>README.md: 项目的主要说明文档，通常包含项目简介、安装指南、开发流程等信息。</li>
<li>api&#x2F;v1: 定义了自定义资源定义(CRD)的目录，其中包含了资源的Go类型定义及DeepCopy生成文件。<ul>
<li>myapp_types.go: 资源类型的定义(myapp_types.go)</li>
<li>myapp_webhook.go: webhook逻辑</li>
<li>zz_generated.deepcopy.go: 深拷贝生成代码</li>
<li>groupversion_info.go: 定义了API组和版本信息。</li>
</ul>
</li>
<li>bin: 存放项目依赖的可执行文件，如controller-gen，用于CRD代码生成。</li>
<li>cmd&#x2F;main.go: Operator的入口点，负责初始化和运行控制器。</li>
<li>config: 配置目录，包含用于Kubernetes资源部署的各种Kustomize配置。<ul>
<li>crd&#x2F;: 用于CRD资源的Kustomize配置。</li>
<li>default&#x2F;: 应用默认的RBAC、服务等配置。</li>
<li>manager&#x2F;: Operator Manager的部署配置。</li>
<li>network-policy&#x2F;, prometheus&#x2F;, rbac&#x2F;, samples&#x2F;: 分别包含网络策略、Prometheus监控配置、RBAC规则和示例资源的配置。</li>
</ul>
</li>
<li>go.mod, go.sum: Go模块管理文件，记录项目依赖。</li>
<li>hack&#x2F;boilerplate.go.txt: 用于代码生成的模板文件，保持版权头部一致性。</li>
<li>internal&#x2F;controller: Operator控制器的核心逻辑所在，包含监控资源(Myapp)的控制器实现。</li>
<li>test: 测试相关目录。<ul>
<li>e2e&#x2F;: 端到端测试代码，验证整个Operator在Kubernetes集群上的行为。</li>
<li>utils&#x2F;: 测试辅助工具和函数。</li>
</ul>
</li>
</ul>
<h1 id="3、编写代码"><a href="#3、编写代码" class="headerlink" title="3、编写代码"></a>3、编写代码</h1><p>下面主要以Deployment为例，核心逻辑是把自定义CR（Myapp）当做终态，把Deployment当做运行态，通过比对属性的不一致，编写相关的Reconcile逻辑。</p>
<p>一张图解释各种资源和 Controller 的关系：<br><img src="/img_4.png" alt="img_4.png"></p>
<h2 id="3-1-定义-CRD"><a href="#3-1-定义-CRD" class="headerlink" title="3.1 定义 CRD"></a>3.1 定义 CRD</h2><p>在api&#x2F;v1&#x2F;myapp_type.go中定义 Spec 和 Status</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// MyappSpec defines the desired state of Myapp</span><br><span class="line">type MyappSpec struct &#123;</span><br><span class="line">        // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster</span><br><span class="line">        // Important: Run &quot;make&quot; to regenerate code after modifying this file</span><br><span class="line"></span><br><span class="line">        // Foo is an example field of Myapp. Edit myapp_types.go to remove/update</span><br><span class="line">        Foo                   string `json:&quot;foo,omitempty&quot;`</span><br><span class="line">        appsv1.DeploymentSpec `json:&quot;,inline&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MyappStatus defines the observed state of Myapp</span><br><span class="line">type MyappStatus struct &#123;</span><br><span class="line">        // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster</span><br><span class="line">        // Important: Run &quot;make&quot; to regenerate code after modifying this file</span><br><span class="line">        appsv1.DeploymentSpec `json:&quot;,inline&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +kubebuilder:object:root=true</span><br><span class="line">// +kubebuilder:subresource:status</span><br><span class="line"></span><br><span class="line">// Myapp is the Schema for the myapps API</span><br><span class="line">type Myapp struct &#123;</span><br><span class="line">        metav1.TypeMeta   `json:&quot;,inline&quot;`</span><br><span class="line">        metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line"></span><br><span class="line">        Spec   MyappSpec   `json:&quot;spec,omitempty&quot;`</span><br><span class="line">        Status MyappStatus `json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>+kubebuilder</code>并非普通注释，不能随意删除。</p>
<h2 id="3-2-编写Reconcile逻辑"><a href="#3-2-编写Reconcile逻辑" class="headerlink" title="3.2 编写Reconcile逻辑"></a>3.2 编写Reconcile逻辑</h2><p>在internal&#x2F;controller&#x2F;myapp_controller.go中实现 Reconcile 逻辑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func (r *MyappReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) &#123;</span><br><span class="line">        logger := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">        // TODO(user): your logic here</span><br><span class="line">        logger.Info(&quot;start Reconcile&quot; + req.Name)</span><br><span class="line"></span><br><span class="line">        return ctrl.Result&#123;&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-修改Webhook"><a href="#3-3-修改Webhook" class="headerlink" title="3.3 修改Webhook"></a>3.3 修改Webhook</h2><p>在api&#x2F;v1&#x2F;myapp_webhook.go中根据需要进行修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func (r *Myapp) ValidateCreate() error </span><br><span class="line">func (r *Myapp) ValidateUpdate(old runtime.Object) error</span><br><span class="line">func (r *Myapp) Default()</span><br></pre></td></tr></table></figure>

<h2 id="3-4-修改main入口"><a href="#3-4-修改main入口" class="headerlink" title="3.4 修改main入口"></a>3.4 修改main入口</h2><p>以前的老版本kubebuilder生成的项目，需要在cmd&#x2F;main.go添加监听的namespace<br>但是新版本没有这个信息，以下是示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options&#123;</span><br><span class="line">                Scheme:                 scheme,</span><br><span class="line">                Metrics:                metricsServerOptions,</span><br><span class="line">                WebhookServer:          webhookServer,</span><br><span class="line">                HealthProbeBindAddress: probeAddr,</span><br><span class="line">                LeaderElection:         enableLeaderElection,</span><br><span class="line">                LeaderElectionID:       &quot;6a511ed4.kubenode.kingtest.com&quot;,</span><br><span class="line">                // LeaderElectionReleaseOnCancel defines if the leader should step down voluntarily</span><br><span class="line">                // when the Manager ends. This requires the binary to immediately end when the</span><br><span class="line">                // Manager is stopped, otherwise, this setting is unsafe. Setting this significantly</span><br><span class="line">                // speeds up voluntary leader transitions as the new leader don&#x27;t have to wait</span><br><span class="line">                // LeaseDuration time first.</span><br><span class="line">                //</span><br><span class="line">                // In the default scaffold provided, the program ends immediately after</span><br><span class="line">                // the manager stops, so would be fine to enable this option. However,</span><br><span class="line">                // if you are doing or is intended to do any operation such as perform cleanups</span><br><span class="line">                // after the manager stops then its usage might be unsafe.</span><br><span class="line">                // LeaderElectionReleaseOnCancel: true,</span><br></pre></td></tr></table></figure>

<p>如果想监听固定的namespace信息，可以在Reconcile内实现。</p>
]]></content>
  </entry>
  <entry>
    <title>operator简介</title>
    <url>/2025/07/kubernetes/Operator%E5%BC%80%E5%8F%91/operator%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="1-kubernetes背景"><a href="#1-kubernetes背景" class="headerlink" title="1 kubernetes背景"></a>1 kubernetes背景</h1><h2 id="1-1-Controller模式"><a href="#1-1-Controller模式" class="headerlink" title="1.1 Controller模式"></a>1.1 Controller模式</h2><p>controller通过根据被控制对象的属性和字段来实现编排，对于每一个build-in的资源类型，都有对应的controller。</p>
<p>比如以下是一个简单的Deployment的yaml示例：</p>
<p>其对应的Deployment Controller编排动作是确保app&#x3D;test的Pod数量为2，Pod的属性和字段由spec.template定义</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>所有控制器的主要操作都是一个调谐循环（Reconcile loop）。主要有三步：</p>
<ul>
<li>观察期望的状态。</li>
<li>观察所管理资源的当前状态。</li>
<li>采取行动，使托管的资源处在期望的状态。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    actualState := GetResourceActualState(rsvc)</span><br><span class="line">    expectState := GetResourceExpectState(rsvc)</span><br><span class="line">    if actualState == expectState &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Reconcile(rsvc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-2-声明式API"><a href="#1-2-声明式API" class="headerlink" title="1.2 声明式API"></a>1.2 声明式API</h2><p>声明式API：告诉K8S你要什么，而不是告诉它你怎么做。</p>
<p>声明式API的操作体现在kubectl apply命令上，在对象创建和后续修改更新都使用apply命令，告诉k8s对象的终态即可，底层的实现是一个对原有API对象的PATCH操作实现的，可以一次性处理多个写操作，相对于命令时一个个的命令大大提高了操作效率。</p>
<p>比如上面的deployment.yaml文件，在提交后会通过Group&#x2F;Version&#x2F;Resource的分级来找到deployment在GO语言中的结构体定义，从而将YAML描述转换成一个序列化的deployment对象，并通过etcd的API将其保存起来。</p>
<h2 id="1-3-“原生的资源-Controller”的问题"><a href="#1-3-“原生的资源-Controller”的问题" class="headerlink" title="1.3 “原生的资源-Controller”的问题"></a>1.3 “原生的资源-Controller”的问题</h2><ul>
<li>原生资源不够用<ul>
<li>K8S内部的基础资源，如Pod、Statefulset、Service，能够覆盖大部分应用的工作模式。</li>
<li>但对以下情况不友好：<ul>
<li>有些应用组件无法找到合适的基础资源作为模板，比如GPU资源、训练数据集、训练任务等；</li>
<li>有些应用组件需要多个基础资源共同输出一项能力，会变得很复杂；</li>
</ul>
</li>
</ul>
</li>
<li>细粒度操作繁琐<ul>
<li>需要对云原生K8S的细粒度资源的种类比较熟悉；</li>
<li>应用在提供服务时，存在通过Label等标签信息对应的逻辑。</li>
</ul>
</li>
<li>缺乏定制化能力，如：<ul>
<li>一些简单的中间件集成</li>
<li>对不同资源的操作时序的流水线管理。</li>
</ul>
</li>
</ul>
<h2 id="1-4-拓展自定义资源与控制器"><a href="#1-4-拓展自定义资源与控制器" class="headerlink" title="1.4 拓展自定义资源与控制器"></a>1.4 拓展自定义资源与控制器</h2><p>主要做两件事：</p>
<ul>
<li>编写自定义资源，并将其部署到K8S集群中: 通过编写符合K8S资源和结构属性的文件，使得K8S能够校验该资源并进行持久化。</li>
<li>编写其对应的控制器，并将其部署到K8S集群中: 通过实现调谐逻辑，来完成资源编排的实际需求。</li>
</ul>
<h1 id="2、Operator-介绍"><a href="#2、Operator-介绍" class="headerlink" title="2、Operator 介绍"></a>2、Operator 介绍</h1><h2 id="2-1-Operator"><a href="#2-1-Operator" class="headerlink" title="2.1 Operator"></a>2.1 Operator</h2><p>借助 Kubernetes 的控制器模式，编写自定义的编排规则，完成对自定义资源的操作，比如增删改查等。</p>
<p>一般来说，Operator&#x3D;CRD(自定义资源)+Controller(自定义控制器)+Webhook(Admission根据实际情况选择是否添加)</p>
<h2 id="2-2-自定义资源-CRD"><a href="#2-2-自定义资源-CRD" class="headerlink" title="2.2 自定义资源 CRD"></a>2.2 自定义资源 CRD</h2><p>CRD（Custom Resource Definition）是用户的自定义资源类型，可以基于Kubernetes的API Server进行管理。其实例为CR（Custom Resource）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apiextensions.k8s.io/v1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  name: test ## CRD名称</span><br><span class="line">spec:</span><br><span class="line">  conversion:</span><br><span class="line">    strategy: None</span><br><span class="line">  group: tq   # REST API: /apis/&lt;group&gt;/&lt;version&gt;</span><br><span class="line">  names:</span><br><span class="line">    kind: App</span><br><span class="line">    listKind: AppList</span><br><span class="line">    plural: apps</span><br><span class="line">    singular: app</span><br><span class="line">  scope: Namespaced  # 资源是否区分namespace</span><br><span class="line">  versions: [] # 资源的版本信息，例如：v1beta1、v1等</span><br></pre></td></tr></table></figure>

<h2 id="2-3-自定义控制器-Controller"><a href="#2-3-自定义控制器-Controller" class="headerlink" title="2.3 自定义控制器 Controller"></a>2.3 自定义控制器 Controller</h2><p>Kubernetes控制器会监视资源的创建&#x2F;更新&#x2F;删除事件，并触发 Reconcile 函数作为响应。Reconcile 是一个使用 object（Resource 的实例）的命名空间和实例名来调用的函数，使object的实际状态与object的Spec中定义的状态保持一致。 调用完成后，Reconcile 会将object的状态更新为当前实际状态。</p>
<p>在实际环境中，Controller会被打包成镜像，以Deployment拉起的Pod的形式应用在集群中，并用service中的ClusterIP方式进行服务暴露发现。<br><img src="/img.png" alt="img.png"></p>
<h2 id="2-4-名词解释"><a href="#2-4-名词解释" class="headerlink" title="2.4 名词解释"></a>2.4 名词解释</h2><ul>
<li>CRD（Custom Resource Definition）: CRD允许用户在Kubernetes API中定义新的资源类型。这意味着你可以创建符合自己应用或服务特性的资源，这些资源能够被Kubernetes以类似于内置资源（如Pods、Services）的方式来管理和操作。CRD实质上是扩展了Kubernetes API的功能，允许你定义资源的名称、字段结构、验证规则等元数据。通过YAML或JSON文件定义CRD后，Kubernetes会将其注册到API服务器，使得用户可以通过Kubernetes API来创建、读取、更新和删除这些自定义资源。</li>
<li>CR（Custom Resource）: CR是基于CRD定义的具体实例。一旦定义了CRD，用户就可以创建该类型的资源实例，这些实例就是CR。每个CR代表了特定的配置或状态，比如一个特定数据库实例的配置、一个复杂应用的部署配置等。CR的工作原理类似于Kubernetes中的其他对象（如Deployment、Service），但它们是用户自定义的，能够更好地适应特定应用的需求。开发者或运维人员通过创建CR来声明他们希望在集群中部署或管理的资源状态，而与之关联的Operator会根据这些声明来创建、维护和更新实际的Kubernetes对象。</li>
<li>GVK（Group, Version, Kind）: GVK代表了资源的组（Group）、版本（Version）和种类（Kind）。它是从资源的API层面描述资源的一种方式。<ul>
<li>Group：指资源所属的API组，用于区分不同功能领域的API。例如，apps&#x2F;v1中的apps就是组名，它通常对应着Kubernetes的一个特定功能领域，如应用程序管理。</li>
<li>Version：资源的API版本，表明资源定义遵循的特定API版本规范。随着Kubernetes的发展，资源的API可能会有变化，版本号帮助区分这些不同的规范。</li>
<li>Kind：资源的类型，如Pod、Service、Deployment等，它定义了一类资源的基本结构和用途。</li>
</ul>
</li>
<li>GVR (Group, Version, Resource): GVR与GVK类似，但用Resource替换了Kind，它从资源的访问路径角度描述资源。<ul>
<li>Group：指资源所属的API组，用于区分不同功能领域的API。例如，apps&#x2F;v1中的apps就是组名，它通常对应着Kubernetes的一个特定功能领域，如应用程序管理。</li>
<li>Version：资源的API版本，表明资源定义遵循的特定API版本规范。随着Kubernetes的发展，资源的API可能会有变化，版本号帮助区分这些不同的规范。</li>
<li>Resource: 指的是资源在API路径中的名称，它直接关联到API端点，是用于与API服务器交互时的URL路径组成部分。Resource通常与Kind相似或相同，但在某些情况下可能有细微差别，特别是在使用自定义资源定义（CRDs）时。</li>
</ul>
</li>
<li>Scheme: 负责管理和注册API类型（如各种资源对象）以及它们之间的转换关系。简单来说，Scheme是理解和操作Kubernetes对象的基础框架，它确保了对象的序列化、反序列化以及类型转换能够正确进行<ul>
<li>类型注册：Scheme允许你注册自定义或内置的API类型。这意味着你可以告诉Scheme如何识别和处理特定的Go结构体类型，比如Pod、Service、或者自定义资源定义（CRDs）等。</li>
<li>对象转换：它提供了类型转换功能，允许在不同的API版本之间转换对象。这对于处理API的版本兼容性和升级非常重要。</li>
<li>默认化：Scheme支持为对象设置默认值。当创建或更新资源时，如果没有明确指定某些字段，Scheme可以根据预设规则自动填充默认值</li>
<li>序列化与反序列化：Scheme知道如何将Go结构体转换为JSON或YAML格式的数据（序列化），以及如何将这些数据反序列化回Go结构体。这对于与Kubernetes API服务器通信至关重要。</li>
<li>元数据处理：它还负责处理对象的元数据，如API版本信息和Kind信息，确保这些信息在序列化和反序列化过程中得到妥善处理。</li>
</ul>
</li>
<li>Manager：Manager整合了一系列功能，使得开发者能够更容易地创建和管理自定义资源（CRDs）及其对应的控制器逻辑。以下是Manager的一些关键职责和功能<ul>
<li>自定义资源管理：Manager负责监听和管理自定义资源定义（CRDs）的变化，当CR实例被创建、更新或删除时，它能确保相应的控制器逻辑得到执行。</li>
<li>控制器注册：它提供了一个中心点来注册和管理不同的控制器（Controllers）。控制器是执行具体业务逻辑的组件，负责维护期望状态与实际集群状态的一致性。</li>
<li>依赖注入：Manager框架通常支持依赖注入，使得开发者可以轻松地复用和共享服务，比如客户端集（ClientSets）用于与Kubernetes API交互、日志记录器、事件记录器等。</li>
<li>领导者选举：在分布式环境中，Manager可以实现领导者选举逻辑，确保在一个集群中只有一个活跃的实例在执行操作，避免冲突和重复处理。</li>
<li>Webhook注册：它还可能支持注册和管理自定义的Admission Webhooks，允许在资源创建或修改时插入自定义验证或修改逻辑。</li>
<li>生命周期管理：Manager负责启动、停止控制器，以及处理它们的生命周期事件，确保资源的有效管理和清理。</li>
</ul>
</li>
<li>Controller：Kubebuilder为我们生成的脚手架文件，我们只需要实现Reconcile方法即可。</li>
<li>Informers：在Kubernetes中，Informers是客户端库（client-go）提供的一个核心组件，用于高效地监听和同步Kubernetes API资源的变化。它是实现控制器模式的关键技术之一，尤其是对于那些需要根据资源状态变化做出反应的组件，如自定义控制器、Operator等<ul>
<li>资源监听：Informers持续监听Kubernetes API服务器中指定资源类型（如Pods、Deployments等）的增删改事件，通过watch API机制实现近乎实时的资源变化感知。</li>
<li>缓存同步：它在本地维护一个资源对象的缓存副本，这个缓存会随着API服务器的事件更新而自动保持最新状态。这样，控制器或其他组件可以直接查询本地缓存获取资源列表或详情，而不需要频繁地直接查询API服务器，大大提高了效率。</li>
<li>事件处理：Informers提供回调机制，允许用户注册处理函数（如EventHandler或Informer的事件处理器），当资源发生变化时自动触发这些函数，执行相应的业务逻辑。</li>
<li>列表和详细信息的统一管理：通过Lister接口，Informers不仅能够提供资源列表，还能高效地获取单个资源的详细信息，进一步简化了资源的管理和查询过程。</li>
</ul>
</li>
<li>Index：由于Controller经常要对Cache进行查询，Kubebuilder提供Index utility给Cache加索引提升查询效率。</li>
<li>Finalizer：在Kubernetes中，Finalizer 是一种高级特性，用于确保资源在其被删除之前能完成必要的清理工作。它作为一种保障机制，可以让控制器或操作者有机会在对象被永久删除前执行一些清理、备份或其他必要的操作，确保资源的优雅删除和资源使用的完整性。<ul>
<li>阻止删除：删除操作会被暂停，直到所有列出的finalizer都被处理完毕。</li>
<li>通知处理者：Kubernetes会通知或等待负责该finalizer的控制器（或外部系统）完成相应的清理操作。</li>
<li>清除Finalizer：一旦处理者完成了其任务，它会通过API更新该对象，从metadata.finalizers字段中移除相应的finalizer项。</li>
<li>继续删除流程：当所有finalizer都被移除后，Kubernetes才会最终从API服务器中删除该对象。</li>
<li>配置Finalizer：Finalizer通常是通过自定义控制器（如Operator）动态添加和管理的。控制器可以在创建或更新资源时向对象的metadata.finalizers字段添加自定义的finalizer名称，同样，在完成清理工作后，需要通过API调用来移除这个finalizer，以允许资源被彻底删除。</li>
</ul>
</li>
<li>OwnerReference工作原理：在Kubernetes中，OwnerReference 是一种机制，用于建立资源对象之间的所有权关系。这种关系定义了资源的生命周期依赖性，即“拥有者”资源（owner）控制着“被拥有”资源（owned resource）的生命周期。当一个资源作为另一个资源的Owner时，它会对被拥有资源的创建、更新和删除产生影响，确保资源之间的一致性和自动化管理。<ul>
<li>自动清理（Garbage Collection）：当一个资源对象被删除，并且它拥有其他资源时，Kubernetes的垃圾收集机制会自动删除这些被拥有的资源，确保资源依赖关系被正确清理，避免孤儿资源的产生。</li>
<li>生命周期耦合：被拥有资源的生命周期与拥有者资源紧密相连。如果拥有者资源被修改或删除，Kubernetes会相应地更新或清理被拥有资源。</li>
<li>防止循环依赖：Kubernetes禁止创建会导致循环OwnerReference关系的资源，以防止资源管理混乱和潜在的死锁情况。</li>
</ul>
</li>
<li>OwnerReference结构定义：OwnerReference是以API对象的一个字段形式存在的，通常位于被拥有资源的metadata.ownerReferences字段中。它包含几个关键属性：<ul>
<li>APIVersion：拥有者的API版本。</li>
<li>Kind：拥有者的资源类型。</li>
<li>Name：拥有者的名称。</li>
<li>UID：拥有者的唯一标识符（UID），这是区分不同资源实例的关键。</li>
<li>Controller（可选）：布尔值，表示是否由一个控制器（如Deployment或StatefulSet）管理这个关系。如果是控制器，Kubernetes会在适当的时候自动管理被拥有资源。</li>
</ul>
</li>
</ul>
<h2 id="2-5-CRD命名规范"><a href="#2-5-CRD命名规范" class="headerlink" title="2.5 CRD命名规范"></a>2.5 CRD命名规范</h2><p>CRD的全名必须是符合如下的命名规范：${Kind}.${Group}.${Organization}.<a href="http://kubenode.alibaba-inc.com/">kubenode.alibaba-inc.com</a>.</p>
<ul>
<li>${Organization}：一般为仓库的git group，即团队英文简称</li>
<li>${Group}：必须是一种功能类别，如ops、apps、auth等，尽量用精简的单个英文单词的方式传达你的CRD属于的”类别”。组成的字母必须小写</li>
<li>${Kind}：即为CRD真正的短名字，用精简的单个或多个英文单词的拼接来明明真正的CRD短名字。如AdvanceDeployment，NetBook等。使用大驼峰命名法(首字母也是答谢，即UpperCamelCase)。</li>
<li><a href="http://alipay.com/">alipay.com</a>：根据自己的公司名称进行确定，即Company Name Domain</li>
<li>目前对于CRD的版本转换不太友好，一般统一使用v1.</li>
</ul>
<h2 id="2-6-Spec，Status-规范"><a href="#2-6-Spec，Status-规范" class="headerlink" title="2.6 Spec，Status 规范"></a>2.6 Spec，Status 规范</h2><ul>
<li>用命令在apis包下生成CRD Types后，请不要随意修改apis里的结构体、命名规则、以及注释。</li>
<li>只能，也只修改${Kind}_types.go文件里的Spec和StatusSpec结构体里的内容。</li>
<li>Spec和StatusSpec里的字段都必须是Public的，也就是字段名首字母是大写。</li>
<li>每个字段，都应该写上JSON Tag，JSON Tag必须使用小驼峰命名法，即LowerCamelCase。</li>
<li>如果字段允许为空，JSON Tag记得带上omitempty。StatusSpec的字段一般都是允许为空的。例子：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type DemoSpecs struct &#123;</span><br><span class="line">        // FiledA 允许为空</span><br><span class="line">        FieldA string `json&quot;fieldA,omitempty&quot;`</span><br><span class="line">        </span><br><span class="line">        // FieldB 不允许为空</span><br><span class="line">        FieldB string `json&quot;fieldB&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Operator-工作流程"><a href="#3-Operator-工作流程" class="headerlink" title="3 Operator 工作流程"></a>3 Operator 工作流程</h1><p><img src="/img_1.png" alt="img_1.png"></p>
<h2 id="3-1-核心组件"><a href="#3-1-核心组件" class="headerlink" title="3.1 核心组件"></a>3.1 核心组件</h2><ul>
<li>Informer：一个依赖 Kubernetes List&#x2F;Watch API 、可监听事件并触发回调函数的二级缓存工具包。<ul>
<li>在启动时Reflector调用List API获得crd的全部Object实例，并缓存在Local Store中。</li>
<li>然后Reflector调用Watch API来获取和监听对象实例的变化，维护缓存的变化。</li>
<li>每当收到add&#x2F;delete等实例请求时，Reflector会将变更的事件+对象推送到deltaFIFO的队列中。</li>
<li>根据delttaFIFO中的内容，先到Local Store中更新对象的信息与状态，之后经过eventHandler进入WorkQueue，进而触发controller的reconcilet调谐逻辑。</li>
</ul>
</li>
<li>WorkQueue：需要处理的事件队列，供controller来进行真正的业务处理。</li>
<li>Control Loop：实际的控制器角色，通过实现调谐逻辑，确保期望和实际运行状态是一致的。通过Lister向Local Store中读Object实例，通过Client向API Server写具体的操作逻辑。</li>
</ul>
<h2 id="3-2-实现细节"><a href="#3-2-实现细节" class="headerlink" title="3.2 实现细节"></a>3.2 实现细节</h2><ul>
<li>消息可靠性：List短链接查询当前全量的资源及状态；Watch长链接接受增量的资源变更事件并做相应处理。两者互相帮助，达到消息的可靠性和数据的一致性。</li>
<li>共享Informer：对同一类型的资源只建立一个链接，为多个controller提供共享cache的能力。</li>
<li>若请求为添加操作，Indexer把API对象保存到本地缓存中，并为它创建索引；若为删除操作，则在本地缓存中删除该对象。</li>
<li>LocalStore 会周期性地把所有资源的信息重新放到 DeltaFIFO 中，确保二级缓存间的同步，让失败的事件得到重新处理。若在入队前发现DeltaFIFO中已经有新版本的Object实例，则不入队。</li>
<li>Reconcilers是核心处理逻辑，但其只获取资源的名称和命名空间，并不知道资源的操作(增删改)是什么，也不知道资源的其他信息。目的就是在收到资源变更时，根据object的期望状态直接调整资源的状态。</li>
</ul>
<h2 id="3-3-以Pod为对象的流程示例"><a href="#3-3-以Pod为对象的流程示例" class="headerlink" title="3.3 以Pod为对象的流程示例"></a>3.3 以Pod为对象的流程示例</h2><p><img src="/img_2.png" alt="img_2.png"></p>
<ul>
<li>Informer 在初始化时，Reflector 会先通过 List API 向 API Server 获得所有的 Pod 实例。</li>
<li>Reflector 拿到全部 Pod 实例后，会将全部 Pod 实例放到 Local Store 中</li>
<li>如果后面 Controller 调用 Lister 的 List&#x2F;Get 方法获取 Pod 实例时， 那么 Lister 会直接从 Local Store 中拿数据。</li>
<li>Informer 初始化完成之后，Reflector开始通过Watch API监听Pod相关的所有事件；如果此时 pod_1 被删除，那么 Reflector 会监听到这个事件。</li>
<li>Reflector 将 pod_1 被删除的这个事件发送到 DeltaFIFO</li>
<li>DeltaFIFO 首先会将这个事件（一般为key : value的形式）存储在自己的WorkQueue，然后会直接操作 Local Store 中的数据，删除 Local Store 中的 pod_1。</li>
<li>WorkQueue 会 Pop 这个事件到 Controller 中。</li>
<li>Controller 收到这个事件，通过 Lister 从本地 Local Store 中获取真正的对象实例，执行真正的业务逻辑。<ul>
<li>若有关联资源（ownerReference为该对象的资源），则删除关联资源。</li>
<li>若无关联资源，则等待读取下一个事件。</li>
</ul>
</li>
</ul>
<h1 id="4-原生实现"><a href="#4-原生实现" class="headerlink" title="4 原生实现"></a>4 原生实现</h1><ul>
<li>CRD实现： 首先利用CRD的定义文件types.go，通过官方的code-generator生成CRD的相关代码，包括标准client，deepcopy，informer和lister。</li>
<li>controller实现： 然后基于官方的sample-controller的实践示例，进行自定义的编排逻辑编写，包括对于不同add &#x2F; update &#x2F;delete 等操作的响应等细节操作。</li>
<li>YAML文件编写： 手动编写CRD定义和Deployment定义YAML文件，通过kubectl apply完成k8s资源的扩展和控制器的部署。</li>
<li>其他开发工作： 比如对Controller进行二进制编译、镜像打包上传、以Deployment中的Pod的形式部署到K8s中等。</li>
</ul>
<p>等后面来看下，这些工作中，脚手架能帮忙实现多少。<br><img src="/img_3.png" alt="img_3.png"></p>
]]></content>
  </entry>
  <entry>
    <title>tencentcloud_ckafka_instance</title>
    <url>/2025/07/devops/terraform/tencentcloud_ckafka_instance/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>约定格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── aliyun                                             # 云厂商实例文件</span><br><span class="line">│   └── aliyun_ecs_mod_demo                           # 模型名</span><br><span class="line">│       └── aliyun_china_platform_7111                # 云账号名</span><br><span class="line">│           └── ecs_instance_name_20241224121212      # 实例名</span><br><span class="line">│               ├── backend.tf                        # 实例state文件保存说明：oss</span><br><span class="line">│               └── main.tf                           # 实例具体的参数</span><br><span class="line">├── modules                                            # 模型数据文件夹</span><br><span class="line">│   ├── aliyun                                        # 云厂商模型文件夹</span><br><span class="line">│   │   └── aliyun_ecs_mod_demo                       # 模型名</span><br><span class="line">│   │       ├── main.tf                               # 模型定义主文件</span><br><span class="line">│   │       ├── outputs.tf                            # 模型定义输出文件</span><br><span class="line">│   │       └── variables.tf                          # 模型定义参数文件</span><br><span class="line">│   └── tenmod                                         # 另一个云厂商模型</span><br><span class="line">└── tenent                                              # 另一个云厂商实例文件</span><br></pre></td></tr></table></figure>

<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── modules</span><br><span class="line">│   └── tcloud</span><br><span class="line">│       └── tcloud_ckafka_mod_demo</span><br><span class="line">│           ├── main.tf</span><br><span class="line">│           ├── outputs.tf</span><br><span class="line">│           └── variables.tf</span><br><span class="line">└── tcloud</span><br><span class="line">    └── tcloud_ckafka_demo</span><br><span class="line">        └── tcloud_china_game_x6</span><br><span class="line">            └── ckafaka_demo_202501221738</span><br><span class="line">                ├── backend.tf</span><br><span class="line">                └── main.tf</span><br></pre></td></tr></table></figure>

<h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><h3 id="modules-tcloud-tcloud-ckafka-mod-demo-main-tf"><a href="#modules-tcloud-tcloud-ckafka-mod-demo-main-tf" class="headerlink" title="&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;main.tf"></a>&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;main.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    tencentcloud = &#123;</span><br><span class="line">      source = &quot;tencentcloudstack/tencentcloud&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;tencentcloud&quot; &#123;</span><br><span class="line">  region = var.region</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;tencentcloud_availability_zones_by_product&quot; &quot;zone&quot; &#123;</span><br><span class="line">  name    = var.availability_zone</span><br><span class="line">  product = &quot;ckafka&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;tencentcloud_ckafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">  instance_name      = var.instance_name</span><br><span class="line">  zone_id            = data.tencentcloud_availability_zones_by_product.zone.zones[0].id</span><br><span class="line">  vpc_id             = var.vpc_id</span><br><span class="line">  subnet_id          = var.vswitch_id</span><br><span class="line">  msg_retention_time = var.msg_retention_time</span><br><span class="line">  kafka_version      = var.kafka_version</span><br><span class="line">  disk_size          = var.disk_size</span><br><span class="line">  band_width         = var.band_width</span><br><span class="line">  disk_type          = var.disk_type</span><br><span class="line">  partition          = var.partition</span><br><span class="line">  charge_type        = var.charge_type</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  config &#123;</span><br><span class="line">    auto_create_topic_enable   = var.auto_create_topic_enable</span><br><span class="line">    default_num_partitions     = var.num_partitions</span><br><span class="line">    default_replication_factor = var.replication_factor</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dynamic_retention_config &#123;</span><br><span class="line">    enable = var.dynamic_retention_config_enable</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="modules-tcloud-tcloud-ckafka-mod-demo-outputs-tf"><a href="#modules-tcloud-tcloud-ckafka-mod-demo-outputs-tf" class="headerlink" title="&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;outputs.tf"></a>&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;outputs.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">output &quot;ckafka_instance_id&quot; &#123;</span><br><span class="line">  value = tencentcloud_ckafka_instance.this.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="modules-tcloud-tcloud-ckafka-mod-demo-variables-tf"><a href="#modules-tcloud-tcloud-ckafka-mod-demo-variables-tf" class="headerlink" title="&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;variables.tf"></a>&#x2F;modules&#x2F;tcloud&#x2F;tcloud_ckafka_mod_demo&#x2F;variables.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">variable &quot;region&quot; &#123;</span><br><span class="line">  description = &quot;地域&quot;</span><br><span class="line">  type        = string</span><br><span class="line">  default     = &quot;ap-shanghai&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;instance_name&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例名&quot;</span><br><span class="line">  type        = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;availability_zone&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">如ap-shanghai-2</span></span><br><span class="line">  description = &quot;可用区&quot;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;charge_type&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">PREPAID(预付费), POSTPAID_BY_HOUR(按量付费)</span></span><br><span class="line">  description = &quot;kafka实例计费方式&quot;</span><br><span class="line">  type = string</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([&quot;PREPAID&quot;, &quot;POSTPAID_BY_HOUR&quot;], var.charge_type)</span><br><span class="line">    error_message = &quot;The charge_type must be one of PREPAID, POSTPAID_BY_HOUR&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;kafka_version&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">0.10.2/1.1.1/2.4.1/2.8.1</span></span><br><span class="line">  description = &quot;kafka实例版本&quot;</span><br><span class="line">  type = string</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([&quot;0.10.2&quot;, &quot;1.1.1&quot;, &quot;2.4.1&quot;, &quot;2.4.2&quot;, &quot;2.8.1&quot;], var.kafka_version)</span><br><span class="line">    error_message = &quot;The kafka_version must be one of 0.10.2, 1.1.1, 2.4.1, 2.4.2, 2.8.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">variable &quot;vswitch_id&quot; &#123;</span><br><span class="line">  // 阿里云vswitch_id -&gt; 腾讯云subnet_id</span><br><span class="line">  description = &quot;绑定子网id&quot;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;vpc_id&quot; &#123;</span><br><span class="line">  description = &quot;绑定vpc_id&quot;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;disk_size&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">需满足当前实例的计费规格，此处预设200和400，可以根据需要修改</span></span><br><span class="line">  description = &quot;kafka实例磁盘规格&quot;</span><br><span class="line">  type = number</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([200, 400], var.disk_size)</span><br><span class="line">    error_message = &quot;The disk_size must be one of 200, 400&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;disk_type&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">专业版实例磁盘类型，标准版实例不需要填写，CLOUD_SSD(SSD云硬盘), CLOUD_BASIC(高性能云硬盘)</span></span><br><span class="line">  description = &quot;kafka专业版实例磁盘类型&quot;</span><br><span class="line">  type = string</span><br><span class="line">  default = &quot;&quot;</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([&quot;&quot;, &quot;CLOUD_SSD&quot;, &quot;CLOUD_BASIC&quot;], var.disk_type)</span><br><span class="line">    error_message = &quot;The disk_type must be empty, or one of CLOUD_SSD, CLOUD_BASIC&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;band_width&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">单位为MBps.</span></span><br><span class="line">  description = &quot;kafka实例带宽&quot;</span><br><span class="line">  type = number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;auto_create_topic_enable&quot; &#123;</span><br><span class="line">  description = &quot;是否自动创建topic&quot;</span><br><span class="line">  type = bool</span><br><span class="line">  default = true</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([true, false], var.auto_create_topic_enable)</span><br><span class="line">    error_message = &quot;The auto_create_topic_enable must be one of true, false&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;num_partitions&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例默认分区数&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;replication_factor&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例默认副本数&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;dynamic_retention_config_enable&quot; &#123;</span><br><span class="line">  description = &quot;是否启用动态消息保留时间配置&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 0</span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = contains([0, 1], var.dynamic_retention_config_enable)</span><br><span class="line">    error_message = &quot;The dynamic_retention_config_enable must be one of 0, 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;msg_retention_time&quot; &#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">以分钟为单位</span></span><br><span class="line">  description = &quot;kafka实例日志的最大保留时间&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 10080</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;partition&quot; &#123;</span><br><span class="line">  description = &quot;kafka实例分区大小&quot;</span><br><span class="line">  type = number</span><br><span class="line">  default = 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="tcloud-tcloud-ckafka-demo-tcloud-china-game-x6-ckafaka-demo-202501221738-backend-tf"><a href="#tcloud-tcloud-ckafka-demo-tcloud-china-game-x6-ckafaka-demo-202501221738-backend-tf" class="headerlink" title="&#x2F;tcloud&#x2F;tcloud_ckafka_demo&#x2F;tcloud_china_game_x6&#x2F;ckafaka_demo_202501221738&#x2F;backend.tf"></a>&#x2F;tcloud&#x2F;tcloud_ckafka_demo&#x2F;tcloud_china_game_x6&#x2F;ckafaka_demo_202501221738&#x2F;backend.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  backend &quot;oss&quot; &#123;</span><br><span class="line">    endpoint = &quot;oss-cn-hangzhou.aliyuncs.com&quot;</span><br><span class="line">    bucket   = &quot;dz-devops&quot; # 替换为你的 OSS Bucket 名称</span><br><span class="line">    prefix = &quot;terraform_state/tcloud/tcloud_ckafka_demo/tcloud_china_game_x6/ckafka_demo_202501221738&quot;</span><br><span class="line">    key      = &quot;terraform.tfstate&quot; # 存储状态文件的路径和名称</span><br><span class="line">    region   = &quot;cn-hangzhou&quot;       # OSS 的地域（根据你的实际情况调整）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcloud-tcloud-ckafka-demo-tcloud-china-game-x6-ckafaka-demo-202501221738-main-tf"><a href="#tcloud-tcloud-ckafka-demo-tcloud-china-game-x6-ckafaka-demo-202501221738-main-tf" class="headerlink" title="&#x2F;tcloud&#x2F;tcloud_ckafka_demo&#x2F;tcloud_china_game_x6&#x2F;ckafaka_demo_202501221738&#x2F;main.tf"></a>&#x2F;tcloud&#x2F;tcloud_ckafka_demo&#x2F;tcloud_china_game_x6&#x2F;ckafaka_demo_202501221738&#x2F;main.tf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module &quot;ckafka_instance&quot; &#123;</span><br><span class="line">  source              = &quot;../../../../modules/tcloud/tcloud_ckafka_mod_demo&quot;</span><br><span class="line">  region              = &quot;ap-shanghai&quot;</span><br><span class="line">  instance_name       = &quot;ckafka-test&quot;</span><br><span class="line">  availability_zone   = &quot;ap-shanghai-2&quot;</span><br><span class="line">  charge_type         = &quot;POSTPAID_BY_HOUR&quot;</span><br><span class="line">  kafka_version       = &quot;2.4.2&quot;</span><br><span class="line">  vpc_id              = &quot;vpc-4tkroxts&quot;</span><br><span class="line">  vswitch_id          = &quot;subnet-oy1pqvzv&quot;</span><br><span class="line">  disk_size           = 200</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">disk_type           = <span class="string">&quot;CLOUD_BASIC&quot;</span></span></span><br><span class="line">  band_width          = 20</span><br><span class="line">  auto_create_topic_enable = true</span><br><span class="line">  num_partitions     = 3</span><br><span class="line">  replication_factor = 3</span><br><span class="line">  dynamic_retention_config_enable = 1</span><br><span class="line">  msg_retention_time = 1300</span><br><span class="line">  partition = 400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><h3 id="获取-AK-SK"><a href="#获取-AK-SK" class="headerlink" title="获取 AK&#x2F;SK"></a>获取 AK&#x2F;SK</h3><p>在首次使用 Terraform 之前，需要前往腾讯云的<a href="https://console.cloud.tencent.com/cam/capi">云 API 密钥页面</a>申请安全凭证SecretId和SecretKey2。若已有可使用的安全凭证，则跳过该步骤2。具体步骤如下2：</p>
<ol>
<li>登录腾讯云<a href="https://console.cloud.tencent.com/cam">访问管理控制台</a>，在左侧导航栏，选择访问密钥&gt;API 密钥管理。</li>
<li>在API 密钥管理页面，单击新建密钥，即可以创建一对SecretId&#x2F;SecretKey。</li>
</ol>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>将获取到的SecretId和SecretKey设置为环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export TENCENTCLOUD_SECRET_ID=your_secret_id</span><br><span class="line">export TENCENTCLOUD_SECRET_KEY=your_secret_key</span><br></pre></td></tr></table></figure>

<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>进入项目根目录，这里是ckafaka_demo_202501221738目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./tcloud/tcloud_ckafka_demo/tcloud_china_game_x6/ckafaka_demo_202501221738/</span><br></pre></td></tr></table></figure>

<p>初始化 Terraform 项目:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xxx替换为实际backend的ak，将yyy替换为实际backend的sk</span></span><br><span class="line">terraform init -backend-config=&quot;access_key=xxx&quot; -backend-config=&quot;secret_key=yyy&quot;</span><br></pre></td></tr></table></figure>

<p>该命令会下载所需的插件和依赖，并初始化后端配置。<br>类似的输出（首次使用某一个provier时，会先下载）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Initializing the backend...</span><br><span class="line"></span><br><span class="line">Successfully configured the backend &quot;oss&quot;! Terraform will automatically</span><br><span class="line">use this backend unless the backend configuration changes.</span><br><span class="line">Initializing modules...</span><br><span class="line">- ckafka_instance in ../../../../modules/tcloud/tcloud_ckafka_mod_demo</span><br><span class="line">Initializing provider plugins...</span><br><span class="line">- Finding latest version of tencentcloudstack/tencentcloud...</span><br><span class="line">- Installing tencentcloudstack/tencentcloud v1.81.162...</span><br><span class="line">- Installed tencentcloudstack/tencentcloud v1.81.162 (signed by a HashiCorp partner, key ID 84F69E1C1BECF459)</span><br><span class="line">Partner and community providers are signed by their developers.</span><br><span class="line">If you&#x27;d like to know more about provider signing, you can read about it here:</span><br><span class="line">https://www.terraform.io/docs/cli/plugins/signing.html</span><br><span class="line">Terraform has created a lock file .terraform.lock.hcl to record the provider</span><br><span class="line">selections it made above. Include this file in your version control repository</span><br><span class="line">so that Terraform can guarantee to make the same selections by default when</span><br><span class="line">you run &quot;terraform init&quot; in the future.</span><br><span class="line"></span><br><span class="line">Terraform has been successfully initialized!</span><br><span class="line"></span><br><span class="line">You may now begin working with Terraform. Try running &quot;terraform plan&quot; to see</span><br><span class="line">any changes that are required for your infrastructure. All Terraform commands</span><br><span class="line">should now work.</span><br><span class="line"></span><br><span class="line">If you ever set or change modules or backend configuration for Terraform,</span><br><span class="line">rerun this command to reinitialize your working directory. If you forget, other</span><br><span class="line">commands will detect it and remind you to do so if necessary.</span><br></pre></td></tr></table></figure>

<h3 id="预览计划变更："><a href="#预览计划变更：" class="headerlink" title="预览计划变更："></a>预览计划变更：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform plan</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Reading...</span><br><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Read complete after 0s [id=2066006299]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.ckafka_instance.tencentcloud_ckafka_instance.this will be created</span></span><br><span class="line">  + resource &quot;tencentcloud_ckafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      + band_width          = 20</span><br><span class="line">      + charge_type         = &quot;POSTPAID_BY_HOUR&quot;</span><br><span class="line">      + disk_size           = 200</span><br><span class="line">      + disk_type           = &quot;CLOUD_BASIC&quot;</span><br><span class="line">      + id                  = (known after apply)</span><br><span class="line">      + instance_name       = &quot;ckafka-test&quot;</span><br><span class="line">      + instance_type       = (known after apply)</span><br><span class="line">      + kafka_version       = &quot;kafka_version&quot;</span><br><span class="line">      + max_message_byte    = (known after apply)</span><br><span class="line">      + msg_retention_time  = 1300</span><br><span class="line">      + partition           = 400</span><br><span class="line">      + public_network      = (known after apply)</span><br><span class="line">      + renew_flag          = (known after apply)</span><br><span class="line">      + specifications_type = &quot;profession&quot;</span><br><span class="line">      + subnet_id           = &quot;subnet-oy1pqvzv&quot;</span><br><span class="line">      + tag_set             = (known after apply)</span><br><span class="line">      + upgrade_strategy    = 1</span><br><span class="line">      + vip                 = (known after apply)</span><br><span class="line">      + vpc_id              = &quot;vpc-4tkroxts&quot;</span><br><span class="line">      + vport               = (known after apply)</span><br><span class="line">      + zone_id             = 200002</span><br><span class="line"></span><br><span class="line">      + config &#123;</span><br><span class="line">          + auto_create_topic_enable   = true</span><br><span class="line">          + default_num_partitions     = 3</span><br><span class="line">          + default_replication_factor = 3</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      + dynamic_retention_config &#123;</span><br><span class="line">          + bottom_retention        = (known after apply)</span><br><span class="line">          + disk_quota_percentage   = (known after apply)</span><br><span class="line">          + enable                  = 1</span><br><span class="line">          + step_forward_percentage = (known after apply)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      + tags (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">Note: You didn&#x27;t use the -out option to save this plan, so Terraform can&#x27;t guarantee to take exactly these actions if you run &quot;terraform apply&quot; now.</span><br></pre></td></tr></table></figure>

<p>执行变更：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform apply</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Reading...</span><br><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Read complete after 1s [id=2066006299]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.ckafka_instance.tencentcloud_ckafka_instance.this will be created</span></span><br><span class="line">  + resource &quot;tencentcloud_ckafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      + band_width          = 20</span><br><span class="line">      + charge_type         = &quot;POSTPAID_BY_HOUR&quot;</span><br><span class="line">      + disk_size           = 200</span><br><span class="line">      + disk_type           = &quot;CLOUD_BASIC&quot;</span><br><span class="line">      + id                  = (known after apply)</span><br><span class="line">      + instance_name       = &quot;ckafka-test&quot;</span><br><span class="line">      + instance_type       = (known after apply)</span><br><span class="line">      + kafka_version       = &quot;kafka_version&quot;</span><br><span class="line">      + max_message_byte    = (known after apply)</span><br><span class="line">      + msg_retention_time  = 1300</span><br><span class="line">      + partition           = 400</span><br><span class="line">      + public_network      = (known after apply)</span><br><span class="line">      + renew_flag          = (known after apply)</span><br><span class="line">      + specifications_type = &quot;profession&quot;</span><br><span class="line">      + subnet_id           = &quot;subnet-oy1pqvzv&quot;</span><br><span class="line">      + tag_set             = (known after apply)</span><br><span class="line">      + upgrade_strategy    = 1</span><br><span class="line">      + vip                 = (known after apply)</span><br><span class="line">      + vpc_id              = &quot;vpc-4tkroxts&quot;</span><br><span class="line">      + vport               = (known after apply)</span><br><span class="line">      + zone_id             = 200002</span><br><span class="line"></span><br><span class="line">      + config &#123;</span><br><span class="line">          + auto_create_topic_enable   = true</span><br><span class="line">          + default_num_partitions     = 3</span><br><span class="line">          + default_replication_factor = 3</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      + dynamic_retention_config &#123;</span><br><span class="line">          + bottom_retention        = (known after apply)</span><br><span class="line">          + disk_quota_percentage   = (known after apply)</span><br><span class="line">          + enable                  = 1</span><br><span class="line">          + step_forward_percentage = (known after apply)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      + tags (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">Do you want to perform these actions?</span><br><span class="line">  Terraform will perform the actions described above.</span><br><span class="line">  Only &#x27;yes&#x27; will be accepted to approve.</span><br><span class="line"></span><br><span class="line">  Enter a value: yes</span><br><span class="line"></span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Creating...</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [10s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [20s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [30s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [40s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [50s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m0s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m10s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m20s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m30s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m40s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [1m50s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m0s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m10s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m20s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m30s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m40s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [2m50s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Still creating... [3m0s elapsed]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Creation complete after 3m7s [id=ckafka-9jnda3jn]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure>

<h3 id="验证创建"><a href="#验证创建" class="headerlink" title="验证创建"></a>验证创建</h3><p>在前端查看是否成功创建实例：<br><img src="/img_1.png" alt="img_1.png"></p>
<h3 id="销毁资源"><a href="#销毁资源" class="headerlink" title="销毁资源"></a>销毁资源</h3><p>执行下面的命令进行销毁：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">terraform destroy</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Reading...</span><br><span class="line">module.ckafka_instance.data.tencentcloud_availability_zones_by_product.zone: Read complete after 1s [id=2066006299]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Refreshing state... [id=ckafka-9jnda3jn]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  - destroy</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">module.ckafka_instance.tencentcloud_ckafka_instance.this will be destroyed</span></span><br><span class="line">  - resource &quot;tencentcloud_ckafka_instance&quot; &quot;this&quot; &#123;</span><br><span class="line">      - band_width          = 20 -&gt; null</span><br><span class="line">      - charge_type         = &quot;POSTPAID_BY_HOUR&quot; -&gt; null</span><br><span class="line">      - disk_size           = 200 -&gt; null</span><br><span class="line">      - disk_type           = &quot;CLOUD_BASIC&quot; -&gt; null</span><br><span class="line">      - id                  = &quot;ckafka-9jnda3jn&quot; -&gt; null</span><br><span class="line">      - instance_name       = &quot;ckafka-test&quot; -&gt; null</span><br><span class="line">      - instance_type       = 1 -&gt; null</span><br><span class="line">      - kafka_version       = &quot;0.10.2.1&quot; -&gt; null</span><br><span class="line">      - msg_retention_time  = 1300 -&gt; null</span><br><span class="line">      - partition           = 400 -&gt; null</span><br><span class="line">      - public_network      = 3 -&gt; null</span><br><span class="line">      - renew_flag          = 0 -&gt; null</span><br><span class="line">      - specifications_type = &quot;profession&quot; -&gt; null</span><br><span class="line">      - subnet_id           = &quot;subnet-oy1pqvzv&quot; -&gt; null</span><br><span class="line">      - tag_set             = &#123;&#125; -&gt; null</span><br><span class="line">      - upgrade_strategy    = 1 -&gt; null</span><br><span class="line">      - vip                 = &quot;172.17.0.3&quot; -&gt; null</span><br><span class="line">      - vpc_id              = &quot;vpc-4tkroxts&quot; -&gt; null</span><br><span class="line">      - vport               = &quot;9092&quot; -&gt; null</span><br><span class="line">      - zone_id             = 200002 -&gt; null</span><br><span class="line"></span><br><span class="line">      - config &#123;</span><br><span class="line">          - auto_create_topic_enable   = true -&gt; null</span><br><span class="line">          - default_num_partitions     = 3 -&gt; null</span><br><span class="line">          - default_replication_factor = 3 -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      - dynamic_retention_config &#123;</span><br><span class="line">          - bottom_retention        = 0 -&gt; null</span><br><span class="line">          - disk_quota_percentage   = 0 -&gt; null</span><br><span class="line">          - enable                  = 1 -&gt; null</span><br><span class="line">          - step_forward_percentage = 0 -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 0 to add, 0 to change, 1 to destroy.</span><br><span class="line"></span><br><span class="line">Do you really want to destroy all resources?</span><br><span class="line">  Terraform will destroy all your managed infrastructure, as shown above.</span><br><span class="line">  There is no undo. Only &#x27;yes&#x27; will be accepted to confirm.</span><br><span class="line"></span><br><span class="line">  Enter a value: yes</span><br><span class="line"></span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Destroying... [id=ckafka-9jnda3jn]</span><br><span class="line">module.ckafka_instance.tencentcloud_ckafka_instance.this: Destruction complete after 5s</span><br><span class="line"></span><br><span class="line">Destroy complete! Resources: 1 destroyed.</span><br></pre></td></tr></table></figure>

<h3 id="验证销毁"><a href="#验证销毁" class="headerlink" title="验证销毁"></a>验证销毁</h3><p><img src="/img_2.png" alt="img_2.png"></p>
]]></content>
  </entry>
  <entry>
    <title>operator部署验证</title>
    <url>/2025/07/kubernetes/Operator%E5%BC%80%E5%8F%91/operator%E9%83%A8%E7%BD%B2%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h1 id="1、部署命令"><a href="#1、部署命令" class="headerlink" title="1、部署命令"></a>1、部署命令</h1><p>这个是很多博客教程都在使用的部署命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make manifests</span><br><span class="line">make install</span><br><span class="line">export ENABLE_WEBHOOKS=false</span><br><span class="line">make run</span><br></pre></td></tr></table></figure>
<p>我们使用之前的demo来进行部署验证：<a href="https://hua-ri.cn/2025/07/kubernetes/Operator%E5%BC%80%E5%8F%91/operator%E5%BC%80%E5%8F%91%E8%84%9A%E6%89%8B%E6%9E%B6/">Kubernetes-Operator篇-02-脚手架熟悉</a></p>
<p>这里面涉及到的makefile的配置可以参考：<a href="https://hua-ri.cn/2025/07/kubernetes/Operator%E5%BC%80%E5%8F%91/kubebuilder%E7%9A%84makefile%E6%96%87%E4%BB%B6/">Kubernetes-Operator篇-03-kubebuilder的Makefile文件熟悉</a></p>
<p>下面让我来看看这些命令的含义，并且都是在干什么</p>
<h2 id="1-1-make-manifests"><a href="#1-1-make-manifests" class="headerlink" title="1.1 make manifests"></a>1.1 make manifests</h2><p><code>make manifests</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: manifests</span><br><span class="line">manifests: controller-gen ## Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects.</span><br><span class="line">        $(CONTROLLER_GEN) rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br></pre></td></tr></table></figure>
<p>这里主要是为了生成WebhookConfiguration、ClusterRole和CustomResourceDefinition 对象。</p>
<p>在生成了WebhookConfiguration、ClusterRole和CustomResourceDefinition 对象后，我们可以进行查看，但是不要手动去修改，因为后面的<code>make install</code>和<code>make run</code>等命令，都依赖该目标，并且因为都是使用的<code>.PHONY</code>关键字来申明的伪目标，所以每次执行<code>make install</code>和<code>make run</code>都会执行manifests依赖。</p>
<p>所以单独执行make manifests的意义是什么呢，个人观点，在一个完整部署动作中，完成了代码变更后，是需要通过<code>make manifests</code>来进行配置的生成查看的。<code>但是如果在本部署动作中，不关心生成配置的具体情况，只想走一遍流程，或者直接测试，那其实忽略不执行也ok，毕竟后面每一步都会重新生成且覆盖。</code></p>
<h2 id="1-2-make-install"><a href="#1-2-make-install" class="headerlink" title="1.2 make install"></a>1.2 make install</h2><p><code>make install</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: install</span><br><span class="line">install: manifests kustomize ## Install CRDs into the K8s cluster specified in ~/.kube/config.</span><br><span class="line">        $(KUSTOMIZE) build config/crd | $(KUBECTL) apply -f -</span><br></pre></td></tr></table></figure>

<p>先运行manifests和kustomize目标，然后使用kustomize 构建config&#x2F;crd目录中的资源，并使用kubectl将其应用到集群。</p>
<p>这里manifests目标会生成WebhookConfiguration、ClusterRole和CustomResourceDefinition 对象，并保存在config&#x2F;crd&#x2F;bases目录下。</p>
<p>而kustomize目标是进行kustomize工具的下载，如果二进制文件不存在则下载，然后生成二进制文件的软链，二进制文件只在首次下载，后续都是仅更新软链。</p>
<p>下面的命令是install实际执行的动作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(KUSTOMIZE) build config/crd | $(KUBECTL) apply -f -</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-make-run"><a href="#1-3-make-run" class="headerlink" title="1.3 make run"></a>1.3 make run</h2><p><code>make run</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: run</span><br><span class="line">run: manifests generate fmt vet ## Run a controller from your host.</span><br><span class="line">        go run ./cmd/main.go</span><br></pre></td></tr></table></figure>
<p>先运行manifests、generate、fmt和vet目标，然后使用go run命令运行cmd&#x2F;main.go文件</p>
<p>这里manifests目标会生成WebhookConfiguration、ClusterRole和CustomResourceDefinition 对象，并保存在config&#x2F;crd&#x2F;bases目录下。</p>
<p>而generate 目标是使用controller-gen工具生成包含DeepCopy、DeepCopyInto, 和DeepCopyObject方法实现的代码。</p>
<p>至于fmt和vet目标就是执行go的命令：<code>fmt ./...</code>和<code>go vet ./...</code></p>
<p>下面的命令是install实际执行的动作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go run ./cmd/main.go</span><br></pre></td></tr></table></figure>

<h3 id="1-4-环境变量ENABLE-WEBHOOKS"><a href="#1-4-环境变量ENABLE-WEBHOOKS" class="headerlink" title="1.4 环境变量ENABLE_WEBHOOKS"></a>1.4 环境变量ENABLE_WEBHOOKS</h3><p>环境变量ENABLE_WEBHOOKS控制着webhook的启用与否。</p>
<p>这段代码是kubectl生成的operator项目的main函数中启用webhook逻辑的部分：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if os.Getenv(&quot;ENABLE_WEBHOOKS&quot;) != &quot;false&quot; &#123;</span><br><span class="line">                if err = (&amp;appsv1.Myapp&#123;&#125;).SetupWebhookWithManager(mgr); err != nil &#123;</span><br><span class="line">                        setupLog.Error(err, &quot;unable to create webhook&quot;, &quot;webhook&quot;, &quot;Myapp&quot;)</span><br><span class="line">                        os.Exit(1)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里很简单粗暴的根据环境变量ENABLE_WEBHOOKS来决定是否启用webhook，os.Getenv的定义:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func Getenv(key string) string &#123;</span><br><span class="line">        testlog.Getenv(key)</span><br><span class="line">        v, _ := syscall.Getenv(key)</span><br><span class="line">        return v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Getenv(key string) (value string, found bool) &#123;</span><br><span class="line">        envOnce.Do(copyenv)</span><br><span class="line">        if len(key) == 0 &#123;</span><br><span class="line">                return &quot;&quot;, false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        envLock.RLock()</span><br><span class="line">        defer envLock.RUnlock()</span><br><span class="line"></span><br><span class="line">        i, ok := env[key]</span><br><span class="line">        if !ok &#123;</span><br><span class="line">                return &quot;&quot;, false</span><br><span class="line">        &#125;</span><br><span class="line">        s := envs[i]</span><br><span class="line">        for i := 0; i &lt; len(s); i++ &#123;</span><br><span class="line">                if s[i] == &#x27;=&#x27; &#123;</span><br><span class="line">                        return s[i+1:], true</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;, false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里返回的值，可能是空字符串，也可能是bool类型值的字符串，但是只要值不是false，就会开启webhook。</p>
<p>至于这里为什么要临时关闭webhook，因为启用webhook是需要证书的，也就是我们需要在本地安装cert-manager，并且还需要配置，在本实验项目就不搞太复杂了。</p>
<h1 id="2、CRD-调试"><a href="#2、CRD-调试" class="headerlink" title="2、CRD 调试"></a>2、CRD 调试</h1><h2 id="2-1-make-manifests"><a href="#2-1-make-manifests" class="headerlink" title="2.1 make manifests"></a>2.1 make manifests</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make manifests</span><br><span class="line">/home/king/workspace/king-devops/operator/myapp-operator/bin/controller-gen rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line"></span><br><span class="line">ls -lh config/crd/bases/</span><br><span class="line">总计 1.1M</span><br><span class="line">-rw-rw-r-- 1 king king 1.1M 10月  5 16:17 apps.kubenode.kingtest.com_myapps.yaml</span><br></pre></td></tr></table></figure>

<h2 id="2-2-make-install"><a href="#2-2-make-install" class="headerlink" title="2.2 make install"></a>2.2 make install</h2><p>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-make-install错误：dial-tcp-127-0-0-1-8080-connect-connection-refused"><a href="#2-2-1-make-install错误：dial-tcp-127-0-0-1-8080-connect-connection-refused" class="headerlink" title="2.2.1 make install错误：dial tcp 127.0.0.1:8080: connect: connection refused"></a>2.2.1 make install错误：dial tcp 127.0.0.1:8080: connect: connection refused</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br><span class="line">/home/king/workspace/king-devops/operator/myapp-operator/bin/controller-gen rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/home/king/workspace/king-devops/operator/myapp-operator/bin/kustomize build config/crd | kubectl apply -f -</span><br><span class="line">error: error validating &quot;STDIN&quot;: error validating data: failed to download openapi: Get &quot;http://localhost:8080/openapi/v2?timeout=32s&quot;: dial tcp 127.0.0.1:8080: connect: connection refused; if you choose to ignore these errors, turn validation off with --validate=false</span><br><span class="line">make: *** [Makefile:131：install] 错误 1</span><br></pre></td></tr></table></figure>

<p>这个错误很诡异： dial tcp 127.0.0.1:8080: connect: connection refused</p>
<p>首先集群是存在的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kind get clusters</span><br><span class="line">myk8s-test</span><br></pre></td></tr></table></figure>

<p>其次已经使用下面的命令将集群信息，设置进去kubectl的上下文里：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kubectl cluster-info --context kind-myk8s-test</span><br></pre></td></tr></table></figure>

<p>sudo kubectl cluster-info –context kind-myk8s-test</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kubectl get nodes</span><br><span class="line">NAME                       STATUS   ROLES           AGE   VERSION</span><br><span class="line">myk8s-test-control-plane   Ready    control-plane   43h   v1.31.0</span><br><span class="line">myk8s-test-worker          Ready    &lt;none&gt;          43h   v1.31.0</span><br><span class="line">myk8s-test-worker2         Ready    &lt;none&gt;          43h   v1.31.0</span><br></pre></td></tr></table></figure>

<p>进一步测试，分别执行<code>kubectl version</code>和<code>kubectl cluster-info dump</code>都遇见了类似的错误：</p>
<p><code>kubectl version</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl version</span><br><span class="line">Client Version: v1.31.1</span><br><span class="line">Kustomize Version: v5.4.2</span><br><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure>

<p><code>kubectl cluster-info dump</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl cluster-info dump</span><br><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure>

<p>但是很悲催的是，忘记将kind集群的kubeconfig导出到本地，我的理解是，虽然kubectl上下文是有集群kubeconfig的，但是本地并没有，简单来说，就是这个信息是kubectl自身保存的，不是直接使用的系统上存储的kubeconfig</p>
<p>使用下面的命令，将kubeconfig信息保存在<code>$HOME/.kube/config内</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kind export kubeconfig --name=myk8s-test --kubeconfig=$HOME/.kube/config</span><br></pre></td></tr></table></figure>

<p>再执行<code>make install</code>命令，本问题已经解决，但是新的问题出现了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br><span class="line">/home/king/workspace/king-devops/operator/myapp-operator/bin/controller-gen rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/home/king/workspace/king-devops/operator/myapp-operator/bin/kustomize build config/crd | kubectl apply -f -</span><br><span class="line">The CustomResourceDefinition &quot;myapps.apps.kubenode.kingtest.com&quot; is invalid: metadata.annotations: Too long: must have at most 262144 bytes</span><br><span class="line">make: *** [Makefile:131：install] 错误 1</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-make-install错误：metadata-annotations-Too-long-must-have-at-most-262144-bytes"><a href="#2-2-2-make-install错误：metadata-annotations-Too-long-must-have-at-most-262144-bytes" class="headerlink" title="2.2.2 make install错误：metadata.annotations: Too long: must have at most 262144 bytes"></a>2.2.2 make install错误：metadata.annotations: Too long: must have at most 262144 bytes</h3><p>kubebuilder的github issues中，修复过这个问题: <a href="https://github.com/kubernetes-sigs/kubebuilder/pull/2862/commits/2c5b9edf614444acd43ae5f65af1702a5ed63ed6">https://github.com/kubernetes-sigs/kubebuilder/pull/2862/commits/2c5b9edf614444acd43ae5f65af1702a5ed63ed6</a></p>
<p>修复方法：打开Makefile，在 manifests 命令处，修改 crd 为 crd:maxDescLen&#x3D;0</p>
<p>原始的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: manifests</span><br><span class="line">manifests: controller-gen ## Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects.</span><br><span class="line">        $(CONTROLLER_GEN) rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br></pre></td></tr></table></figure>

<p>修复后的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: manifests</span><br><span class="line">manifests: controller-gen ## Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects.</span><br><span class="line">        $(CONTROLLER_GEN) rbac:roleName=manager-role crd:maxDescLen=0 webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br></pre></td></tr></table></figure>

<p>问题解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br><span class="line">/home/king/workspace/king-devops/operator/myapp-operator/bin/controller-gen rbac:roleName=manager-role crd:maxDescLen=0 webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/home/king/workspace/king-devops/operator/myapp-operator/bin/kustomize build config/crd | kubectl apply -f -</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/my</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-make-install验证"><a href="#2-2-3-make-install验证" class="headerlink" title="2.2.3 make install验证"></a>2.2.3 make install验证</h3><p>查看安装结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get crd</span><br><span class="line">NAME                                CREATED AT</span><br><span class="line">myapps.apps.kubenode.kingtest.com   2024-10-05T11:56:22Z</span><br></pre></td></tr></table></figure>
<p>已经可以看到我们定义的crd了。</p>
<h2 id="2-3-make-run"><a href="#2-3-make-run" class="headerlink" title="2.3 make run"></a>2.3 make run</h2><p>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export ENABLE_WEBHOOKS=false</span><br><span class="line">make run</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make run</span><br><span class="line">/home/king/workspace/king-devops/operator/myapp-operator/bin/controller-gen rbac:roleName=manager-role crd:maxDescLen=0 webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/home/king/workspace/king-devops/operator/myapp-operator/bin/controller-gen object:headerFile=&quot;hack/boilerplate.go.txt&quot; paths=&quot;./...&quot;</span><br><span class="line">go fmt ./...</span><br><span class="line">go vet ./...</span><br><span class="line">go run ./cmd/main.go</span><br><span class="line">2024-10-05T20:29:02+08:00       INFO    setup   starting manager</span><br><span class="line">2024-10-05T20:29:02+08:00       INFO    starting server &#123;&quot;name&quot;: &quot;health probe&quot;, &quot;addr&quot;: &quot;[::]:8081&quot;&#125;</span><br><span class="line">2024-10-05T20:29:02+08:00       INFO    Starting EventSource    &#123;&quot;controller&quot;: &quot;myapp&quot;, &quot;controllerGroup&quot;: &quot;apps.kubenode.kingtest.com&quot;, &quot;controllerKind&quot;: &quot;Myapp&quot;, &quot;source&quot;: &quot;kind source: *v1.Myapp&quot;&#125;</span><br><span class="line">2024-10-05T20:29:02+08:00       INFO    Starting Controller     &#123;&quot;controller&quot;: &quot;myapp&quot;, &quot;controllerGroup&quot;: &quot;apps.kubenode.kingtest.com&quot;, &quot;controllerKind&quot;: &quot;Myapp&quot;&#125;</span><br><span class="line">2024-10-05T20:29:02+08:00       INFO    Starting workers        &#123;&quot;controller&quot;: &quot;myapp&quot;, &quot;controllerGroup&quot;: &quot;apps.kubenode.kingtest.com&quot;, &quot;controllerKind&quot;: &quot;Myapp&quot;, &quot;worker count&quot;: 1&#125;</span><br></pre></td></tr></table></figure>

<p>已经成功启动！！！</p>
<h2 id="2-4-执行debug"><a href="#2-4-执行debug" class="headerlink" title="2.4 执行debug"></a>2.4 执行debug</h2><h3 id="2-4-1-启动debug"><a href="#2-4-1-启动debug" class="headerlink" title="2.4.1 启动debug"></a>2.4.1 启动debug</h3><p>在上面执行了以下步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make manifests</span><br><span class="line">make install</span><br><span class="line">export ENABLE_WEBHOOKS=false</span><br><span class="line">make run</span><br></pre></td></tr></table></figure>
<p>我们先将make run运行的controller停止，然后打开operator项目，在项目的调谐函数内打上断点，然后直接以debug模式启动。</p>
<p>打断点<br><img src="/img_5.png" alt="img_5.png"></p>
<p>别忘了设置环境变量，关闭webhook<br><img src="/img_6.png" alt="img_6.png"></p>
<p>以debug方式启动：<br><img src="/img_7.png" alt="img_7.png"></p>
<p>执行结果<br><img src="/img_8.png" alt="img_8.png"></p>
<p>接下来，我们来apply一个资源，测试一下。</p>
<h3 id="2-4-2-crd测试"><a href="#2-4-2-crd测试" class="headerlink" title="2.4.2 crd测试"></a>2.4.2 crd测试</h3><p>编写一个测试的yaml：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps.kubenode.kingtest.com/v1</span><br><span class="line">kind: Myapp</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-sample</span><br><span class="line">spec:</span><br><span class="line">  foo: &quot;test value&quot;</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: myapp</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: myapp</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: myapp-container</span><br><span class="line">        image: nginx:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>

<p>将测试yaml通过kubectl apply进去集群:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kubectl apply -f myapptest.yaml</span><br><span class="line">myapp.apps.kubenode.kingtest.com/myapp-sample created</span><br></pre></td></tr></table></figure>

<p>然后controller的调谐函数成功断住<br><img src="/img_9.png" alt="img_9.png"></p>
<p>再向下执行一步<br><img src="/img_10.png" alt="img_10.png"></p>
<p>在终端里已经成功打印出来代码里的日志：<br><img src="/img_11.png" alt="img_11.png"></p>
<p>通过kubectl查看crd状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kubectl get Myapp -A -owide</span><br><span class="line">NAMESPACE   NAME           AGE</span><br><span class="line">default     myapp-sample   14m</span><br></pre></td></tr></table></figure>
<p>到此都是符合预期的。</p>
<h1 id="4-构建CRD镜像并部署进k8s"><a href="#4-构建CRD镜像并部署进k8s" class="headerlink" title="4 构建CRD镜像并部署进k8s"></a>4 构建CRD镜像并部署进k8s</h1><p>上面我们是在本地运行的controller，那么在实际中该怎么办呢。</p>
<p>答案是将controller打包成docker镜像，然后部署进集群。</p>
<p>构建镜像并推送至你的镜像仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make docker-build docker-push IMG=&lt;some-registry&gt;/&lt;project-name&gt;:tag</span><br></pre></td></tr></table></figure>

<p>看下makefile的定义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: docker-build</span><br><span class="line">docker-build: ## Build docker image with the manager.</span><br><span class="line">        $(CONTAINER_TOOL) build -t $&#123;IMG&#125; .</span><br><span class="line"></span><br><span class="line">.PHONY: docker-push</span><br><span class="line">docker-push: ## Push docker image with the manager.</span><br><span class="line">        $(CONTAINER_TOOL) push $&#123;IMG&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是使用CONTAINER_TOOL(默认为docker)构建并推送docker镜像，并使用IMG变量指定镜像名称和标签<br>指定镜像将controller部署进你的集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make deploy IMG=&lt;some-registry&gt;/&lt;project-name&gt;:tag</span><br></pre></td></tr></table></figure>

<p>查看makefile定义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: deploy</span><br><span class="line">deploy: manifests kustomize ## Deploy controller to the K8s cluster specified in ~/.kube/config.</span><br><span class="line">        cd config/manager &amp;&amp; $(KUSTOMIZE) edit set image controller=$&#123;IMG&#125;</span><br><span class="line">        $(KUSTOMIZE) build config/default | $(KUBECTL) apply -f -</span><br></pre></td></tr></table></figure>

<ul>
<li>先运行manifests和kustomize目标</li>
<li>使用kustomize设置controller镜像为IMG</li>
<li>使用kustomize构建config&#x2F;default目录中的资源，并使用kubectl将其应用到集群</li>
</ul>
<h1 id="5-删除controller部署和卸载CRD"><a href="#5-删除controller部署和卸载CRD" class="headerlink" title="5 删除controller部署和卸载CRD"></a>5 删除controller部署和卸载CRD</h1><p>删除controller部署：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make undeploy</span><br></pre></td></tr></table></figure>

<p>查看makefile定义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: undeploy</span><br><span class="line">undeploy: kustomize ## Undeploy controller from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found=true to ignore resource not found errors during deletion.</span><br><span class="line">        $(KUSTOMIZE) build config/default | $(KUBECTL) delete --ignore-not-found=$(ignore-not-found) -f -</span><br></pre></td></tr></table></figure>

<p>使用kustomize 构建config&#x2F;default目录中的资源，并使用kubectl将其从集群中删除。可以通过ignore-not-found&#x3D;true忽略资源未找到的错误</p>
<p>从集群卸载CRD：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make uninstall</span><br></pre></td></tr></table></figure>

<p>查看makefile定义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.PHONY: uninstall</span><br><span class="line">uninstall: manifests kustomize ## Uninstall CRDs from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found=true to ignore resource not found errors during deletion.</span><br><span class="line">        $(KUSTOMIZE) build config/crd | $(KUBECTL) delete --ignore-not-found=$(ignore-not-found) -f -</span><br></pre></td></tr></table></figure>
<ul>
<li>先运行manifests和kustomize目标</li>
<li>使用kustomize 构建config&#x2F;crd目录中的资源，并使用kubectl将其从集群中删除，可以通过ignore-not-found&#x3D;true忽略资源未找到的错误</li>
</ul>
<h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h1><p>这是在我们本地运行的controller，我在最初一直想不通是怎么连接的集群的，知道想起了最初的client-go的使用。</p>
<p>在看本文的同学，肯定是听说过，甚至使用过client-go的，我们可以使用client-go去实现一些小工具，比如说某个namespace下pod的查询，甚至可以获取node的列表，pod的全部信息等等，只要是kubectl可以做的，都可以通过client-go来实现，并且可以做更复杂的场景。</p>
<p>我们是可以在工具里指定kubeconfig的路径的，让client-go去读取，并渲染对应的client，然后和对应集群的apiserver做交互。</p>
<p>知道了这点，那么问题来了，operator是怎么做的呢，operator其实是使用的controller-runtime库，他和client-go有什么区别呢，他是client-go以及其他库的更上一层封装。</p>
<p>所以虽然没具体看，但是controller-runtime肯定是默认读取的$HOME&#x2F;.kube&#x2F;config文件的kubeconfig，至于可不可以指定其他的kubeconfig，理论上是可以的，因为就是指定下kubeconfig的路径，然后去读取渲染client，这里和自己直接使用client-go去实现是一样的逻辑。</p>
<p>但是，controller-runtime究竟支不支持，还需要自己去找一下源码或者资料，因为本地运行controller这本身肯定是不建议的，所以不支持也是说得过去的。</p>
]]></content>
  </entry>
</search>
